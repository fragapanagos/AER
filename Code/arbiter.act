// This file contains PRS for the arbiter circuits
import "lib/globals.act";
import "channel.act";

defproc ARB2 (globals g; port a1, a2) {
    // The basic 2-input arbiter
    bool _a1o,_a2o;

    spec {
        mk_excllo(_a1o, _a2o)
    }

    //Cross-Coupled NANDs
    prs<g.Vdd,g.GND> {
        a1.i & _a2o   => _a1o- //_a1i NAND
        a2.i & _a1o   => _a2o- //_a2i NAND
    }

    //Filter
    prs<g.Vdd,g.GND> {
        ~_a1o & _a2o  -> a1.o+
        _a1o          -> a1.o-

        ~_a2o & _a1o -> a2.o+
        _a2o         -> a2.o-
    }
}

defproc C_ARB (globals g; port s, c) {
    bool ci_hat, si_hat, u, cso, sso;
    ARB2 arb(g,,);
    arb.a1.i = c.i;
    arb.a2.i = s.i;
    arb.a1.o = ci_hat;
    arb.a2.o = si_hat;

    prs<g.Vdd,g.GND> {
        ci_hat & s.i & ~sso -> cso+
        ~ci_hat -> cso-

        cso & ~s.i -> c.o+
        ~cso | s.i -> c.o-

        si_hat & ~c.o -> sso+
        ~si_hat | c.o -> sso-

        cso | sso => s.o+
    }
}

namespace arbiter_a {
    // contains the arbiter with active S ports
    export
    defproc CTRL_TEST (globals g; port s1, s2, p) {
        // test version of CTRL sequencing circuit
        // does not use children as start signal
        // assumes both children are always requesting
        bool x, y;
        prs<g.Vdd,g.GND> {
            g._sReset & ~y -> p.o+
            g.pReset | ~s2.i & ~x & y -> p.o-

            g._sReset & x & ~y -> s1.o+
            g.pReset | ~x | y -> s1.o-

            g._sReset & ~s1.i & x & y -> s2.o+
            g.pReset | ~x -> s2.o-

            g._sReset & p.i & ~y -> x+
            g.pReset | s2.i & y -> x-

            s1.i -> y+
            ~p.i -> y-
        }
    }
    
    export
    defproc CTRL (globals g; bool c1i, c2i; port s1, s2, p) {
        bool x, y;
        prs<g.Vdd,g.GND> {
            g._sReset & (c1i | c2i) & ~y -> p.o+
            g.pReset | ~s2.i & ~x & y -> p.o-

            g._sReset & x & ~y -> s1.o+
            g.pReset | ~x | y -> s1.o-

            g._sReset & ~s1.i & x & y -> s2.o+
            g.pReset | ~x -> s2.o-

            g._sReset & p.i & ~y -> x+
            g.pReset | s2.i & y -> x-

            s1.i -> y+
            ~p.i -> y-
        }
    }
} // end namespace arbiter_a

namespace arbiter_p {
    // contains the arbiter with passive S ports
    export
    defproc CTRL_TEST (globals g; port s1, s2, p) {
        // test version of CTRL sequencing circuit
        // does not use children as start signal
        // assumes both children are always requesting
        prs<g.Vdd,g.GND> {
            g._sReset & ~s2.o -> p.o+
            g.pReset | ~s2.i & s2.o -> p.o-
    
            p.i & s1.i -> s1.o+
            ~p.i -> s1.o-

            ~s1.i & s1.o & s2.i -> s2.o+
            ~s1.o -> s2.o-
        }
    }
    
    export
    defproc CTRL (globals g; bool c1i, c2i; port s1, s2, p) {
        prs<g.Vdd,g.GND> {
            g._sReset & (c1i | c2i) & ~s2.o -> p.o+
            g.pReset | ~s2.i & s2.o -> p.o-
    
            p.i & s1.i -> s1.o+
            ~p.i -> s1.o-

            ~s1.i & s1.o & s2.i -> s2.o+
            ~s1.o -> s2.o-
        }
    }
    
    export
    defproc C_S (globals g; port c, a) {
        bool x, _co, _ao;
        prs<g.Vdd,g.GND> {
            g._sReset & (a.i | x) -> _co-
            g.pReset | ~a.i & ~x -> _co+

            g._sReset & c.i & x -> _ao-
            g.pReset | ~c.i | ~x -> _ao+

            ~c.i & ~a.i -> x+
            a.i -> x-

            _co => c.o-
            _ao => a.o-
        }
    }
} // end namespace arbiter_p

