// This file contains PRS for the arbiter circuits
import "lib/globals.act";
import "channel.act";
import "test.act";

namespace arbiter {
    // contains arbiter related processes. 
    defproc CTRL (globals g; bool _ci[2], s0i, s0o, _s1i, s1o, pi, po) {
        // sequences between children and parent communications
        bool x, y, _y;
        prs<g.Vdd,g.GND> {
            g._sReset & (~_ci[0] | ~_ci[1]) & ~_y -> po+
            g.pReset | _s1i & x & _y -> po-
    
            g._sReset & ~x & ~_y -> s0o+
            g.pReset | x | _y -> s0o-
    
            g._sReset & ~s0i & ~x & ~y -> s1o+
            g.pReset | x -> s1o-
    
            g.pReset | ~_s1i & ~y -> x+
            g._sReset & pi & y -> x-
    
            ~pi -> y+
            s0i -> y-

            y => _y-
        }
    }
    
    export
    defproc CTRL_TEST (globals g; bool s0i, s0o, s1i, s1o, pi, po) {
        // test version of CTRL sequencing circuit
        // does not use children as start signal
        // assumes both children are always requesting
        bool x, y, _y, _s1i;
        prs<g.Vdd,g.GND> {
            g._sReset & ~_y -> po+
            g.pReset | _s1i & x & _y -> po-
    
            g._sReset & ~x & ~_y -> s0o+
            g.pReset | x | _y -> s0o-
    
            g._sReset & ~s0i & ~x & ~y -> s1o+
            g.pReset | x -> s1o-
    
            g.pReset | ~_s1i & ~y -> x+
            g._sReset & pi & y -> x-
    
            ~pi -> y+
            s0i -> y-

            y => _y-
            s1i => _s1i-
        }
    }
    
    export
    defproc ARB (bool i[2], o[2]) {
        // The basic 2-input arbiter
        bool _x[2];
    
        spec {
            mk_excllo(_x[0], _x[1])
        }
    
        //Cross-Coupled NANDs
        prs {
            i[0] & _x[1]  => _x[0]-
            i[1] & _x[0]  => _x[1]-
        }
    
        //Filter
        prs {
            ~_x[0] & _x[1] -> o[0]+
            _x[0]          -> o[0]-
    
            ~_x[1] & _x[0] -> o[1]+
            _x[1]          -> o[1]-
        }
    }
    
    export
    defproc _ARB (bool _i[2], _o[2]) {
        // The basic 2-input arbiter with active low inputs/outputs
        bool x[2];
    
        spec {
            mk_exclhi(x[0], x[1])
        }
    
        //Cross-Coupled NORs
        prs {
            _i[0] | x[1] => x[0]-
            _i[1] | x[0] => x[1]-
        }
    
        //Filter
        prs {
            x[0] & ~x[1] -> _o[0]-
            ~x[0]        -> _o[0]+
    
            x[1] & ~x[0] -> _o[1]-
            ~x[1]        -> _o[1]+
        }
    }
    
    export
    defproc C_ARB (bool _si, _so, _ci, co) {
        // controlled arbiter cell for use with CTRL
        // arbitrates between child request and CTRL request
        bool cso, sso;
        bool _ci_hat, _si_hat, _co;
        _ARB arb(,);
        arb._i[0] = _ci;
        arb._i[1] = _si;
        arb._o[0] = _ci_hat;
        arb._o[1] = _si_hat;
    
        prs {
            ~_ci_hat & ~_si & ~sso -> cso+
            _ci_hat -> cso-
    
            _si & cso -> _co-
            ~_si | ~cso -> _co+
    
            ~_si_hat & ~co -> sso+
            _si_hat | co -> sso-
    
            cso | sso => _so-

            _co => co-
        }
    }

    export 
    defproc H_ARB (globals g; bool _ci[2], co[2], pi, _po) {
        // heirarchical arbiter cell
        // can be arranged in a binary tree to service more than 2 children
        CTRL ctrl(g, _ci,,,,, pi,);
        C_ARB c0_arb(,, _ci[0], co[0]), c1_arb(,, _ci[1], co[1]);

        bool _s0a, s0b, _s1a;
        prs {
            ctrl.po => _po-

            ctrl.s0o => _s0a-
            c0_arb._so => s0b- 
            ctrl.s1o => _s1a-
        }

        ctrl.s0i = s0b;
        c0_arb._si = _s0a;
        ctrl._s1i = c1_arb._so;
        c1_arb._si = _s1a;
    }

    template <pint N>
    defproc _N_ARB (globals g; bool _ci[N], co[N], pi, _po) {
        // recursive utility to build an N-way arbiter tree
        [ N = 1 ->
            _ci[0] = _po;
            co[0] = pi;
        [] N = 2 ->
            H_ARB h_arb(g, _ci, co, pi, _po);
        [] N > 2 ->
            _N_ARB<N/2>   _n_arb0(g, _ci[0..N/2-1], co[0..N/2-1],,);
            _N_ARB<N-N/2> _n_arb1(g, _ci[N/2..N-1], co[N/2..N-1],,);
            H_ARB h_arb(g,,, pi, _po);
            h_arb._ci[0] = _n_arb0._po;
            h_arb._ci[1] = _n_arb1._po;
            h_arb.co[0] = _n_arb0.pi;
            h_arb.co[1] = _n_arb1.pi;
        ]
    }

    export
    template <pint N>
    defproc N_ARB (globals g; bool i[N], o[N]) {
        // N-way arbiter
        bool _i[N];
        _N_ARB<N> _n_arb(g, _i, o,,);
        prs {
            // connect top of tree back to itself
            _n_arb._po => _n_arb.pi-
            // connect child ports to arbiter leaves
            (: n : N : i[n] => _i[n]-)
        }
    }

    namespace test {
        export
        defproc TEST_CTRL_TEST (globals g) {
            // tests CTRL_TEST
            passive_handshaker<2> s(,);
            passive_handshaker<1> p(,);
            CTRL_TEST ctrl(g,,,,,,);
            
            ctrl.po = p.i[0];
            ctrl.pi = p.o[0];
            ctrl.s0i = s.o[0];
            ctrl.s0o = s.i[0];
            ctrl.s1i = s.o[1];
            ctrl.s1o = s.i[1];
        }
        
        export
        defproc TEST_ARB (globals g) {
            // tests ARB
            active_handshaker<2> c(g,,);
            ARB arb(,);
            
            c.o = arb.i;
            c.i = arb.o;
        }

        export
        defproc TEST_ARB_LOW (globals g) {
            // tests ARB with active low inputs
            active_low_handshaker<2> c(g,,);
            _ARB arb(,);
            
            c._o = arb._i;
            c._i = arb._o;
        }

        defproc C_ARB_handshaker (globals g; bool _si, _so, ci, _co) {
            // used in TEST_C_ARB
            prs<g.Vdd,g.GND> {
                g.pReset | ~_si -> _so+
                g._sReset & _si -> _so-

                g.pReset | ci -> _co+
                g._sReset & ~ci -> _co-
            }
        }

        export
        defproc TEST_C_ARB (globals g) {
            C_ARB_handshaker c(g,,,,);
            C_ARB c_arb(,,,);
            
            c_arb._si = c._so;
            c_arb._so = c._si;
            c_arb._ci = c._co;
            c_arb.co = c.ci;
        }

        export 
        defproc TEST_H_ARB (globals g) {
            // tests H_ARB
            active_handshaker<2> c(g,,);
            H_ARB h_arb(g,, c.i,,);
            
            // connect top of H_ARB back to itself
            prs<g.Vdd,g.GND> {
                h_arb._po => h_arb.pi-

                c.o[0] => h_arb._ci[0]-
                c.o[1] => h_arb._ci[1]-
            }
        }

        export
        template<pint N>
        defproc TEST_N_ARB (globals g) {
            // tests N_ARB
            N_ARB<N> n_arb(g,,);
            active_handshaker<N> c(g,,);

            c.o = n_arb.i;
            c.i = n_arb.o;
        }

        export
        template<pint N>
        defproc TEST_N_ARB_HALF_EVEN (globals g) {
            // tests N_ARB with only even ports active
            N_ARB<N> n_arb(g,,);
            active_handshaker<N/2> c(g,,);

            // connect children to arbiter tree ports
            (; n : N/2 : 
                c.o[n] = n_arb.i[2*n];
                c.i[n] = n_arb.o[2*n];
            )

            // connect dangling arbiter tree ports to GND
            (; n : N/2 : 
                n_arb.i[2*n+1] = g.GND;
            )
        }

        export
        template<pint N>
        defproc TEST_N_ARB_HALF_ODD (globals g) {
            // tests N_ARB with only odd ports active
            N_ARB<N> n_arb(g,,);
            active_handshaker<N/2> c(g,,);

            // connect children to arbiter tree ports
            (; n : N/2 : 
                c.o[n] = n_arb.i[2*n+1];
                c.i[n] = n_arb.o[2*n+1];
            )

            // connect dangling arbiter tree ports to GND
            (; n : N/2 : 
                n_arb.i[2*n] = g.GND;
            )
        }

        export
        template<pint N>
        defproc TEST_N_ARB_HALF_MID (globals g) {
            // tests N_ARB with only middle ports active
            N_ARB<N> n_arb(g,,);
            active_handshaker<N/2> c(g,,);

            // connect children to arbiter tree ports
            (; n : N/2 : 
                c.o[n] = n_arb.i[N/4+n];
                c.i[n] = n_arb.o[N/4+n];
            )

            // connect dangling arbiter tree ports to GND
            (; n : N/4 : 
                n_arb.i[n] = g.GND;
                n_arb.i[3*N/4+n] = g.GND;
            )
        }
    } // end namespace test
} // end namespace arbiter
