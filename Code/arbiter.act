// This file contains PRS for the arbiter circuits
import "lib/globals.act";
import "channel.act";
import "test.act";

namespace arbiter {
    // contains arbiter related processes. 
    defproc ARB_CTRL (globals g; bool c1i, c2i; port s1, s2, p) {
        // sequences between children and parent communications
        bool x, y;
        prs<g.Vdd,g.GND> {
            g._sReset & (c1i | c2i) & ~y -> p.o+
            g.pReset | ~s2.i & ~x & y -> p.o-
    
            g._sReset & x & ~y -> s1.o+
            g.pReset | ~x | y -> s1.o-
    
            g._sReset & ~s1.i & x & y -> s2.o+
            g.pReset | ~x -> s2.o-
    
            g._sReset & p.i & ~y -> x+
            g.pReset | s2.i & y -> x-
    
            s1.i -> y+
            ~p.i -> y-
        }
    }
    
    defproc ARB_CTRL_TEST (globals g; port s1, s2, p) {
        // test version of CTRL sequencing circuit
        // does not use children as start signal
        // assumes both children are always requesting
        bool x, y;
        prs<g.Vdd,g.GND> {
            g._sReset & ~y -> p.o+
            g.pReset | ~s2.i & ~x & y -> p.o-
    
            g._sReset & x & ~y -> s1.o+
            g.pReset | ~x | y -> s1.o-
    
            g._sReset & ~s1.i & x & y -> s2.o+
            g.pReset | ~x -> s2.o-
    
            g._sReset & p.i & ~y -> x+
            g.pReset | s2.i & y -> x-
    
            s1.i -> y+
            ~p.i -> y-
        }
    }
    
    defproc ARB (globals g; port a1, a2) {
        // The basic 2-input arbiter
        bool _a1o,_a2o;
    
        spec {
            mk_excllo(_a1o, _a2o)
        }
    
        //Cross-Coupled NANDs
        prs<g.Vdd,g.GND> {
            a1.i & _a2o   => _a1o- //_a1i NAND
            a2.i & _a1o   => _a2o- //_a2i NAND
        }
    
        //Filter
        prs<g.Vdd,g.GND> {
            ~_a1o & _a2o  -> a1.o+
            _a1o          -> a1.o-
    
            ~_a2o & _a1o -> a2.o+
            _a2o         -> a2.o-
        }
    }
    
    defproc ARB_C (globals g; port s, c) {
        // arbiter cell for use with CTRL
        // arbitrates between child request and CTRL request
        bool ci_hat, si_hat, cso, sso;
        ARB arb(g,,);
        arb.a1.i = c.i;
        arb.a2.i = s.i;
        arb.a1.o = ci_hat;
        arb.a2.o = si_hat;
    
        prs<g.Vdd,g.GND> {
            ci_hat & s.i & ~sso -> cso+
            ~ci_hat -> cso-
    
            cso & ~s.i -> c.o+
            ~cso | s.i -> c.o-
    
            si_hat & ~c.o -> sso+
            ~si_hat | c.o -> sso-
    
            cso | sso => s.o+
        }
    }

    export 
    defproc H_ARB (globals g; port c1, c2, p) {
        // heirarchical arbiter cell
        // can be arranged in a binary tree to service more than 2 children
        ARB_CTRL ctrl(g,,,,,);
        ARB_C c1_arb(g,,), c2_arb(g,,);
        
        ctrl.c1i = c1.i;
        ctrl.c2i = c2.i;
        ctrl.s1.i = c1_arb.s.o;
        ctrl.s1.o = c1_arb.s.i;
        ctrl.s2.i = c2_arb.s.o;
        ctrl.s2.o = c2_arb.s.i;
        ctrl.p.o = p.o;
        ctrl.p.i = p.i;
        
        c1_arb.c.i = c1.i;
        c2_arb.c.i = c2.i;
        c1_arb.c.o = c1.o;
        c2_arb.c.o = c2.o;
    }

    export
    template <pint N>
    defproc ARB_TREE (globals g; port c[N]) {
        // arbiter tree servicing N children
        H_ARB h_arb[N-1];

        // connect globals to arbiters
        (; i : N-1 : h_arb[i].g=g;) 
        
        // connect arbiters in tree
        (; i : N-2 : 
            [ (i%2) = 0 -> 
                h_arb[i].p.o = h_arb[(N+i)/2].c1.i;
                h_arb[i].p.i = h_arb[(N+i)/2].c1.o;
            [] (i%2) = 1 ->
                h_arb[i].p.o = h_arb[(N+i)/2].c2.i;
                h_arb[i].p.i = h_arb[(N+i)/2].c2.o;
            ]
        )
        
        // connect top of arbiter tree back to itself
        prs<g.Vdd,g.GND> {
            h_arb[N-2].p.o => h_arb[N-2].p.i+
        }

        // connect children ports to arbiter tree leaves
        (; i : N : 
            [ (i%2) = 0 -> 
               c[i] = h_arb[i/2].c1;
            [] (i%2) = 1 ->
               c[i] = h_arb[i/2].c2;
            ]
        )
    }

    export
    defproc TEST_ARB_CTRL_TEST (globals g) {
        // tests ARB_CTRL_TEST
        passive_handshaker s1(g,,), s2(g,,), p(g,,);
        ARB_CTRL_TEST ctrl(g,,,);
        
        ctrl.p.o = p.i;
        ctrl.p.i = p.o;
        ctrl.s1.i = s1.o;
        ctrl.s1.o = s1.i;
        ctrl.s2.i = s2.o;
        ctrl.s2.o = s2.i;
    }
    
    export
    defproc TEST_ARB (globals g) {
        // tests ARB
        active_handshaker c1(g,,), c2(g,,);
        ARB a(g,,);
        
        c1.o = a.a1.i;
        c1.i = a.a1.o;
        c2.o = a.a2.i;
        c2.i = a.a2.o;
    }

    export 
    defproc TEST_H_ARB (globals g) {
        // tests H_ARB
        passive_handshaker p(g,,);
        active_handshaker c1(g,,), c2(g,,);
        H_ARB h_arb(g,,,);
        
        h_arb.c1.i = c1.o;
        h_arb.c2.i = c2.o;
        h_arb.c1.o = c1.i;
        h_arb.c2.o = c2.i;
        h_arb.p.o = p.i;
        h_arb.p.i = p.o;
    }

    export
    template<pint N>
    defproc TEST_ARB_TREE (globals g) {
        // tests ARB_TREE
        ARB_TREE<N> arb_tree(g,);
        active_handshaker c[N];

        // connect globals to chidren
        (; i : N : c[i].g=g;) 

        // connect children to arbiter tree ports
        (; i : N : 
            c[i].o = arb_tree.c[i].i;
            c[i].i = arb_tree.c[i].o;
        )
    }
} // end namespace arbiter
