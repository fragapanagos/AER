// This file contains PRS for the arbiter circuits
import "lib/globals.act";
import "channel.act";
import "test.act";

namespace arbiter {
    // contains arbiter related processes. 
    defproc CTRL (globals g; bool _c1i, _c2i; port s1, s2, p) {
        // sequences between children and parent communications
        // s2.i is active low from H_ARB environment
        bool x, y, _y;
        prs<g.Vdd,g.GND> {
            g._sReset & (~_c1i | ~_c2i) & ~_y -> p.o+
            g.pReset | s2.i & x & _y -> p.o-
    
            g._sReset & ~x & ~_y -> s1.o+
            g.pReset | x | _y -> s1.o-
    
            g._sReset & ~s1.i & ~x & ~y -> s2.o+
            g.pReset | x -> s2.o-
    
            g.pReset | ~s2.i & ~y -> x+
            g._sReset & p.i & y -> x-
    
            ~p.i -> y+
            s1.i -> y-

            y => _y-
        }
    }
    
    export
    defproc CTRL_TEST (globals g; port s1, s2, p) {
        // test version of CTRL sequencing circuit
        // does not use children as start signal
        // assumes both children are always requesting
        bool x, y, _y, _s2i;
        prs<g.Vdd,g.GND> {
            g._sReset & ~_y -> p.o+
            g.pReset | _s2i & x & _y -> p.o-
    
            g._sReset & ~x & ~_y -> s1.o+
            g.pReset | x | _y -> s1.o-
    
            g._sReset & ~s1.i & ~x & ~y -> s2.o+
            g.pReset | x -> s2.o-
    
            g.pReset | ~_s2i & ~y -> x+
            g._sReset & p.i & y -> x-
    
            ~p.i -> y+
            s1.i -> y-

            y => _y-
            s2.i => _s2i-
        }
    }
    
    export
    defproc ARB (globals g; port a1, a2) {
        // The basic 2-input arbiter
        bool _a1, _a2;
    
        spec {
            mk_excllo(_a1, _a2)
        }
    
        //Cross-Coupled NANDs
        prs<g.Vdd,g.GND> {
            a1.i & _a2  => _a1-
            a2.i & _a1  => _a2-
        }
    
        //Filter
        prs<g.Vdd,g.GND> {
            ~_a1 & _a2  -> a1.o+
            _a1         -> a1.o-
    
            ~_a2 & _a1 -> a2.o+
            _a2        -> a2.o-
        }
    }
    
    export
    defproc ARB_LOW (globals g; port _a1, _a2) {
        // The basic 2-input arbiter with active low inputs/outputs
        bool a1, a2;
    
        spec {
            mk_exclhi(a1, a2)
        }
    
        //Cross-Coupled NORs
        prs<g.Vdd,g.GND> {
            _a1.i | a2 => a1-
            _a2.i | a1 => a2-
        }
    
        //Filter
        prs<g.Vdd,g.GND> {
            a1 & ~a2 -> _a1.o-
            ~a1      -> _a1.o+
    
            a2 & ~a1 -> _a2.o-
            ~a2      -> _a2.o+
        }
    }
    
    export
    defproc C_ARB (globals g; port _s; bool _ci, co) {
        // controlled arbiter cell for use with CTRL
        // arbitrates between child request and CTRL request
        bool cso, sso;
        bool _ci_hat, _si_hat, _co;
        ARB_LOW arb(g,,);
        arb._a1.i = _ci;
        arb._a2.i = _s.i;
        arb._a1.o = _ci_hat;
        arb._a2.o = _si_hat;
    
        prs<g.Vdd,g.GND> {
            ~_ci_hat & ~_s.i & ~sso -> cso+
            _ci_hat -> cso-
    
            _s.i & cso -> _co-
            ~_s.i | ~cso -> _co+
    
            ~_si_hat & ~co -> sso+
            _si_hat | co -> sso-
    
            cso | sso => _s.o-

            _co => co-
        }
    }

    export 
    defproc H_ARB (globals g; port c1, c2, p) {
        // heirarchical arbiter cell
        // can be arranged in a binary tree to service more than 2 children
        CTRL ctrl(g,,,,,);
        C_ARB c1_arb(g,,,), c2_arb(g,,,);

        bool _c1i, _c2i, _s1a, s1b, _s2a;
        prs<g.Vdd,g.GND> {
            c1.i => _c1i-
            c2.i => _c2i-

            ctrl.s1.o => _s1a-
            c1_arb._s.o => s1b- 
            ctrl.s2.o => _s2a-
        }

        ctrl._c1i = _c1i;
        ctrl._c2i = _c2i;

        ctrl.s1.i = s1b;
        c1_arb._s.i = _s1a;
        ctrl.s2.i = c2_arb._s.o; // ctrl.s2.i will be active low
        c2_arb._s.i = _s2a;

        ctrl.p.o = p.o;
        ctrl.p.i = p.i;
        
        c1_arb._ci = _c1i;
        c2_arb._ci = _c2i;
        c1_arb.co = c1.o;
        c2_arb.co = c2.o;
    }

    export
    template <pint N>
    defproc ARB_TREE (globals g; port c[N]) {
        // arbiter tree servicing N children
        H_ARB h_arb[N-1];

        // connect globals to arbiters
        (; i : N-1 : h_arb[i].g=g;) 
        
        // connect arbiters in tree
        (; i : N-2 : 
            [ (i%2) = 0 -> 
                h_arb[i].p.o = h_arb[(N+i)/2].c1.i;
                h_arb[i].p.i = h_arb[(N+i)/2].c1.o;
            [] (i%2) = 1 ->
                h_arb[i].p.o = h_arb[(N+i)/2].c2.i;
                h_arb[i].p.i = h_arb[(N+i)/2].c2.o;
            ]
        )
        
        // connect top of arbiter tree back to itself
        prs<g.Vdd,g.GND> {
            h_arb[N-2].p.o => h_arb[N-2].p.i+
        }

        // connect children ports to arbiter tree leaves
        (; i : N : 
            [ (i%2) = 0 -> 
               c[i] = h_arb[i/2].c1;
            [] (i%2) = 1 ->
               c[i] = h_arb[i/2].c2;
            ]
        )
    }

    namespace test {
        export
        defproc TEST_CTRL_TEST (globals g) {
            // tests CTRL_TEST
            passive_handshaker s1(g,,), s2(g,,), p(g,,);
            CTRL_TEST ctrl(g,,,);
            
            ctrl.p.o = p.i;
            ctrl.p.i = p.o;
            ctrl.s1.i = s1.o;
            ctrl.s1.o = s1.i;
            ctrl.s2.i = s2.o;
            ctrl.s2.o = s2.i;
        }
        
        export
        defproc TEST_ARB (globals g) {
            // tests ARB
            active_handshaker c1(g,,), c2(g,,);
            ARB arb(g,,);
            
            c1.o = arb.a1.i;
            c1.i = arb.a1.o;
            c2.o = arb.a2.i;
            c2.i = arb.a2.o;
        }

        export
        defproc TEST_ARB_LOW (globals g) {
            // tests ARB with active low inputs
            active_low_handshaker c1(g,,), c2(g,,);
            ARB_LOW arb(g,,);
            
            c1._o = arb._a1.i;
            c1._i = arb._a1.o;
            c2._o = arb._a2.i;
            c2._i = arb._a2.o;
        }

        defproc C_ARB_handshaker (globals g; port _s; bool ci, _co) {
            // used in TEST_C_ARB
            prs<g.Vdd,g.GND> {
                g.pReset | ~_s.i -> _s.o+
                g._sReset & _s.i -> _s.o-

                g.pReset | ci -> _co+
                g._sReset & ~ci -> _co-
            }
        }

        export
        defproc TEST_C_ARB (globals g) {
            C_ARB_handshaker c(g,,,);
            C_ARB arb_c(g,,,);
            
            arb_c._s.i = c._s.o;
            arb_c._s.o = c._s.i;
            arb_c._ci = c._co;
            arb_c.co = c.ci;
        }

        export 
        defproc TEST_H_ARB (globals g) {
            // tests H_ARB
            active_handshaker c1(g,,), c2(g,,);
            H_ARB h_arb(g,,,);
            
            // connect top of H_ARB back to itself
            prs<g.Vdd,g.GND> {
                h_arb.p.o => h_arb.p.i+
            }

            h_arb.c1.i = c1.o;
            h_arb.c2.i = c2.o;
            h_arb.c1.o = c1.i;
            h_arb.c2.o = c2.i;
        }

        export
        template<pint N>
        defproc TEST_ARB_TREE (globals g) {
            // tests ARB_TREE
            ARB_TREE<N> arb_tree(g,);
            active_handshaker c[N];

            // connect globals to chidren
            (; i : N : c[i].g=g;) 

            // connect children to arbiter tree ports
            (; i : N : 
                c[i].o = arb_tree.c[i].i;
                c[i].i = arb_tree.c[i].o;
            )
        }

        export
        template<pint N>
        defproc TEST_ARB_TREE_HALF_EVEN (globals g) {
            // tests ARB_TREE with only even ports active
            ARB_TREE<N> arb_tree(g,);
            active_handshaker c[N/2];

            // connect globals to chidren
            (; i : N/2 : c[i].g=g;) 

            // connect children to arbiter tree ports
            (; i : N/2 : 
                c[i].o = arb_tree.c[2*i].i;
                c[i].i = arb_tree.c[2*i].o;
            )

            // connect dangling arbiter tree ports to GND
            (; i : N/2 : 
                arb_tree.c[2*i+1].i = g.GND;
            )
        }

        export
        template<pint N>
        defproc TEST_ARB_TREE_HALF_ODD (globals g) {
            // tests ARB_TREE with only odd ports active
            ARB_TREE<N> arb_tree(g,);
            active_handshaker c[N/2];

            // connect globals to chidren
            (; i : N/2 : c[i].g=g;) 

            // connect children to arbiter tree ports
            (; i : N/2 : 
                c[i].o = arb_tree.c[2*i+1].i;
                c[i].i = arb_tree.c[2*i+1].o;
            )

            // connect dangling arbiter tree ports to GND
            (; i : N/2 : 
                arb_tree.c[2*i].i = g.GND;
            )
        }

        export
        template<pint N>
        defproc TEST_ARB_TREE_HALF_MID (globals g) {
            // tests ARB_TREE with only middle ports active
            ARB_TREE<N> arb_tree(g,);
            active_handshaker c[N/2];

            // connect globals to chidren
            (; i : N/2 : c[i].g=g;) 

            // connect children to arbiter tree ports
            (; i : N/2 : 
                c[i].o = arb_tree.c[N/4+i].i;
                c[i].i = arb_tree.c[N/4+i].o;
            )

            // connect dangling arbiter tree ports to GND
            (; i : N/4 : 
                arb_tree.c[i].i = g.GND;
                arb_tree.c[3*N/4+i].i = g.GND;
            )
        }
    } // end namespace test
} // end namespace arbiter
