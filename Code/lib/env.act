import "lib/globals.act";
import "lib/channel.act";

/**

    WARNING: these are not CMOS-implementable
    rules. Don't use these as guidelines for
    anything! 

**/

namespace env {

/*

   Sources and sinks

 */
defproc source_cell (globals g; bool l, le, s, se, r, re)
{
        bool x, y;
        s = r;
        prs {
                ~g.pReset & ~x & ~y & l -> le-
                ~g.pReset &  ~y & ~le -> x+
                g.pReset | x & ~y & ~l -> le+
                ~g.pReset & x & le -> y+
                ~g.pReset & x & y & se & re -> s+
                g.pReset | y & s -> x-
                 g.pReset | ~x & y & ~se & ~re -> s-
                g.pReset | ~x & ~s -> y-
        }
}

defproc start_cell (globals g; bool l, le, r, re)
{
        bool x, y;
        prs {
                ~g.pReset & ~x & ~y & re -> r+
                ~g.pReset & ~y & r -> x+
                g.pReset | x & ~y & ~re -> r-
                ~g.pReset & x & ~r -> y+
                ~g.pReset & x & y & l -> le-
                g.pReset | y & ~le -> x-
                g.pReset | ~x & y & ~l -> le+
                g.pReset | ~x & le -> y-
        }
}

template <pint N, M; pint d[N]>
define source_e(globals g; e1of<M> rr)
{
        d1of<M> r;
        e1of<N> s;
        s.e = rr.e;
        bool l[N+1], le[N+1];
        source_cell sc[N];
        (;i:N:
                sc[i](g, l[i], le[i], s.d[i], s.e, l[i+1], le[i+1]);
        )
        start_cell startc(g, l[N], le[N], l[0], le[0]);
        prs {
                (:i:N: s.d[i] -> r.d[d[i]]+ )
                (:i:M: (&:j:N: ~s.d[j] ) -> r.d[i]- )
                (:i:M: r.d[i] -> rr.d[i]+)
                (:i:M: ~r.d[i] -> rr.d[i]-)
        }
}


/**
        Source a user-specified series of values.
*/
export template <pint N; pint d[N]>
defproc source_e1of2(globals g; e1of2 r) {
        e1of<2> s;
        s.d = r.d;
        s.e = r.e;
        source_e<N,2,d> src(g, s);
}

/**
        Random source.
*/
export defproc rsource_e1of2 (globals g; e1of2 r) 
{
  bool _r0, _r1;
  prs {
    r.e & ~g.pReset => _r0-
    r.e & ~g.pReset => _r1-
    _r0 => r.f-
    _r1 => r.t-
  }
  spec {
    mk_excllo(_r0, _r1)
  }
}

export defproc rsource_e1of3 (globals g; e1of<3> r) 
{
  bool _r[3];
  prs {
    (:i:3: r.e & ~g.pReset => _r[i]-)
    (:i:3: _r[i] => r.d[i]-)
  }

  spec {
    mk_excllo(_r[0], _r[1], _r[2])
  }
}

export template<pint M>
defproc rsource_eMx1of2(globals g; eMx1of2<M> r)
{
  rsource_e1of2 src[M];
  (;i:M: src[i].r.d = r.b[i].d;)
  (;i:M: src[i].r.e = r.e;)
  (;i:M: src[i].g = g;)
}

// XXX this doesn't seem to work (Alex wrote this)
/*
export template<pint N>
defproc rsource_e1of(globals g; e1of<N> r) 
{
  bool _r[N];
  prs {
    (:i:N: r.e & ~g.pReset => _r[i]-)
    (:i:N: _r[i] => r.d[i]-)
  }

  (;i:N-1:
    spec {
      mk_excllo(_r[i], _r[i+1])
    }
  )
}
*/

export defproc source_e1of1(globals g; e1of1 r)
{
  prs {
    g.sReset | r.e -> r.d+
    ~g.sReset & ~r.e -> r.d-
  }
}

export defproc passive_source_e1of1(globals g; e1of1 r)
{
  prs {
    ~g.sReset & r.e -> r.d+
    g.sReset | ~r.e -> r.d-
  }
}

export defproc sink_e1of1(globals g; e1of1 l)
{
  prs {
    g.sReset | ~l.d -> l.e+
    ~g.sReset & l.d -> l.e-
  }
}

export defproc bucket_e1of2(globals g; e1of2 l)
{
  prs {
    ~g.sReset & (l.f | l.t) -> l.e-
    g.sReset | ~l.f & ~l.t -> l.e+
  }
}

export template <pint N>
defproc bucket_e1of(globals g; e1of<N> l)
{
  prs {
    ~g.sReset & (|:i:N: l.d[i]) -> l.e-
    g.sReset | (&:i:N: ~l.d[i]) -> l.e+
  }
}

export template <pint M>
defproc bucket_eMx1of2(globals g; eMx1of2<M> l)
{
        bool valid;
        prs {
                (&:i:M: l.b[i].t | l.b[i].f) -> valid+
                (&:i:M: ~l.b[i].t & ~l.b[i].f) -> valid-
                ~g.sReset & valid -> l.e-
                g.sReset | ~valid -> l.e+
        }
}


}
