// This file defines a serialized tree tranceiver
import "lib/globals.act";
import "lib/channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";

namespace aer {
    namespace transmitter {
        export
        template <pint N>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; c1of<N> c[N], p) {
            // AEXT tree NODE controller
            /*--------------------------------------------------------------*/
            // /* // development
                bool c_[N], u;
                c1of<N> w;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c_[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c_[n]) -> po-
                
                    (: n : N :
                        c_[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c_[0] & u & pi & ~co[1] -> co[0]+
                    ~pi -> co[0]-
                    c_[1] & u & pi & ~co[0] -> co[1]+
                    ~pi -> co[1]-
                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c_[N], q[N], u;
                c1of<N> w;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    c_[0] & ~co[1] -> q[0]+
                    g.pReset | ~c_[0] & co[0] -> q[0]-
                    c_[1] & ~co[0] -> q[1]+
                    g.pReset | ~c_[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: nc : N :
                        q[nc] & u & pi -> co[nc]+
                        (~u | (| : n : N : p.d[n])) & ~pi -> co[nc]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            */
            /*--------------------------------------------------------------*/
        }

        template <pint N>
        defproc LEAF (globals g; bool ci[N], co[N], pi, po; c1of<N> p) {
            // leaf node of aext tree
            /*--------------------------------------------------------------*/
            // /* // development
                bool c[N], u;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c[n]) -> po-
                
                    (: n : N :
                        c[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c[0] & u & pi & ~co[1] -> co[0]+
                    ~pi -> co[0]-
                    c[1] & u & pi & ~co[0] -> co[1]+
                    ~pi -> co[1]-
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c[N], q[N], u;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    c[0] & ~co[1] -> q[0]+
                    g.pReset | ~c[0] & co[0] -> q[0]-
                    c[1] & ~co[0] -> q[1]+
                    g.pReset | ~c[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: n : N :
                        q[n] & u & pi -> co[n]+
                        ~u & ~pi -> co[n]-
                    )
                }
            */
        }

        template <pint N>
        defproc OUT (globals g; bool xi, xo; c1of<N> x; e1of<N> y) {
            // interface AEXT tree with e1ofN channel
            x.d = y.d;
            prs {
                xi & y.e => xo+
            }
        }

        export
        template <pint M, N, NN>
        defproc AEXT_ (globals g; bool xi[NN], xo[NN], ci[N], co[N], pi, po; c1of<N> p) {
            // utility for AEXT
            [ M = 1 ->
                NN = N;
                LEAF<N> leaf(g, ci, co, pi, po, p);
                ci = xi;
                co = xo;
            [] M > 1 ->
                pint k = NN/N;
                AEXT_<M-1, N, k> _[N];
                (; n : N :
                    _[n].g = g;
                    _[n].xi = xi[n*k..(n+1)*k-1];
                    _[n].xo = xo[n*k..(n+1)*k-1];
                )

                NODE<N> node(g,,, pi, po,, p);
                (; n : N :
                    node.ci[n] = _[n].po;
                    node.co[n] = _[n].pi;
                    node.c[n] = _[n].p;
                )
            ]
        }

        export
        template <pint M, N, NN>
        defproc AEXT (globals g; bool xi[NN], xo[NN]; e1of<N> y) {
            // Serial transmitter
            // M layers in the tree
            // N for 1-of-N encoding. + tail word line
            // NN = N^M neurons
            [ M = 0 ->
                0 = 1;
            [] M > 0 ->
                AEXT_<M, N, NN> _(g, xi, xo,,,,,);
                OUT<N> out(g, _.po, _.pi, _.p, y);
            ]
        }

        namespace test {
            export
            template <pint M, N, NN>
            defproc TEST_AEXT (globals g) {
                // M layers in the tree
                // N for 1-of-N encoding. + tail word line
                // NN = N^M neurons
                active_handshaker<NN> a(g,,);
                AEXT<M, N, NN> aext(g, a.o, a.i,);
                VN_e1ofN<N> vn(aext.y);
            }

            export
            template <pint M, N, NN, nn>
            defproc TEST_AEXT1 (globals g) {
                // M layers in the tree
                // N for 1-of-N encoding. + tail word line
                // NN = N^M neurons
                active_handshaker<1> a(g,,);
                AEXT<M, N, NN> aext(g,,,);
                VN_e1ofN<N> vn(aext.y);
                a.o[0] = aext.xi[nn];
                a.i[0] = aext.xo[nn];
                [ nn > 0 ->
                    (; idx : 0..nn-1 :
                        aext.xi[idx] = g.GND;
                    )
                ]
                [ nn < NN ->
                    (; idx : nn+1..NN-1 :
                        aext.xi[idx] = g.GND;
                    )
                ]
            }
        } // namespace test
    } // namespace transmitter

    namespace receiver {
        template <pint N>
        defproc SPLIT (globals g; e1of<N> p, c[N+1]; bool s[N+1]) {
            // splits data to children
            prs {
                (| : n : N+1 : c[n].e) => p.e+
                (: nc : N+1 :
                    (: n : N :
                        s[nc] & p.d[n] => c[nc].d[n]+
                    )
                )
            }
        }

        template <pint N>
        defproc CTRL (globals g; bool pi, po, ci[N], co[N], s[N+1]; e1of<N> x) {
            // controls split
            bool u[N];
            (; n : N : s[n] = co[n];)
            prs<g.Vdd, g.GND> {
                pi & (& : n : N : ~u[n]) => x.e+

                x.e | (| : n : N : x.d[n]) => s[N]+

                (: n : N :
                    x.d[n] -> u[n]+
                    ~pi -> u[n]-
                )

                (: n : N :
                    u[n] & ~s[N] => s[n]+
                )

                (| : n : N : ci[n]) => po+
            }
        }

        template <pint N>
        defproc LEAF (globals g; bool pi, po, ci[N], co[N]; e1of<N> x) {
            // leaf of AERV tree
            // similar to CTRL, but no need for SPLIT at leaf if no payload to deliver
            bool u[N];
            prs<g.Vdd, g.GND> {
                pi & (& : n : N : ~u[n]) => x.e+

                (: n : N :
                    x.d[n] -> u[n]+
                    ~pi -> u[n]-
                )

                (: n : N :
                    u[n] & ~x.d[n] => co[n]+
                )

                (| : n : N : ci[n]) => po+
            }
        }

        template <pint N>
        defproc NODE (globals g; bool pi, po, ci[N], co[N]; e1of<N> p, c[N]) {
            // node in AERV tree
            SPLIT<N> split(g, p,,);
            CTRL<N> ctrl(g, pi, po, ci, co, split.s, split.c[N]);
            (; n : N : split.c[n] = c[n];)
        }

        template <pint M, N, NN>
        defproc AERV_ (globals g; bool yi[NN], yo[NN], pi, po; e1of<N> p) {
            // utility for AERV
            [ M = 1 ->
                NN = N;
                // NODE<N> node(g, pi, po, yi, yo, p,); // future
                // (; n : N : node.c[n].e = g.GND;) // future
                LEAF<N> leaf(g, pi, po, yi, yo, p);
            [] M > 1 ->
                AERV_<M-1, N, NN/N> _[N];
                NODE<N> node(g, pi, po,,, p,);
                pint k = NN/N;
                (; n : N :
                    _[n].g = g;
                    _[n].p = node.c[n];
                    _[n].pi = node.co[n];
                    _[n].po = node.ci[n];
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].yo = yo[n*k..(n+1)*k-1];
                )
            ]
        }

        export
        template <pint M, N, NN>
        defproc AERV (globals g; e1of<N> x; bool yi[NN], yo[NN]) {
            // Serial receiver
            // M layers in the tree
            // N for 1-of-N encoding
            // NN = N^M neurons
            [ M = 0 ->
                0 = 1;
            [] M > 0 ->
                AERV_<M, N, NN> _(g, yi, yo,,, x);
                prs {
                    ~g.sReset & ~_.po -> _.pi+
                    g.pReset | _.po -> _.pi-
                }
            ]
        }

        namespace test {
        } // namespace test
    } // namespace receiver

    export
    template <pint M, N, NN>
    defproc AER (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        transmitter::AEXT<M, N, NN> aext(g, xi, xo,);
        receiver::AERV<M, N, NN> aerv(g, aext.y, yi, yo);
    }

    namespace test {
        export
        template <pint M, N, NN>
        defproc TEST_AER (globals g) {
            // M groups
            // N items per group
            // NN neurons. NN=N^M
            active_handshaker<NN> x(g,,);
            passive_handshaker<NN> y(,);
            AER<M, N, NN> aer(g, x.o, x.i, y.o, y.i);
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER1 (globals g) {
            // Tests AER with 1 neuron
            // M groups
            // N items per group
            // NN neuron ports. NN=N^M
            active_handshaker<1> x(g,,);
            active_handshaker<1> y(g,,);
            AER<M, N, NN> aer(g,,,,);
            aer.xi[0] = x.o[0];
            aer.xo[0] = x.i[0];
            aer.yi[0] = y.o[0];
            aer.yo[0] = y.i[0];
            (; nn : 1..NN-1 :
                aer.xi[nn] = g.GND;
                aer.yi[nn] = g.GND;
            )
        }
    } // namespace test
} // namespace aer
