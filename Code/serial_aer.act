// This file defines a serialized tree tranceiver
import "lib/globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";

namespace aer {
    namespace transmitter {
        export
        template <pint N>
        defproc INT (globals g; bool xi, xo; a1of<N+1> y) {
            // interface with the neuron
            // N for 1-of-N encoding. + tail word line
            xi = y.m.n[N];
            xo = y.a;
            (; n : N : g.GND = y.m.n[n];)
        }

        export
        template <pint N, n>
        defproc FWD (globals g; a1of<N+1> x, y) {
            // prepends head word and fowards packet
            // N for 1-of-N encoding. + tail word line
            // n word prepended to each packet
            bool yi = y.a;
            bool xo = x.a;
            bool yt = y.m.n[N];
            bool xt = x.m.n[N];

            /*--------------------------- version 1 -------------------------*/
            // bool h, q;
            // prs<g.Vdd, g.GND> {
            //     h & yi & y.m.n[n] -> q+
            //     g.pReset | ~h -> q-

            //     g.pReset | yt & xo & yi -> h+
            //     q & ~yi -> h-
            //     
            //     ~h & (y.m.n[0] | y.m.n[1] | yt) -> xo+
            //     ~x.m.n[0] & ~x.m.n[1] & ~xt & ~y.m.n[0] & ~y.m.n[1] & ~yt -> xo-

            //     h & ~q & ~yi & ~xo & (x.m.n[0] | x.m.n[1] | xt) -> y.m.n[n]+
            //     q -> y.m.n[n]-

            //     ~h & x.m.n[0] & ~q & ~yi & ~xo -> y.m.n[0]+
            //     g.pReset | yi & xo -> y.m.n[0]-

            //     ~h & x.m.n[1] & ~q & ~yi & ~xo -> y.m.n[1]+
            //     g.pReset | yi & xo -> y.m.n[1]-

            //     ~h & xt & ~q & ~yi & ~xo -> yt+
            //     g.pReset | h & xo -> yt-
            // }

            /*--------------------------- version 2 -------------------------*/
            bool h;
            bool u[2], ut;
            prs<g.Vdd, g.GND> {
                g.pReset | yt -> h+
                y.m.n[n] & yi -> h-
                
                h & (x.m.n[0] | x.m.n[1] | xt) & ~yi & ~yt -> y.m.n[n]+
                ~h & yi & ~u[n] -> y.m.n[n]-

                (u[0] | u[1] | ut) => xo+

                ~h & x.m.n[0] & ~yi -> u[0]+
                g.pReset | ~x.m.n[0] & yi -> u[0]-

                ~h & x.m.n[1] & ~yi -> u[1]+
                g.pReset | ~x.m.n[1] & yi -> u[1]-

                ~h & xt & ~yi -> ut+
                g.pReset | h & ~xt & yi -> ut-

                u[0] -> y.m.n[0]+
                g.pReset | ~h & ~u[0] -> y.m.n[0]-

                u[1] -> y.m.n[1]+
                g.pReset | ~h & ~u[1] -> y.m.n[1]-

                ut -> yt+
                ~ut  -> yt-
            }
        }

        template <pint N, n>
        defproc FWD_ARR (globals g; a1of<N+1> x[N], y[N]) {
            // utility for building an array of FWD processes
            [ n < N ->
                FWD<N, n> fwd(g, x[n], y[n]);
                FWD_ARR<N, n+1> _(g, x, y);
            ]
        }

        export
        template <pint N>
        defproc MERGE (globals g; a1of<N+1> c[N], p) {
            // merges serialized packet streams
            // N for 1-of-N encoding. + tail word line
            bool a[N], ct[N], co[N];
            bool pt = p.m.n[N];
            bool pi = p.a;
            (; n : N :
                ct[n] = c[n].m.n[N];
                co[n] = c[n].a;
            )
            ::arbiter::N_ARB<N> arb(g,,);
            /*--------------------------- version 0 -------------------------*/
            // /*
                bool _a[N];
                prs<g.Vdd, g.GND> {
                    // arbitration
                    (: n : N :
                        ~a[n] & ((| : nc : N : c[n].m.n[nc]) | ct[n]) -> arb.i[n]+
                        g.pReset | a[n] -> arb.i[n]-
                    )

                    arb.o[0] & (& : n : 1..N-1 : ~a[n] & ~co[n]) & ~pi -> a[0]+
                    (: n : 1..N-2 :
                        arb.o[n] & 
                        (& : na : 0..n-1 : ~a[na] & ~co[na]) &
                        (& : nb : n+1..N-1 : ~a[nb] & ~co[nb]) &
                        ~pi -> a[n]+
                    )
                    arb.o[N-1] & (& : n : N-1 : ~a[n] & ~co[n]) & ~pi -> a[N-1]+

                    (: n : N :
                        g.pReset | ~arb.o[n] & pi & pt & ~ct[n] -> a[n]-

                        a[n] => _a[n]-
                    )

                    // routing state
                    (: n : N :
                        ~pi & (| : nc : N : a[nc] & c[nc].m.n[n]) -> p.m.n[n]+
                        g.pReset | pi & (| : nc : N : ~_a[nc] & ~c[nc].m.n[n]) -> p.m.n[n]-
                    )
                    // tail bit state
                    ~pi & (| : n : N : a[n] & ct[n]) -> pt+
                    g.pReset | (& : n : N : _a[n]) -> pt-

                    // child comm
                    (: n : N :
                        a[n] & ((| : nc : N : p.m.n[nc]) | pt) -> co[n]+
                        (& : nc : N : ~p.m.n[nc]) & ~pt -> co[n]-
                    )
                }
            // */
            /*--------------------------- version 1 -------------------------*/
            /*
                bool h;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ((| : nc : N : c[n].m.n[nc]) | ct[n]) & ~a[n] -> arb.i[n]+
                        g.pReset | ~h & a[n] -> arb.i[n]-
                    )

                    ( : n : N :
                        h & arb.o[n] & ~pi -> a[n]+
                        g.pReset | pt & pi & co[n] & ~ct[n] & ~arb.o[n] -> a[n]-
                    )

                    // head word state
                    (& : n : N : ~a[n]) -> h+
                    (| : n : N : a[n]) & (& : n : N : ~co[n]) -> h-

                    // parent comm
                    (: n : N :
                        ~pi & (| : nc : N : a[nc] & c[nc].m.n[n]) & ~h -> p.m.n[n]+
                        g.pReset | pi & (| : nc : N : a[nc] & ~c[nc].m.n[n]) -> p.m.n[n]-
                    )
                    ~pi & (| : n : N : a[n] & ct[n]) -> pt+
                    (& : n : N : ~a[n])  -> pt-

                    // child comm
                    (: n : N :
                        a[n] & ((| : nc : N : p.m.n[nc]) | pt) -> co[n]+
                        (& : nc : N : ~p.m.n[nc]) & ~pt -> co[n]-
                    )
                }
            */
        }

        export
        template <pint N, M, NN>
        defproc AEXT (globals g; bool xi[NN], xo[NN]; a1of<N+1> y) {
            // Serial transmitter
            // N for 1-of-N encoding. + tail word line
            // M layers in the tree
            // NN = N^M neurons
            [ M = 0 ->
                NN = 1; // check that NN = N^M
                INT<N> n_int(g, xi[0], xo[0], y);
            [] M > 0 ->
                bool yt = y.m.n[N];
                pint k = NN/N;
                AEXT<N, M-1, k> aext[N];
                MERGE<N> merge(g,,y);
                FWD_ARR<N, 0> fwd_arr(g,, merge.c);
                (; n : N :
                    aext[n].g = g;
                    aext[n].y = fwd_arr.x[n];
                )
                (; n : N-1 :
                    aext[n].xi = xi[n*k..(n+1)*k-1];
                    aext[n].xo = xo[n*k..(n+1)*k-1];
                )
                aext[N-1].xi = xi[(N-1)*k..NN-1];
                aext[N-1].xo = xo[(N-1)*k..NN-1];
            ]
        }

        namespace test {
            export
            template <pint N, M; pint nm[M]>
            defproc FWD_CHAIN_ (globals g; a1of<N+1> y) {
                // utility for TEST_FWD
                // N for 1-of-N encoding
                // M nodes in chain
                // nm words to prepend at each node
                [ M = 1 ->
                    active_handshaker<1> a(g,,);
                    INT<N> a_int(g, a.o[0], a.i[0],);
                    FWD<N, nm[0]> fwd(g, a_int.y, y);
                [] M > 1 ->
                    FWD_CHAIN_<N, M-1, nm[1..M-1]> _(g,);
                    FWD<N, nm[0]> fwd(g, _.y, y);
                ]
            }

            export
            template <pint N, M; pint nm[M]>
            defproc TEST_FWD (globals g) {
                // tests a chain of FWD blocks
                // N for 1-of-N encoding
                // M number of FWD processes to chain
                // n array of words to prepend.
                FWD_CHAIN_<N, M, nm> _(g,);
                VN<1, N+1> vn(, _.y.a);
                vn.d[0] = _.y.m;
            }

            export
            template <pint N>
            defproc TEST_MERGE (globals g) {
                pint M=2; // depth of foward chains
                pint n[N][M];
                pint nm0[M], nm1[M];
                (; m : M : 
                    nm0[m] = 0;
                    nm1[m] = 1;
                )

                FWD_CHAIN_<N, M, nm0> c0(g,);
                FWD_CHAIN_<N, M, nm1> c1(g,);
                MERGE<N> merge(g,,);
                VN<1, N+1> vn(, merge.p.a);
                vn.d[0] = merge.p.m;
                merge.c[0] = c0.y;
                merge.c[1] = c1.y;
            }

            export
            template <pint N, M, NN>
            defproc TEST_AEXT (globals g) {
                active_handshaker<NN> a(g,,);
                AEXT<N, M, NN> aext(g, a.o, a.i,);
                VN<1, N+1> vn(, aext.y.a);
                vn.d[0] = aext.y.m;
            }
        } // namespace test
    } // namespace transmitter

    namespace receiver {
        export
        template <pint N> 
        defproc BCAST (globals g; a1of<N+1> p, c[N]) {
            // broadcasts incoming words from parent to children
            // N for 1-of-N encoding
            bool po = p.a;
            bool pt = p.m.n[N];
            bool ci[N], ct[N];
            (; n : N : 
                ci[n] = c[n].a;
                ct[n] = c[n].m.n[N];
            )

            /* version cppc pipelined parallelized --------------------------*/
            /* version unpipelined ------------------------------------------*/
            // /*
                prs {
                    (: n : N+1 :
                        (: nc : N :
                            p.m.n[n] => c[nc].m.n[n]+
                        )
                    )
                    (& : n : N : ci[n]) -> po+
                    (& : n : N : ~ci[n]) -> po-
                }
            // */

        }

        template <pint N, n>
        defproc FILTER (globals g; a1of<N+1> x, y) {
            // N for 1-of-N encoding
            // n if first packet word is n, pass rest of packet. else filter.
        }

        template <pint N>
        defproc FILTER_ARR (globals g; a1of<N+1> x[N], y[N]) {
            // N for 1-of-N encoding
        }

        export
        template <pint N, M, NN>
        defproc AERV (globals g; a1of<N+1> x; bool yi[NN], yo[NN]) {
            // Serial receiver
            // N for 1-of-N encoding
        }

        namespace test {
            export
            template <pint N>
            defproc TEST_BCAST (globals g) {
                pint M=3;
                pint nm[M];
                (; m : M : nm[m] = 0;)
                ::aer::transmitter::test::FWD_CHAIN_<N, M, nm> fwd(g,);
                BCAST<N> bcast(g, fwd.y,);
                VN<1, N+1> vn[N];
                (; n : N :
                    bcast.c[n].m = vn[n].d[0];
                    bcast.c[n].a = vn[n].o;
                )
            }

        } // namespace test
    } // namespace receiver

    export
    template <pint N, M, NN>
    defproc AER (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
    }

    namespace test {
        export
        template <pint N, M, NN>
        defproc TEST_AER (globals g) {
            // M groups
            // N items per group
            // NN neurons. NN=N^M
            active_handshaker<NN> x(g,,);
            passive_handshaker<NN> y(,);
            AER<M, N, NN> aer(g, x.o, x.i, y.o, y.i);
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER1 (globals g) {
            // Tests AER with 1 neuron
            // M groups
            // N items per group
            // NN neuron ports. NN=N^M
            active_handshaker<1> x(g,,);
            passive_handshaker<1> y(,);
            AER<M, N, NN> aer(g,,,,);
            aer.xi[0] = x.o[0];
            aer.xo[0] = x.i[0];
            aer.yi[0] = y.o[0];
            aer.yo[0] = y.i[0];
            (; nn : 1..NN-1 :
                aer.xi[nn] = g.GND;
                aer.yi[nn] = g.GND;
            )
        }
    } // namespace test
} // namespace aer
