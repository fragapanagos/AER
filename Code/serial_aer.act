// This file defines a serialized tree tranceiver
import "lib/globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";

namespace aer {
    namespace transmitter {
        export
        template <pint N>
        defproc INT (globals g; bool xi, xo; a1of<N+1> y) {
            // interface with the neuron
            // N for 1-of-N encoding. + tail word line
            xi = y.m.n[N];
            xo = y.a;
            (; n : N : g.GND = y.m.n[n];)
        }

        export
        template <pint N, n>
        defproc PFWD (globals g; a1of<N+1> x, y) {
            // prepends head word and fowards packet
            // N for 1-of-N encoding. + tail word line
            // n word prepended to each packet
            bool yi = y.a;
            bool xo = x.a;
            bool yt = y.m.n[N];
            bool xt = x.m.n[N];

            /* version hq ---------------------------------------------------*/
            // bool h, q;
            // prs<g.Vdd, g.GND> {
            //     h & yi & y.m.n[n] -> q+
            //     g.pReset | ~h -> q-

            //     g.pReset | yt & xo & yi -> h+
            //     q & ~yi -> h-
            //     
            //     ~h & (y.m.n[0] | y.m.n[1] | yt) -> xo+
            //     ~x.m.n[0] & ~x.m.n[1] & ~xt & ~y.m.n[0] & ~y.m.n[1] & ~yt -> xo-

            //     h & ~q & ~yi & ~xo & (x.m.n[0] | x.m.n[1] | xt) -> y.m.n[n]+
            //     q -> y.m.n[n]-

            //     ~h & x.m.n[0] & ~q & ~yi & ~xo -> y.m.n[0]+
            //     g.pReset | yi & xo -> y.m.n[0]-

            //     ~h & x.m.n[1] & ~q & ~yi & ~xo -> y.m.n[1]+
            //     g.pReset | yi & xo -> y.m.n[1]-

            //     ~h & xt & ~q & ~yi & ~xo -> yt+
            //     g.pReset | h & xo -> yt-
            // }

            /* version hu ---------------------------------------------------*/
            bool h;
            bool u[2], ut;
            prs<g.Vdd, g.GND> {
                g.pReset | yt -> h+
                y.m.n[n] & yi -> h-
                
                h & (x.m.n[0] | x.m.n[1] | xt) & ~yi & ~yt -> y.m.n[n]+
                ~h & yi & ~u[n] -> y.m.n[n]-

                (u[0] | u[1] | ut) => xo+

                ~h & x.m.n[0] & ~yi -> u[0]+
                g.pReset | ~x.m.n[0] & yi -> u[0]-

                ~h & x.m.n[1] & ~yi -> u[1]+
                g.pReset | ~x.m.n[1] & yi -> u[1]-

                ~h & xt & ~yi -> ut+
                g.pReset | h & ~xt & yi -> ut-

                u[0] -> y.m.n[0]+
                g.pReset | ~h & ~u[0] -> y.m.n[0]-

                u[1] -> y.m.n[1]+
                g.pReset | ~h & ~u[1] -> y.m.n[1]-

                ut -> yt+
                ~ut  -> yt-
            }
        }

        template <pint N, n>
        defproc PFWD_ARR (globals g; a1of<N+1> x[N], y[N]) {
            // utility to build array of PFWD
            // N for 1-of-N encoding
            // n which word to prepend. Initialize with 0
            [ n < N ->
                PFWD<N, n> pfwd(g, x[n], y[n]);
                PFWD_ARR<N, n+1> _(g, x, y);
            ]
        }

        export
        template <pint N>
        defproc MERGE (globals g; a1of<N+1> c[N], p) {
            // merges serialized packet streams
            // N for 1-of-N encoding. + tail word line
            bool a[N], ct[N], co[N];
            bool pt = p.m.n[N];
            bool pi = p.a;
            (; n : N :
                ct[n] = c[n].m.n[N];
                co[n] = c[n].a;
            )
            ::arbiter::N_ARB<N> arb(g,,);
            /* version a_a --------------------------------------------------*/
            // /*
                bool _a[N];
                prs<g.Vdd, g.GND> {
                    // arbitration
                    (: n : N :
                        ~a[n] & ((| : nc : N : c[n].m.n[nc]) | ct[n]) -> arb.i[n]+
                        g.pReset | a[n] -> arb.i[n]-
                    )

                    arb.o[0] & (& : n : 1..N-1 : ~a[n] & ~co[n]) & ~pi -> a[0]+
                    (: n : 1..N-2 :
                        arb.o[n] & 
                        (& : na : 0..n-1 : ~a[na] & ~co[na]) &
                        (& : nb : n+1..N-1 : ~a[nb] & ~co[nb]) &
                        ~pi -> a[n]+
                    )
                    arb.o[N-1] & (& : n : N-1 : ~a[n] & ~co[n]) & ~pi -> a[N-1]+

                    (: n : N :
                        g.pReset | ~arb.o[n] & pi & pt & ~ct[n] -> a[n]-

                        a[n] => _a[n]-
                    )

                    // routing state
                    (: n : N :
                        ~pi & (| : nc : N : a[nc] & c[nc].m.n[n]) -> p.m.n[n]+
                        g.pReset | pi & (| : nc : N : ~_a[nc] & ~c[nc].m.n[n]) -> p.m.n[n]-
                    )
                    // tail bit state
                    ~pi & (| : n : N : a[n] & ct[n]) -> pt+
                    g.pReset | (& : n : N : _a[n]) -> pt-

                    // child comm
                    (: n : N :
                        a[n] & ((| : nc : N : p.m.n[nc]) | pt) -> co[n]+
                        (& : nc : N : ~p.m.n[nc]) & ~pt -> co[n]-
                    )
                }
            // */
            /* version ah ---------------------------------------------------*/
            /*
                bool h;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ((| : nc : N : c[n].m.n[nc]) | ct[n]) & ~a[n] -> arb.i[n]+
                        g.pReset | ~h & a[n] -> arb.i[n]-
                    )

                    ( : n : N :
                        h & arb.o[n] & ~pi -> a[n]+
                        g.pReset | pt & pi & co[n] & ~ct[n] & ~arb.o[n] -> a[n]-
                    )

                    // head word state
                    (& : n : N : ~a[n]) -> h+
                    (| : n : N : a[n]) & (& : n : N : ~co[n]) -> h-

                    // parent comm
                    (: n : N :
                        ~pi & (| : nc : N : a[nc] & c[nc].m.n[n]) & ~h -> p.m.n[n]+
                        g.pReset | pi & (| : nc : N : a[nc] & ~c[nc].m.n[n]) -> p.m.n[n]-
                    )
                    ~pi & (| : n : N : a[n] & ct[n]) -> pt+
                    (& : n : N : ~a[n])  -> pt-

                    // child comm
                    (: n : N :
                        a[n] & ((| : nc : N : p.m.n[nc]) | pt) -> co[n]+
                        (& : nc : N : ~p.m.n[nc]) & ~pt -> co[n]-
                    )
                }
            */
        }

        export
        template <pint N, M, NN>
        defproc AEXT (globals g; bool xi[NN], xo[NN]; a1of<N+1> y) {
            // Serial transmitter
            // N for 1-of-N encoding. + tail word line
            // M layers in the tree
            // NN = N^M neurons
            bool yi = y.a;
            [ M = 0 ->
                NN = 1; // check that NN = N^M
                INT<N> n_int(g, xi[0], xo[0], y);
            [] M > 0 ->
                bool yt = y.m.n[N];
                pint k = NN/N;
                AEXT<N, M-1, k> aext[N];
                MERGE<N> merge(g,,y);
                PFWD_ARR<N, 0> pfwd_arr(g,, merge.c);
                (; n : N :
                    aext[n].g = g;
                    aext[n].y = pfwd_arr.x[n];
                )
                (; n : N-1 :
                    aext[n].xi = xi[n*k..(n+1)*k-1];
                    aext[n].xo = xo[n*k..(n+1)*k-1];
                )
                aext[N-1].xi = xi[(N-1)*k..NN-1];
                aext[N-1].xo = xo[(N-1)*k..NN-1];
            ]
        }

        namespace test {
            export
            template <pint N, M; pint nm[M]>
            defproc PFWD_CHAIN_ (globals g; a1of<N+1> y) {
                // utility for TEST_FWD
                // N for 1-of-N encoding
                // M nodes in chain
                // nm words to prepend at each node
                [ M = 1 ->
                    active_handshaker<1> a(g,,);
                    INT<N> a_int(g, a.o[0], a.i[0],);
                    PFWD<N, nm[0]> pfwd(g, a_int.y, y);
                [] M > 1 ->
                    PFWD_CHAIN_<N, M-1, nm[1..M-1]> _(g,);
                    PFWD<N, nm[0]> pfwd(g, _.y, y);
                ]
            }

            export
            template <pint N, M; pint nm[M]>
            defproc TEST_FWD (globals g) {
                // tests a chain of PFWD blocks
                // N for 1-of-N encoding
                // M number of PFWD processes to chain
                // n array of words to prepend.
                PFWD_CHAIN_<N, M, nm> _(g,);
                VN<1, N+1> vn(, _.y.a);
                vn.d[0] = _.y.m;
            }

            export
            template <pint N>
            defproc TEST_MERGE (globals g) {
                pint M=2; // depth of foward chains
                pint n[N][M];
                pint nm0[M], nm1[M];
                (; m : M : 
                    nm0[m] = 0;
                    nm1[m] = 1;
                )

                PFWD_CHAIN_<N, M, nm0> c0(g,);
                PFWD_CHAIN_<N, M, nm1> c1(g,);
                MERGE<N> merge(g,,);
                VN<1, N+1> vn(, merge.p.a);
                vn.d[0] = merge.p.m;
                merge.c[0] = c0.y;
                merge.c[1] = c1.y;
            }

            export
            template <pint N, M, NN>
            defproc TEST_AEXT (globals g) {
                active_handshaker<NN> a(g,,);
                AEXT<N, M, NN> aext(g, a.o, a.i,);
                VN<1, N+1> vn(, aext.y.a);
                vn.d[0] = aext.y.m;
            }
        } // namespace test
    } // namespace transmitter

    namespace receiver {
        export
        template <pint N>
        defproc INT (a1of<N+1> x; bool yi, yo) {
            // interface with the neuron
            // N for 1-of-N encoding. + tail word line
            x.m.n[N] = yo;
            x.a = yi;
        }

        export
        template <pint N> 
        defproc BCAST (globals g; a1of<N+1> p, c[N]) {
            // broadcasts incoming words from parent to children
            // N for 1-of-N encoding
            bool po = p.a;
            bool pt = p.m.n[N];
            bool ci[N], ct[N];
            (; n : N : 
                ci[n] = c[n].a;
                ct[n] = c[n].m.n[N];
            )

            /* version cpcp pipelined strict --------------------------------*/
            /*
             VN <N, N+1> vn(,);
             (; n : N : c[n].m = vn.d[n];)
             po = vn.o;
             bool q[N+1];
             prs<g.Vdd, g.GND> {
                 (: n : N+1 :
                     (& : nc : N : ~ci[nc]) & p.m.n[n] -> q[n]+
                     g.pReset | (& : nc : N : ci[nc]) & ~p.m.n[n] -> q[n]-
                     (: nc : N : q[n] => c[nc].m.n[n]+)
                 )
             }
            */
            /* version cpcp pipelined parallelized --------------------------*/
            // /*
             VN <N, N+1> vn(,);
             (; n : N : c[n].m = vn.d[n];)
             po = vn.o;
             prs<g.Vdd, g.GND> {
                 (: nc : N :
                     (: n : N+1 :
                         ~ci[nc] & p.m.n[n] -> c[nc].m.n[n]+
                         g.pReset | ci[nc] & ~p.m.n[n] -> c[nc].m.n[n]-
                     )
                 )
             }
            // */
            /* version unpipelined ------------------------------------------*/
            /*
                prs {
                    (: n : N+1 :
                        (: nc : N :
                            p.m.n[n] => c[nc].m.n[n]+
                        )
                    )
                    (& : n : N : ci[n]) -> po+
                    (& : n : N : ~ci[n]) -> po-
                }
            */
        }

        template <pint N, n>
        defproc FILTER (globals g; a1of<N+1> x, y) {
            // N for 1-of-N encoding
            // n : if first word is n, pass packet, else filter
            bool xt = x.m.n[N];
            bool yt = y.m.n[N];
            bool xo = x.a;
            bool yi = y.a;

            bool st, sf;
            /* version pipelined --------------------------------------------*/
            /*
                bool ht, hf, tf;
                prs<g.Vdd, g.GND> {
                    ~yi & ht & ~x.m.n[n] -> st+
                    yt & yi & ~xt & ~xo -> st-

                    ~yi & hf & ~x.m.n[] -> sf+ // any other element of x except for tail
                    tf & ~xt -> sf-
                }

                prs<g.Vdd, g.GND> {
                    ~st & ~sf & ~tf & x.m.n[n] & ~yi -> ht+
                    st & ~xo -> ht-

                    ~st & ~sf & ~tf & x.m.n[] & ~yi -> hf+
                    sf & ~xo -> hf-

                    sf & xt -> tf+
                    sf & ~xo -> tf-
                }
                
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~yi & ~ht & ~st & x.m.n[n] -> y.m.n[n]+
                        yi & ~x.m.n[n] & ~xo -> y.m.n[n]-
                    )
                    ~yi & ~ht & st & xt -> yt+
                    ~st -> yt-
                }

                prs<g.Vdd, g.GND> {
                    sf & ((| : n : N : x.m.n[n]) | tf & xt) | 
                    st & (| : n : N+1 : y.m.n[n]) -> xo+
                    (& : n : N+1 : ~x.m.n[n]) -> xo-
                }
            */
            /* version unpipelined ------------------------------------------*/
            // /*
                bool q, t;
                prs {
                    st | sf => q-

                    sf & xt -> t+
                    ~sf -> t-

                }
                prs<g.Vdd, g.GND> {
                    q & x.m.n[n] & ~t -> st+
                    g.pReset | yt & ~xt -> st-
                }

                [ n = 0 ->
                    prs {
                        q & (| : nn : 1..N-1 : x.m.n[nn]) & ~t -> sf+
                    }
                [] n = (N-1) ->
                    prs {
                        q & (| : nn : 0..N-2 : x.m.n[nn]) & ~t -> sf+
                    }
                [] n > 0 & n < (N-1) ->
                    prs {
                        q & ((| : nn : 0..n-1 : x.m.n[nn])
                            |(| : nn : n+1..N-1 : x.m.n[nn])) & ~t -> sf+
                    }
                ]
                prs<g.Vdd, g.GND> {
                    g.pReset | t & ~xt & ~xo -> sf-
                }
                prs<g.Vdd, g.GND> {
                    sf & ((| : nn : N : x.m.n[nn]) | xt & t) | yi -> xo+
                    (& : nn : N+1 : ~x.m.n[nn]) & ~yi -> xo-
                }
                prs<g.Vdd, g.GND> {
                    (: nn : N :
                        st & x.m.n[nn] -> y.m.n[nn]+
                        ~x.m.n[nn] -> y.m.n[nn]-
                    )
                    st & xt -> yt+
                    ~st -> yt-
                }
            // */
        }

        template <pint N, n>
        defproc FILTER_ARR (globals g; a1of<N+1> x[N], y[N]) {
            // utility to build array of FILTER
            // N for 1-of-N encoding
            // n which first word to check for. Initialize with 0
            [ n < N ->
                FILTER<N, n> filter(g, x[n], y[n]);
                FILTER_ARR<N, n+1> _(g, x, y);
            ]
        }

        export
        template <pint N, w>
        defproc DECIDE (globals g; a1of<N+1> x; bool st, sf) {
            // N for 1-of-N encoding
            // w : if first word is w, raise st. else raise sf.
            bool xt = x.m.n[N];
            bool xo = x.a;

            bool u, v;
            prs {
                (st | sf) & ~u -> v+
                ~st & ~sf | u -> v-

                ~st & ~sf & ~v -> u+
                st | sf | v -> u-

                v & (st | sf) & (| : n : N : x.m.n[n]) | u & xt -> xo+
                (& : n : N+1 : ~x.m.n[n]) -> xo-
            }

            [ w = 0 ->
                prs {
                    u & (| : nn : 1..N-1 : x.m.n[nn]) -> sf+
                }
            [] w = (N-1) ->
                prs {
                    u & (| : nn : 0..N-2 : x.m.n[nn]) -> sf+
                }
            [] w > 0 & w < (N-1) ->
                prs {
                    u & ((| : n : 0..w-1 : x.m.n[n])
                        |(| : n : w+1..N-1 : x.m.n[n])) -> sf+
                }
            ]
            prs <g.Vdd, g.GND> {
                u & x.m.n[w] -> st+
                g.pReset | v & xt -> st-
                g.pReset | v & xt -> sf-
            }
        }

        export
        template <pint N, M, NN>
        defproc AERV (globals g; a1of<N+1> x; bool yi[NN], yo[NN]) {
            // Serial receiver
            // N for 1-of-N encoding
            // M layers in the tree
            // NN = N^M neurons
            [ M = 0 ->
                NN = 1; // check that NN = N^M
                INT<N> n_int(x, yi[0], yo[0]);
            [] M > 0 ->
                bool xt = x.m.n[N];
                pint k = NN/N;
                AERV<N, M-1, k> aerv[N];
                BCAST<N> bcast(g, x,);
                FILTER_ARR<N, 0> filter_arr(g, bcast.c,);
                (; n : N :
                    aerv[n].g = g;
                    aerv[n].x = filter_arr.y[n];
                )
                (; n : N-1 :
                    aerv[n].yi = yi[n*k..(n+1)*k-1];
                    aerv[n].yo = yo[n*k..(n+1)*k-1];
                )
                aerv[N-1].yi = yi[(N-1)*k..NN-1];
                aerv[N-1].yo = yo[(N-1)*k..NN-1];
            ]
        }

        namespace test {
            export
            template <pint N>
            defproc TEST_BCAST (globals g) {
                pint M=3;
                pint nm[M];
                (; m : M : nm[m] = 0;)
                ::aer::transmitter::test::PFWD_CHAIN_<N, M, nm> pfwd(g,);
                BCAST<N> bcast(g, pfwd.y,);
                VN<1, N+1> vn[N];
                (; n : N :
                    bcast.c[n].m = vn[n].d[0];
                    bcast.c[n].a = vn[n].o;
                )
            }

            export
            template <pint N, M, NN, w>
            defproc TEST_DECIDE (globals g) {
                active_handshaker<NN> x(g,,);
                ::aer::transmitter::AEXT<N, M, NN> aext(g, x.o, x.i,);
                DECIDE<N, w> decide(g, aext.y,,);
            }
        } // namespace test
    } // namespace receiver

    export
    template <pint N, M, NN>
    defproc AER (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        transmitter::AEXT<N, M, NN> aext(g, xi, xo,);
        receiver::AERV<N, M, NN> aerv(g,, yi, yo);
        aext.y = aerv.x;
    }

    namespace test {
        export
        template <pint N, M, NN>
        defproc TEST_AER (globals g) {
            // M groups
            // N items per group
            // NN neurons. NN=N^M
            active_handshaker<NN> x(g,,);
            passive_handshaker<NN> y(,);
            AER<M, N, NN> aer(g, x.o, x.i, y.o, y.i);
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER1 (globals g) {
            // Tests AER with 1 neuron
            // M groups
            // N items per group
            // NN neuron ports. NN=N^M
            active_handshaker<1> x(g,,);
            passive_handshaker<1> y(,);
            AER<M, N, NN> aer(g,,,,);
            aer.xi[0] = x.o[0];
            aer.xo[0] = x.i[0];
            aer.yi[0] = y.o[0];
            aer.yo[0] = y.i[0];
            (; nn : 1..NN-1 :
                aer.xi[nn] = g.GND;
                aer.yi[nn] = g.GND;
            )
        }
    } // namespace test
} // namespace aer
