// This file defines a serialized tree tranceiver
import "lib/globals.act";
import "lib/channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";

namespace aer {
    namespace transmitter {
        export
        template <pint N>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; c1of<N> c[N], p) {
            // AEXT tree NODE controller
            /*--------------------------------------------------------------*/
            // /* // development
                bool c_[N], u;
                c1of<N> w;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c_[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c_[n]) -> po-
                
                    (: n : N :
                        c_[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c_[0] & u & pi & ~co[1] -> co[0]+
                    ~pi -> co[0]-
                    c_[1] & u & pi & ~co[0] -> co[1]+
                    ~pi -> co[1]-
                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c_[N], q[N], u;
                c1of<N> w;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    c_[0] & ~co[1] -> q[0]+
                    g.pReset | ~c_[0] & co[0] -> q[0]-
                    c_[1] & ~co[0] -> q[1]+
                    g.pReset | ~c_[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: nc : N :
                        q[nc] & u & pi -> co[nc]+
                        (~u | (| : n : N : p.d[n])) & ~pi -> co[nc]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            */
            /*--------------------------------------------------------------*/
        }

        template <pint N>
        defproc LEAF (globals g; bool ci[N], co[N], pi, po; c1of<N> p) {
            // leaf node of aext tree
            /*--------------------------------------------------------------*/
            // /* // development
                bool c[N], u;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c[n]) -> po-
                
                    (: n : N :
                        c[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c[0] & u & pi & ~co[1] -> co[0]+
                    ~pi -> co[0]-
                    c[1] & u & pi & ~co[0] -> co[1]+
                    ~pi -> co[1]-
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c[N], q[N], u;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    c[0] & ~co[1] -> q[0]+
                    g.pReset | ~c[0] & co[0] -> q[0]-
                    c[1] & ~co[0] -> q[1]+
                    g.pReset | ~c[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: n : N :
                        q[n] & u & pi -> co[n]+
                        ~u & ~pi -> co[n]-
                    )
                }
            */
        }

        export
        template <pint N>
        defproc OUT (globals g; bool xi, xo; c1of<N> x; e1of<N> y) {
            // interface AEXT tree with e1ofN channel
            x.d = y.d;
            prs {
                xi & y.e => xo+
            }
        }

        export
        template <pint M, N, NN>
        defproc AEXT (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
            // utility for AEXT
            [ M = 0 ->
                0 = 1;
            [] M = 1 ->
                NN = N;
                LEAF<N> leaf(g, xi, xo, pi, po, p);
            [] M > 1 ->
                pint k = NN/N;
                AEXT<M-1, N, k> _[N];
                (; n : N :
                    _[n].g = g;
                    _[n].xi = xi[n*k..(n+1)*k-1];
                    _[n].xo = xo[n*k..(n+1)*k-1];
                )

                NODE<N> node(g,,, pi, po,, p);
                (; n : N :
                    node.ci[n] = _[n].po;
                    node.co[n] = _[n].pi;
                    node.c[n] = _[n].p;
                )
            ]
        }

        namespace test {
            template <pint M, N, NN>
            defproc TEST_AEXT_ (globals g; bool xi[NN], xo[NN]; e1of<N> y) {
                // M layers in the tree
                // N for 1-of-N encoding. + tail word line
                // NN = N^M neurons
                AEXT<M, N, NN> aext(g, xi, xo,,,);
                OUT<N> out(g, aext.po, aext.pi, aext.p, y);
            }

            export
            template <pint M, N, NN>
            defproc TEST_AEXT (globals g) {
                // M layers in the tree
                // N for 1-of-N encoding. + tail word line
                // NN = N^M neurons
                active_handshaker<NN> a(g,,);
                TEST_AEXT_<M, N, NN> aext(g, a.o, a.i,);
                VN_e1ofN<N> vn(aext.y);
            }

            export
            template <pint M, N, NN, nn>
            defproc TEST_AEXT1 (globals g) {
                // M layers in the tree
                // N for 1-of-N encoding. + tail word line
                // NN = N^M neurons
                active_handshaker<1> a(g,,);
                TEST_AEXT_<M, N, NN> aext(g,,,);
                VN_e1ofN<N> vn(aext.y);
                a.o[0] = aext.xi[nn];
                a.i[0] = aext.xo[nn];
                [ nn > 0 ->
                    (; idx : 0..nn-1 :
                        aext.xi[idx] = g.GND;
                    )
                ]
                [ nn < NN ->
                    (; idx : nn+1..NN-1 :
                        aext.xi[idx] = g.GND;
                    )
                ]
            }
        } // namespace test
    } // namespace transmitter

    namespace receiver {
        template <pint N>
        defproc NODE (globals g; bool pi, po, ci[N], co[N]; c1of<N> p, c[N]) {
            // node in AERV tree
            bool u[N], cco, cci, uu;
            prs<g.Vdd, g.GND> {
                (pi & ~cco | cci) & ~uu => po+

                (: n : N :
                    u[n] & ~p.d[n] -> co[n]+
                    ~pi -> co[n]-
                )

                (| : n : N : ci[n]) => cci+
                (| : n : N : co[n]) => cco+

                (: n : N :
                    p.d[n] & ~cco -> u[n]+
                    g.pReset | cco -> u[n]-
                )

                (| : n : N : u[n]) => uu+

                (: nc : N :
                    (: n : N :
                        co[nc] & p.d[n] => c[nc].d[n]+
                    )
                )
            }
        }

        template <pint N>
        defproc LEAF_DATA1 (globals g; bool pi, po, ci[N]; c1of<N> p, c[N]) {
            // leaf of AERV tree
            bool u[N], co[N], cco, cci, uu;
            prs<g.Vdd, g.GND> {
                (pi | cco) & ~uu & ~cci => po+

                (: n : N :
                    ~cco & p.d[n] -> u[n]+
                    g.pReset | cco -> u[n]-
                )
                (| : n : N : u[n]) => uu+

                (: n : N :
                    u[n] & ~p.d[n] -> co[n]+
                    ~pi -> co[n]-
                )
                (| : n : N : co[n]) => cco+

                (| : n : N : ci[n]) => cci+

                (: nc : N :
                    (: n : N :
                        co[nc] & p.d[n] => c[nc].d[n]+
                    )
                )
            }
        }

        template <pint N>
        defproc LEAF_NODATA (globals g; bool pi, po, ci[N], co[N]; c1of<N> p) {
            // leaf of AERV tree that does not transmit data
            bool u;
            prs<g.Vdd, g.GND> {
                pi & (& : n : N : ~ci[n]) | u => po+

                (| : n : N : ci[n] & ~p.d[n]) => u+

                (: n : N :
                    p.d[n] -> co[n]+
                    ~pi -> co[n]-
                )
            }
        }

        export
        template <pint M, N, NN>
        defproc AERV_NODATA (globals g; bool yi[NN], yo[NN], pi, po; c1of<N> p) {
            // receiver that does not send data to neurons
            [ M = 1 ->
                NN = N;
                LEAF_NODATA<N> leaf(g, pi, po, yi, yo, p);
            [] M > 1 ->
                AERV_NODATA<M-1, N, NN/N> _[N];
                NODE<N> node(g, pi, po,,, p,);
                pint k = NN/N;
                (; n : N :
                    _[n].g = g;
                    _[n].p = node.c[n];
                    _[n].pi = node.co[n];
                    _[n].po = node.ci[n];
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].yo = yo[n*k..(n+1)*k-1];
                )
            ]
        }

        export
        template <pint M, N, NN>
        defproc AERV_DATA (globals g; bool yi[NN], yo[NN], pi, po; c1of<N> p, c[NN]) {
            // receiver capable of sending data to neuron
            [ M = 1 ->
                NN = N;
                NODE<N> node(g, pi, po, yi, yo, p, c);
            [] M > 1 ->
                AERV_DATA<M-1, N, NN/N> _[N];
                NODE<N> node(g, pi, po,,, p,);
                pint k = NN/N;
                (; n : N :
                    _[n].g = g;
                    _[n].p = node.c[n];
                    _[n].pi = node.co[n];
                    _[n].po = node.ci[n];
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].yo = yo[n*k..(n+1)*k-1];
                    _[n].c = c[n*k..(n+1)*k-1];
                )
            ]
        }

        export
        template <pint M, N, NN>
        defproc AERV_DATA1 (globals g; bool yi[NN], pi, po; c1of<N> p, c[NN]) {
            // receiver capable of sending data to neuron
            [ M = 1 ->
                NN = N;
                LEAF_DATA1<N> leaf(g, pi, po, yi, p, c);
            [] M > 1 ->
                AERV_DATA1<M-1, N, NN/N> _[N];
                NODE<N> node(g, pi, po,,, p,);
                pint k = NN/N;
                (; n : N :
                    _[n].g = g;
                    _[n].p = node.c[n];
                    _[n].pi = node.co[n];
                    _[n].po = node.ci[n];
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].c = c[n*k..(n+1)*k-1];
                )
            ]
        }

        namespace test {
        } // namespace test
    } // namespace receiver

    export
    template <pint M, N, NN>
    defproc AER_NODATA (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        transmitter::AEXT<M, N, NN> aext(g, xi, xo,,,);
        receiver::AERV_NODATA<M, N, NN> aerv(g, yi, yo,,,);
        aext.pi = aerv.po;
        aext.po = aerv.pi;
        aext.p = aerv.p;
    }

    export
    template <pint M_AEXT, M_AERV, N, NN_AEXT, NN_AERV>
    defproc AER_DATA1 (globals g; bool xi[NN_AEXT], xo[NN_AEXT], yi[NN_AERV]; c1of<N> y[NN_AERV]) {
        // address-event representation tranceiver
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M_AEXT groups in transmitter
        // M_AERV groups in receiver
        // N items per group
        // NN=N^M
        transmitter::AEXT<M_AEXT, N, NN_AEXT> aext(g, xi, xo,,,);
        receiver::AERV_DATA1<M_AERV, N, NN_AERV> aerv(g, yi,,,, y);
        aext.pi = aerv.po;
        aext.po = aerv.pi;
        aext.p = aerv.p;
    }

    export
    template <pint M_AEXT, M_AERV, N, NN_AEXT, NN_AERV>
    defproc AER_DATA (globals g; bool xi[NN_AEXT], xo[NN_AEXT], yi[NN_AERV], yo[NN_AERV]; c1of<N> y[NN_AERV]) {
        // address-event representation tranceiver
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        transmitter::AEXT<M_AEXT, N, NN_AEXT> aext(g, xi, xo,,,);
        receiver::AERV_DATA<M_AERV, N, NN_AERV> aerv(g, yi, yo,,,, y);
        aext.pi = aerv.po;
        aext.po = aerv.pi;
        aext.p = aerv.p;
    }

    namespace test {
        export
        template <pint M, N, NN>
        defproc TEST_AER1_NODATA (globals g) {
            // Tests AER with 1 neuron
            // M groups
            // N items per group
            // NN neuron ports. NN=N^M
            active_handshaker<1> x(g,,);
            active_handshaker<1> y(g,,);
            AER_NODATA<M, N, NN> aer(g,,,,);
            aer.xi[0] = x.o[0];
            aer.xo[0] = x.i[0];
            aer.yi[0] = y.o[0];
            aer.yo[0] = y.i[0];
            (; nn : 1..NN-1 :
                aer.xi[nn] = g.GND;
                aer.yi[nn] = g.GND;
            )
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER_NODATA (globals g) {
            // M groups
            // N items per group
            // NN neurons. NN=N^M
            active_handshaker<NN> x(g,,);
            passive_handshaker<NN> y(,);
            AER_NODATA<M, N, NN> aer(g, x.o, x.i, y.o, y.i);
        }

        template <pint N, NN>
        defproc AERV_NRN_FULL(bool i[NN], o[NN]; c1of<N> d[NN]) {
            prs {
                (: nn : NN :
                    i[nn] & (& : n : N : ~d[nn].d[n]) => o[nn]+
                )
            }
        }

        export
        template <pint M_AEXT, M_AERV, N, NN_AEXT, NN_AERV>
        defproc TEST_AER_DATA (globals g) {
            // M groups
            // N items per group
            // NN receiver neurons. NN=N^M
            // NN*M transmitter neurons generate data for receiver neurons
            active_handshaker<NN_AEXT> x(g,,);
            AERV_NRN_FULL<N, NN_AERV> y(,,);
            AER_DATA<M_AEXT, M_AERV, N, NN_AEXT, NN_AERV> aer(g, x.o, x.i, y.o, y.i, y.d);
        }

        template <pint N, NN>
        defproc AERV_NRN_SIMPLE(c1of<N> i[NN]; bool o[NN]) {
            VN_a1ofN<N> vn[NN];
            (; nn : NN :
                vn[nn].d.m = i[nn];
                vn[nn].d.a = o[nn];
            )
        }

        export
        template <pint M_AEXT, M_AERV, N, NN_AEXT, NN_AERV>
        defproc TEST_AER_DATA1 (globals g) {
            // M groups
            // N items per group
            // NN receiver neurons. NN=N^M
            // NN*M transmitter neurons generate data for receiver neurons
            active_handshaker<NN_AEXT> x(g,,);
            AERV_NRN_SIMPLE<N, NN_AERV> y(,);
            AER_DATA1<M_AEXT, M_AERV, N, NN_AEXT, NN_AERV> aer(g, x.o, x.i, y.o, y.i);
        }
    } // namespace test
} // namespace aer
