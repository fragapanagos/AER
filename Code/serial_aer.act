// This file defines a serialized tree tranceiver
import "lib/globals.act";
import "lib/channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";

namespace aer {
    namespace transmitter {
        export
        template <pint N>
        defproc FWDT (globals g; bool ci, co; e1of<N+1> x, y) {
            // forward words and detect tail
            // N for 1-of-N encoding. +1 tail word line
            (; n : N : x.d[n] = y.d[n];)
            prs {
                ci & y.e -> x.e+
                ~ci | ~y.e -> x.e-

                y.d[N] & ~x.e -> co+
                ~y.d[N] | x.e -> co-

                g._sReset & x.d[N] -> y.d[N]+
                g.pReset | ~x.d[N] & ~ci -> y.d[N]-
            }
        }

        template <pint N>
        defproc MERGE (globals g; bool m[N], mw; e1of<N+1> c[N], p; e1of<N> cw) {
            // controlled merge
            prs {
                (: n : N : p.e & m[n] => c[n].e+)
                p.e & mw => cw.e+

                (: n : N : // data
                    (| : nc : N : c[nc].d[n]) | cw.d[n] => p.d[n]+
                )
                (| : nc : N : c[nc].d[N]) => p.d[N]+ // tail
            }
        }

        template <pint N>
        defproc WORD (globals g; e1of<N> x, y) {
            // injects a word
            y = x;
        }

        export
        template <pint N>
        defproc CTRL (globals g; bool ci[N], co[N], pi, po,
                      m[N], mw, fi[N], fo[N]; e1of<N> w) {
            // AEXT tree NODE controller
            bool c[N];
            ::arbiter::N_ARB<N> arb(g, ci, c);

            prs<g.Vdd, g.GND> {
                c[0] & ~fi[0] & ~co[1] | c[1] & ~fi[1] & ~co[0] -> po+
                g.pReset | fi[0] | fi[1] -> po-

                pi & (& : n : N : ~m[n]) -> mw+
                g.pReset | (| : n : N : m[n]) -> mw-
                (: n : N :
                    w.d[n] & ~w.e -> m[n]+
                    ~pi -> m[n]-
                )

                (: n : N :
                    c[n] & w.e & mw -> w.d[n]+
                    ~mw -> w.d[n]-
                )

                (: n : N :
                    m[n] & ~w.d[n] -> fo[n]+
                    ~c[n] -> fo[n]-
                )

                (: n : N :
                    fi[n] & ~m[n] -> co[n]+
                    ~fi[n] | m[n] -> co[n]-
                )
            }
        }

        export
        template <pint N>
        defproc INT (globals g; bool ni, no, ci, co; e1of<N+1> d) {
            // neuron interface to AEXT tree
            (; n : N : d.d[n] = g.GND;)
            prs<g.Vdd, g.GND> {
                ni -> co+
                ~ni -> co-

                ni & d.e -> d.d[N]+
                ~ni & ~d.e -> d.d[N]-

                ci & d.d[N] -> no+
                ~ci & ~d.d[N] -> no-
            }
        }

        export
        template <pint N>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; e1of<N+1> c[N], p) {
            // node in the AEXT tree
            CTRL<N> ctrl(g, ci, co, pi, po,,,,,);
            WORD<N> word(g, ctrl.w,);
            MERGE<N> merge(g, ctrl.m, ctrl.mw,, p, word.y);
            FWDT<N> fwdt[N];
            (; n : N :
                fwdt[n].g = g;
                fwdt[n].ci = ctrl.fo[n];
                fwdt[n].co = ctrl.fi[n];
                fwdt[n].x = c[n];
                fwdt[n].y = merge.c[n];
            )
        }

        export
        template <pint M, N, NN>
        defproc AEXT_ (globals g; bool xi[NN], xo[NN]; a1of<N+1> y) {
            // utility for AEXT
        }

        export
        template <pint N, M, NN>
        defproc AEXT (globals g; bool xi[NN], xo[NN]; e1of<N+1> y) {
            // Serial transmitter
            // M layers in the tree
            // N for 1-of-N encoding. + tail word line
            // NN = N^M neurons
        }

        namespace test {
            export
            template <pint N>
            defproc TEST_FWDT (globals g; e1of<N+1> x,y) {
                active_handshaker<1> c(g,,);
                FWDT<N> fwdt(g, c.o[0], c.i[0],,);
                VN_e1ofN<N+1> vn(fwdt.y);
                x = fwdt.x;
                y = fwdt.y;
            }

            export
            template <pint N>
            defproc TEST_CTRL (globals g) {
                CTRL<N> ctrl(g,,,,,,,,,);
                active_handshaker<N> c(g, ctrl.co, ctrl.ci);
                passive_handshaker<1> p(,);
                p.i[0] = ctrl.po;
                p.o[0] = ctrl.pi;
                VN_e1ofN<N> w(ctrl.w);
                passive_handshaker<N> fwdt(ctrl.fo, ctrl.fi);
            }

            export
            template <pint N>
            defproc TEST_NODE (globals g) {
                NODE<N> node(g,,,,,,);
                INT<N> nint[N];
                active_handshaker<N> nrn(g,,);
                passive_handshaker<1> p(,);
                VN_e1ofN<N+1> vn(node.p);

                (; n : N :
                    nint[n].g = g;
                    nint[n].ni = nrn.o[n];
                    nint[n].no = nrn.i[n];
                    node.ci[n] = nint[n].co;
                    node.co[n] = nint[n].ci;
                    node.c[n] = nint[n].d;
                )
                node.pi = p.o[0];
                node.po = p.i[0];
            }

            export
            template <pint M, N, NN>
            defproc TEST_AEXT (globals g) {
                // M layers in the tree
                // N for 1-of-N encoding. + tail word line
                // NN = N^M neurons
                active_handshaker<NN> a(g,,);
                AEXT<N, M, NN> aext(g, a.o, a.i,);
                VN_e1ofN<N+1> vn(aext.y);
            }
        } // namespace test
    } // namespace transmitter

    namespace receiver {
        template <pint N>
        defproc INT (e1of<N+1> x; bool yi, yo) {
            // interface with the neuron
            // N for 1-of-N encoding. + tail word line
            yi = x.e;
            x.d[N] = yo;
        }

        template <pint N, NC>
        defproc ROUTE (globals g; e1of<N+1> p, c[NC]; e1of<N> h) {
            // routes parent data to requesting child
            // assumes child requests are mutually exclusive
            //
            // parameters
            // ----------
            // N for 1-of-N encoding. + tail word line
            // NC children
            // 
            // ports
            // -----
            // p parent, active
            // c children, passive
            // h read_head, passive
            prs {
                (| : nc : NC : c[nc].e) | h.e => p.e+
                
                (: nc : NC :
                    (: n : N+1 :
                        p.d[n] & c[nc].e -> c[nc].d[n]+
                        ~p.d[n] -> c[nc].d[n]-
                    )
                )

                (: n : N :
                    p.d[n] & h.e -> h.d[n]+
                    ~p.d[n] -> h.d[n]-
                )
            }
        }

        template <pint N>
        defproc READ_HEAD (globals g; e1of<N> x; bool si, s[N]) {
            // reads the head of a packet to determine the routing direction
            // N for 1-of-N encoding. + tail word line
            bool u[N];
            /* version [si];xe+;[xi];u+;xe-;[~xi];so+;[~si];u-;so- ----------*/
            // /*
                prs<g.Vdd, g.GND> {
                    si & (& : n : N : ~u[n]) -> x.e+
                    (| : n : N : u[n]) -> x.e-

                    (: n : N :
                        x.d[n] -> u[n]+
                        g.pReset | ~si -> u[n]-
                    )

                    (: n : N :
                        u[n] & ~x.d[n] -> s[n]+
                        g.pReset | ~u[n] | x.d[n] -> s[n]-
                    )
                }
            // */
        }

        template <pint N>
        defproc FWD_BODY (globals g; e1of<N+1> p, c[N]; bool s[N], so) {
            // forwards the body of a packet to a child
            // N for 1-of-N encoding. + tail word line
            /* version pipelined --------------------------------------------*/
            /*
                bool q;
                OR<(N+1)*N> or(, q);
                (; nc : N : (; n : N+1 : or.i[nc*(N+1)+n] = c[nc].d[n];))

                prs<g.Vdd, g.GND> {
                    (| : n : N : s[n]) & ~q -> p.e+
                    g.pReset | q -> p.e-

                    ~q -> so+
                    ~p.d[N] & (| : n : N : ~c[n].e & c[n].d[N]) -> so-

                    (: nc : N :
                        (: n : N :
                            p.d[n] & s[nc] & c[nc].e -> c[nc].d[n]+
                            g.pReset | ~p.d[n] & ~c[nc].e -> c[nc].d[n]-
                        )
                        p.d[N] & s[nc] & c[nc].e -> c[nc].d[N]+ // tail
                        g.pReset | ~s[nc] -> c[nc].d[N]-
                    )
                }
            */
            /* version unpipelined ------------------------------------------*/
            // /*
                prs<g.Vdd, g.GND> {
                    (| : n : N : s[n] & c[n].e) -> p.e+
                    g.pReset | (| : n : N : s[n] & ~c[n].e) -> p.e-

                    (& : n : N : ~c[n].d[N]) -> so+
                    ~p.d[N] & (| : n : N : c[n].d[N]) -> so-

                    (: nc : N :
                        (: n : N :
                            p.d[n] & s[nc] -> c[nc].d[n]+
                            g.pReset | ~p.d[n] | ~s[nc] -> c[nc].d[n]-
                        )
                        p.d[N] & s[nc] -> c[nc].d[N]+
                        g.pReset | ~s[nc] -> c[nc].d[N]-
                    )
                }
            // */
        }

        template <pint N>
        defproc NODE (globals g; e1of<N+1> p, c[N]) {
            // node in receiver tree
            // N for 1-of-N encoding. + tail word line
            ROUTE<N, 1> route(g, p,,);
            READ_HEAD<N> head(g, route.h,,);
            FWD_BODY<N> fwd(g, route.c[0], c, head.s, head.si);
        }

        export
        template <pint N, M, NN>
        defproc AERV (globals g; e1of<N+1> x; bool yi[NN], yo[NN]) {
            // Serial receiver
            // N for 1-of-N encoding
            // M layers in the tree
            // NN = N^M neurons
            [ M = 0 ->
                NN = 1; // check that NN = N^M
                INT<N> n_int(x, yi[0], yo[0]);
            [] M > 0 ->
                bool xt = x.d[N];
                pint k = NN/N;
                NODE<N> node(g, x,);
                AERV<N, M-1, k> _[N];

                (; n : N : g = _[n].g;)
                (; n : N : node.c[n] = _[n].x;)
                (; n : N-1 :
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].yo = yo[n*k..(n+1)*k-1];
                )
                _[N-1].yi = yi[(N-1)*k..NN-1];
                _[N-1].yo = yo[(N-1)*k..NN-1];
            ]
        }

        namespace test {
        } // namespace test
    } // namespace receiver

    export
    template <pint N, M, NN>
    defproc AER (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        transmitter::AEXT<N, M, NN> aext(g, xi, xo,);
        receiver::AERV<N, M, NN> aerv(g,, yi, yo);
        aext.y = aerv.x;
    }

    namespace test {
        export
        template <pint N, M, NN>
        defproc TEST_AER (globals g) {
            // M groups
            // N items per group
            // NN neurons. NN=N^M
            active_handshaker<NN> x(g,,);
            active_handshaker<NN> y(g,,);
            AER<M, N, NN> aer(g, x.o, x.i, y.o, y.i);
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER1 (globals g) {
            // Tests AER with 1 neuron
            // M groups
            // N items per group
            // NN neuron ports. NN=N^M
            active_handshaker<1> x(g,,);
            active_handshaker<1> y(g,,);
            AER<M, N, NN> aer(g,,,,);
            aer.xi[0] = x.o[0];
            aer.xo[0] = x.i[0];
            aer.yi[0] = y.o[0];
            aer.yo[0] = y.i[0];
            (; nn : 1..NN-1 :
                aer.xi[nn] = g.GND;
                aer.yi[nn] = g.GND;
            )
        }
    } // namespace test
} // namespace aer
