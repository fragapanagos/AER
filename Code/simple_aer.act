// This file contains PRS for a simple address event transmitter/receiver
import "lib/globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "test.act";

namespace aer {
    template <pint N>
    defproc STATE (globals g; bool c[N], co[N], si[N], so[N]) {
        // Transmitter state sequences inputs to encoder
        bool x[N];
        (; n : N :
            prs<g.Vdd,g.GND> {
                    c[n] & ~x[n] -> so[n]+
                    g.pReset | x[n] -> so[n]-

                    ~si[n] & x[n] -> co[n]+
                    si[n] | ~x[n] -> co[n]-

                    si[n] -> x[n]+
                    ~c[n] -> x[n]-
            }
        )
    }

    template <pint m, M, N, NN, LR, NR>
    defproc _ENC (bool vi, si[NN]; aMx1ofN<M,N> d) {
        // recursive utility to build the encoding function
        // converts 1-of-NN encoding (NN = N^M) to M-1-of-N encoding
        // m group index
        // N elements per group
        // NN total elements
        // LR length per run
        // NR number of runs
        prs {
            (: n : N :
                vi & (| : nr : NR : 
                     (| : lr : LR :
                        si[n*LR + nr*N*LR + lr])) -> d.m[m].n[n]+
            )
        }

        [LR != 1 ->
            _ENC<m+1, M, N, NN, LR/N, NR*N> _enc(vi, si, d);
        ]
    }

    template <pint M, N, NN>
    defproc ENC (bool vi, si[NN], so[NN]; aMx1ofN<M,N> d) {
        // Transmitter encoder converts 1-of-NN encoding into M-1-of-N encoding
        // M encoding groups
        // N neurons per group
        // N^M = NN total neurons

        // encode
        pint m_0 = 0;
        pint LR_0 = NN/N;
        pint NR_0 = 1;
        _ENC<m_0, M, N, NN, LR_0, NR_0> _enc(vi, si, d);

        // reset encoding
        prs {
            (: m : M :
                (: n : N :
                    ~vi -> d.m[m].n[n]-
                )
            )
        }

        // communicate with STATE
        prs {
            (: nn : NN :
                si[nn] & d.a -> so[nn]+
                ~si[nn] & ~d.a -> so[nn]-
            )
        }
    }

    export
    template <pint M,N>
    defproc VN (bool i[M*N], o) {
        // detects valid/neutral data
        OR<N> or[M];
        (; m : M :
            (; n : N :
                or[m].i[n] = i[m*N+n];
            )
        )

        C_TREE<M> c_tree(,o);

        (; k : M :
            or[k].o = c_tree.i[k];
        )
    }

    export
    template <pint M,N,NN>
    defproc AEXT (globals g; bool ci[NN], co[NN]; aMx1ofN<M,N> d) {
        ::arbiter::N_ARB<NN> arb(g, ci,);
        STATE<NN> state(g,, co,,);
        VN<1, NN> vn(,);
        ENC<M, N, NN> enc(,,,);

        state.c = arb.co;
        state.so = enc.si;
        state.si = enc.so;
        state.so = vn.i;
        vn.o = enc.vi;
        enc.d = d;
    }

    export
    template <pint M, N, NN>
    defproc AERV (globals g; bool ri[NN], ro[NN]; aMx1ofN<M,N> d) {
        // receiver
        VN<M,N> vn(,);
    }

    export
    template <pint M, N, NN>
    defproc AER (globals g; bool ci[NN], co[NN], ri[NN], ro[NN]) {
        // AER system. 
        // Transmits spikes from transmitter neurons to receiver neurons
        AEXT<M,N,NN> aext(g,ci,co,);
        AERV<M,N,NN> aerv(g,ri,ro,);
        aext.d = aerv.d;
    }

    namespace test {
        export
        template <pint M, N, NN>
        defproc TEST_AEXT(globals g) {
            active_handshaker<NN> s(g,,);
            AEXT<M, N, NN> aext(g,,,);
            aext.ci = s.o;
            aext.co = s.i;

            VN<M, N> vn(, aext.d.a);
            (; m : M :
                (; n : N :
                    vn.i[m*N+n] = aext.d.m[m].n[n];
                )
            )
        }

        export
        template <pint M, N, NN, k>
        defproc TEST_AEXT1(globals g) {
            active_handshaker<1> s(g,,);
            AEXT<M, N, NN> aext(g,,,);
            (; nn : NN :
                [ nn = k ->
                    aext.ci[nn] = s.o[0];
                    aext.co[nn] = s.i[0];
                [] nn != k ->
                    aext.ci[nn] = g.GND;
                ]
            )

            VN<M, N> vn(, aext.d.a);
            (; m : M :
                (; n : N :
                    vn.i[m*N+n] = aext.d.m[m].n[n];
                )
            )
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER(globals g) {
            active_handshaker<NN> s(g,,);
            passive_handshaker<NN> r(g,,);
            AER<M,N,NN> aer(g,,,,);

            aer.ci = s.o;
            aer.co = s.i;
            aer.ro = r.i;
            aer.ri = r.o;
        }
    }
}
