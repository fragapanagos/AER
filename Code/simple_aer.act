// This file contains PRS for a simple address event transmitter/receiver
import "lib/globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "test.act";

namespace aer {
    template <pint N>
    defproc CTRL (globals g; bool ci[N], co[N], si[N], so[N]) {
        bool c[N];
        ::arbiter::N_ARB<N> arb(g, ci, c);
        bool x[N];
        prs {
            (: n : N :
                c[n] & ~x[n] -> so[n]+
                ~c[n] | x[n] -> so[n]-

                ~si[n] & x[n] -> co[n]+
                si[n] | ~x[n] -> co[n]-

                si[n] -> x[n]+
                ~c[n] -> x[n]-
            )
        }
    }

    template <pint N>
    defproc ENC_XMIT (bool si[N], so[N], xo[N], di) {
        // Transmission portion of encoder 
        // Sequences inputs to encoder function block
        prs {
            (: n : N :
                si[n] -> xo[n]+
                ~si[n] -> xo[n]-

                xo[n] & di -> so[n]+
                ~xo[n] & ~di -> so[n]-
            )
        }
    }

    template <pint m, M, N, NN, LR, NR>
    defproc _ENC_FBLK (bool vi, xi[NN]; aMx1ofN<M,N> d);

    template <pint M, N, NN>
    defproc ENC_FBLK (bool vi, xi[NN]; aMx1ofN<M,N> d) {
        // Function block portion of encoder
        // Converts 1-of-NN encoding into M-1-of-N encoding
        // M encoding groups
        // N neurons per group
        // N^M = NN total neurons

        // encode
        pint m_0 = 0;
        pint LR_0 = NN/N;
        pint NR_0 = 1;
        _ENC_FBLK<m_0, M, N, NN, LR_0, NR_0> _enc_fblk(vi, xi, d);
    }

    template <pint m, M, N, NN, LR, NR>
    defproc _ENC_FBLK (bool vi, xi[NN]; aMx1ofN<M,N> d) {
        // recursive utility to build the encoding function
        // converts 1-of-NN encoding (NN = N^M) to M-1-of-N encoding
        // m group index
        // N elements per group
        // NN total elements
        // LR length per run
        // NR number of runs
        prs {
            (: n : N :
                vi & (| : nr : NR : 
                     (| : lr : LR :
                        xi[n*LR + nr*N*LR + lr])) -> d.m[m].n[n]+
                ~vi -> d.m[m].n[n]-
            )
        }

        [LR != 1 ->
            _ENC_FBLK<m+1, M, N, NN, LR/N, NR*N> _enc_fblk(vi, xi, d);
        ]
    }

    export
    template <pint M,N>
    defproc VN (bool i[M*N], o) {
        // detects valid/neutral data
        OR<N> or[M];
        (; m : M :
            (; n : N :
                or[m].i[n] = i[m*N+n];
            )
        )

        C_TREE<M> c_tree(,o);

        (; k : M :
            or[k].o = c_tree.i[k];
        )
    }

    export
    template <pint M,N,NN>
    defproc AEXT (globals g; bool ci[NN], co[NN]; aMx1ofN<M,N> d) {
        CTRL<NN> ctrl(g, ci, co,,);
        ENC_XMIT<NN> enc_xmit(,,, d.a);
        ENC_FBLK<M, N, NN> enc_fblk(,,d);
        VN<1, NN> vn(,);

        ctrl.si = enc_xmit.so;
        ctrl.so = enc_xmit.si;
        enc_xmit.xo = enc_fblk.xi;
        enc_xmit.xo = vn.i;
        enc_fblk.vi = vn.o;
    }

    export
    template <pint M, N, NN>
    defproc AERV (globals g; bool ri[NN], ro[NN]; aMx1ofN<M,N> d) {
        // receiver
        VN<M,N> vn(,);
    }

    export
    template <pint M, N, NN>
    defproc AER (globals g; bool ci[NN], co[NN], ri[NN], ro[NN]) {
        // AER system. 
        // Transmits spikes from transmitter neurons to receiver neurons
        AEXT<M,N,NN> aext(g,ci,co,);
        AERV<M,N,NN> aerv(g,ri,ro,);
        aext.d = aerv.d;
    }

    namespace test {
        export
        template <pint M, N, NN>
        defproc TEST_AEXT(globals g) {
            active_handshaker<NN> s(g,,);
            AEXT<M, N, NN> aext(g,,,);
            aext.ci = s.o;
            aext.co = s.i;

            VN<M, N> vn(,);
            (; m : M :
                (; n : N :
                    vn.i[m*N+n] = aext.d.m[m].n[n];
                )
            )
            vn.o = aext.d.a;
        }

        export
        template <pint M, N, NN, k>
        defproc TEST_AEXT1(globals g) {
            active_handshaker<1> s(g,,);
            AEXT<M, N, NN> aext(g,,,);
            (; nn : NN :
                [ nn = k ->
                    aext.ci[nn] = s.o[0];
                    aext.co[nn] = s.i[0];
                [] nn != k ->
                    aext.ci[nn] = g.GND;
                ]
            )

            VN<M, N> vn(, aext.d.a);
            (; m : M :
                (; n : N :
                    vn.i[m*N+n] = aext.d.m[m].n[n];
                )
            )
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER(globals g) {
            active_handshaker<NN> s(g,,);
            passive_handshaker<NN> r(g,,);
            AER<M,N,NN> aer(g,,,,);

            aer.ci = s.o;
            aer.co = s.i;
            aer.ro = r.i;
            aer.ri = r.o;
        }
    }
}
