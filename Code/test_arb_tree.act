// Tests the multiple arbiter cells configured in a tree
import "lib/globals.act";
import "arbiter.act";
import "test.act";

pint N=8;

globals g;
passive_handshaker p(g,,);
active_handshaker c[N];
arbiter::H_ARB h_arb[N-1];

(; i : N : c[i].g=g;) // connect globals to chidren
(; i : N-1 : h_arb[i].g=g;) // connect globals to arbiters

// connect arbiters in tree
(; i : N-2 : 
    [ (i%2) = 0 -> 
        h_arb[i].p.o = h_arb[(N+i)/2].c1.i;
        h_arb[i].p.i = h_arb[(N+i)/2].c1.o;
    [] (i%2) = 1 ->
        h_arb[i].p.o = h_arb[(N+i)/2].c2.i;
        h_arb[i].p.i = h_arb[(N+i)/2].c2.o;
    ]
)

// connect top of arbiter tree to parent
h_arb[N-2].p.o = p.i;
h_arb[N-2].p.i = p.o;

// connect children to arbiter tree leaves
(; i : N : 
    [ (i%2) = 0 -> 
       c[i].o = h_arb[i/2].c1.i;
       c[i].i = h_arb[i/2].c1.o;
    [] (i%2) = 1 ->
       c[i].o = h_arb[i/2].c2.i;
       c[i].i = h_arb[i/2].c2.o;
    ]
)

bool pReset, sReset;
prs {
    sReset => g.sReset+
    pReset => g.pReset+
    sReset => g._sReset-
    pReset => g._pReset-
    sReset -> g.Vdd+
    sReset -> g.GND-
}
