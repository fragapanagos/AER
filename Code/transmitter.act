// This file contains PRS for the transmitter circuits
import "lib/globals.act";
import "channel.act";
import "test.act";

namespace transmitter {
    export
    defproc EVT (globals g; bool pi, po, ri, ro, ci, co) {
        bool u, _pi;
        prs {
            ~g.sReset & ~_pi & ~ri -> ro+
            g.pReset | _pi          -> ro-
    
            g.pReset | ri & ro -> u-
            ~g.sReset & ~ri     -> u+
    
            u => po-
            u => co-
    
            pi => _pi-
        }
    }

    export
    defproc INT (globals g; bool vi, vo, ei, eo, ci, co) {
    }
    
    export
    defproc ARB_stat (globals g; bool li[2], lo[2], ri, ro) {
        // ARB_stat is the arbiter using synchronizers
        bool _ai[2], _ao[2], ao[2], _ri;
    
        //Force Arbiter Behavior
        spec {
            mk_excllo(_ai[0],_ai[1])
        }
    
        //Implement fair and greedy algorithm
        prs<g.Vdd,g.GND> {
            //asymmetric c-elements
            li[0] & _ri -> _ao[0]-
            ~li[0]      -> _ao[0]+
            li[1] & _ri -> _ao[1]-
            ~li[1]      -> _ao[1]+
    
            // staticizers
            _ao[0] => ao[0]-
            _ao[1] => ao[1]-
    
            // parent lines
            ao[0] | ao[1] => ro+
            ri => _ri-
        }
    
        //Cross-Coupled NANDs
        prs<g.Vdd,g.GND> {
            ao[0] & _ai[1]   => _ai[0]-
            ao[1] &  _ai[0]  => _ai[1]-
        }
    
        //Filter
        prs<g.Vdd,g.GND> {
            _ai[0] & _ri   -> lo[0]-
            ~_ai[0] & ~_ri -> lo[0]+ // requires staticizer
            _ai[1] & _ri   -> lo[1]-
            ~_ai[1] & ~_ri -> lo[1]+
        }
    }
    
    export
    defproc ARB_ng (globals g; bool li[2], lo[2], ri, ro) {
        // ARB_ng is the arbiter implemented on neurogrid and earlier chips.
        // Its filter circuit is not QDI. 
        // Specifically, assumes that a1i (a2i) changes before ri in l1o- (l2o-)
        // guards.
        bool _ai[2], _ao[2], ao[2], _ri;
    
        //Force Arbiter Behavior
        spec {
            mk_excllo(_ai[0],_ai[1])
        }
    
        //Implement fair and greedy algorithm
        prs<g.Vdd,g.GND> {
            //asymmetric c-elements
            li[0] & _ri -> _ao[0]-
            ~li[0]      -> _ao[0]+
            li[1] & _ri -> _ao[1]-
            ~li[1]      -> _ao[1]+
    
            // staticizers
            _ao[0] => ao[0]-
            _ao[1] => ao[1]-
    
            // parent lines
            ao[0] | ao[1] => ro+
            ri => _ri-
        }
    
        //Cross-Coupled NANDs
        prs<g.Vdd,g.GND> {
            ao[0] & _ai[1]   => _ai[0]-
            ao[1] &  _ai[0]  => _ai[1]-
        }
    
        //Filter
        prs<g.Vdd,g.GND> {
            _ai[0] | _ri   -> lo[0]-
            ~_ai[0] & ~_ri -> lo[0]+
            _ai[1] | _ri   -> lo[1]-
            ~_ai[1] & ~_ri -> lo[1]+
        }
    }
    
    export
    defproc LTH (globals g; bool li, lo, gi, go, rk) {
    }
    
    export
    defproc ADY (globals g; bool yi, yo, vi, vo, di, do) {
    }
    
    export
    defproc ADX (globals g; bool xi, xo, vi, vo, ci, co) {
    }
    
    export
    defproc SEQ (globals g; bool si, so, xi, xo, yi, yo, ti, to, di, do) {
    }
    namespace test {
        defproc dummy_LTH_INT(globals g; bool vi, vo, rk) {
            // utility for TEST_EVT
            prs {
                ~g.sReset & vi & ~rk -> vo+
                g.pReset | ~vi & rk  -> vo-
            }
        }

        export
        defproc TEST_EVT (globals g) {
            active_handshaker<1> neuron(g,,);
            dummy_LTH_INT lth_int(g,,,);
            EVT e(g,,,,,,);
            
            e.pi = neuron.o[0];
            e.po = neuron.i[0];
            e.ro = lth_int.vi;
            e.ri = lth_int.vo;
            e.co = lth_int.rk;
        }
    }
} // namespace transmitter
