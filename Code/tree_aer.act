// This file contains PRS for a feedfoward tree transmitter
import "lib/globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "test.act";

pint N=2;
namespace aer {
    namespace transmitter {
        /*
        defproc NODE_LEAF (globals g; bool di[2], do[2]; aMx1ofN<1,N> x) {
            // leaf node of transmitter tree
            // pipelined send, sequential reset X first
            bool a[2], xi;
            xi = x.a;
            ::arbiter::ARB arb(di, a);

            prs<g.Vdd, g.GND> {
                a[0] & ~do[1] & ~do[0] -> x.m[0].n[0]+
                g.pReset | do[0] -> x.m[0].n[0]-

                a[1] & ~do[0] & ~do[1] -> x.m[0].n[1]+
                g.pReset | do[1] -> x.m[0].n[1]-

                xi & a[0] & ~do[1] -> do[0]+
                ~xi & ~a[0] -> do[0]-

                xi & a[1] & ~do[0] -> do[1]+
                ~xi & ~a[1] -> do[1]-
            }
        }
        */

        defproc NODE_LEAF (bool di[2], do[2]; aMx1ofN<1,N> x) {
            // leaf node of transmitter tree
            // pipelined send, pipelined reset
            bool a[2], xi;
            xi = x.a;
            ::arbiter::ARB arb(di, a);

            prs {
                a[0] & ~do[1] => x.m[0].n[0]+

                a[1] & ~do[0] => x.m[0].n[1]+

                xi & a[0] & ~do[1] -> do[0]+
                ~xi -> do[0]-

                xi & a[1] & ~do[0] -> do[1]+
                ~xi -> do[1]-
            }
        }

        /*
        template <pint M>
        defproc NODE_INT (globals g; aMx1ofN<M,N> d[2]; aMx1ofN<M+1,N> x) {
            // interior node of transmitter tree
            // pipelined send, sequential reset X first
            bool a[2], do[2];
            bool xi = x.a; // for convenience
            ::arbiter::ARB arb(, a);
            VN<M,2> vn[2];

            do[0] = d[0].a;
            do[1] = d[1].a;
            vn[0].d = d[0].m;
            vn[1].d = d[1].m;
            arb.i[0] = vn[0].o;
            arb.i[1] = vn[1].o;

            prs<g.Vdd, g.GND> {
                a[0] & ~do[1] & ~do[0] -> x.m[0].n[0]+
                g.pReset | do[0] -> x.m[0].n[0]-

                a[1] & ~do[0] & ~do[1] -> x.m[0].n[1]+
                g.pReset | do[1] -> x.m[0].n[1]-

                (: m : M :
                    (a[0] & d[0].m[m].n[0] | a[1] & d[1].m[m].n[0]) &
                        ~do[1] & ~do[0] -> x.m[m+1].n[0]+
                    g.pReset | do[0] | do[1] -> x.m[m+1].n[0]-

                    (a[0] & d[0].m[m].n[1] | a[1] & d[1].m[m].n[1]) &
                        ~do[1] & ~do[0] -> x.m[m+1].n[1]+
                    g.pReset | do[0] | do[1] -> x.m[m+1].n[1]-
                )

                xi & a[0] & ~do[1] -> do[0]+
                ~xi & ~a[0] -> do[0]-

                xi & a[1] & ~do[0] -> do[1]+
                ~xi & ~a[1] -> do[1]-
            }
        }
        */

        template <pint M>
        defproc NODE_INT (globals g; aMx1ofN<M,N> d[2]; aMx1ofN<M+1,N> x) {
            // interior node of transmitter tree
            // pipelined send, pipelined reset
            bool a[2], do[2];
            bool xi = x.a; // for convenience
            do[0] = d[0].a; // for convenience
            do[1] = d[1].a; // for convenience

            ::arbiter::ARB arb(, a);

            VN<M,2> vn[2];
            vn[0].d = d[0].m;
            vn[1].d = d[1].m;

            arb.i[0] = vn[0].o;
            arb.i[1] = vn[1].o;

            prs<g.Vdd, g.GND> {
                a[0] & ~do[1] => x.m[0].n[0]+

                a[1] & ~do[0] => x.m[0].n[1]+

                (: m : M :
                    (a[0] & d[0].m[m].n[0] | a[1] & d[1].m[m].n[0])
                    & ~do[0] & ~do[1] -> x.m[m+1].n[0]+
                    g.pReset | (~a[0] & do[0] | ~a[1] & do[1])
                        -> x.m[m+1].n[0]-


                    (a[0] & d[0].m[m].n[1] | a[1] & d[1].m[m].n[1])
                        & ~do[0] & ~do[1] -> x.m[m+1].n[1]+
                    g.pReset | (~a[0] & do[0] | ~a[1] & do[1])
                        -> x.m[m+1].n[1]-
                )

                xi & a[0] & ~do[1] -> do[0]+
                ~xi -> do[0]-

                xi & a[1] & ~do[0] -> do[1]+
                ~xi -> do[1]-
            }
        }

        export
        template <pint M, NN; pbool root>
        defproc AEXT (globals g; bool si[NN], so[NN]; aMx1ofN<M,N> x) {
            // transmitter
            // M number of bits
            // NN number of neurons. NN=N^M
            bool xi = x.a; // for convenience

            [ M = 1 ->
                NN = N; // assert NN=N. checks for NN=N^M overall
                NODE_LEAF node_leaf(si, so, x);
            [] M > 1 ->
                AEXT<M-1, NN/2, false> aext[2];
                aext[0].g = g;
                aext[1].g = g;
                aext[0].si = si[0..NN/2-1];
                aext[1].si = si[NN/2..NN-1];
                aext[0].so = so[0..NN/2-1];
                aext[1].so = so[NN/2..NN-1];
                NODE_INT<M-1> node_int(g,, x);
                node_int.d[0] = aext[0].x;
                node_int.d[1] = aext[1].x;
            ]
        }

        namespace test {
            export
            template <pint M, NN>
            defproc TEST_AEXT (globals g) {
                active_handshaker<NN> s(g,,);
                AEXT<M, NN, true> aext(g,,,);
                VN<M, N> vn(,);
                aext.si = s.o;
                aext.so = s.i;
                aext.x.m = vn.d;
                aext.x.a = vn.o;
            }

            export
            template <pint M, NN>
            defproc TEST_AEXT1 (globals g) {
                active_handshaker<1> s(g,,);
                AEXT<M, NN, true> aext(g,,,);
                VN<M, N> vn(,);
                aext.si[0] = s.o[0];
                aext.so[0] = s.i[0];
                aext.x.m = vn.d;
                aext.x.a = vn.o;
                (; nn : 1..NN-1 :
                    aext.si[nn] = g.GND;
                )
            }
        } // namespace test
    } // namespace transmitter

    namespace receiver {
        defproc NODE_LEAF (bool xi[2], xo[2]; aMx1ofN<1,N> d) {
            bool do = d.a; // for convience
            d.m[0].n[0] = xo[0];
            d.m[0].n[1] = xo[1];

            prs {
                xi[0] | xi[1] => do+
            }
        }

        template <pint M>
        defproc NODE_INT (aMx1ofN<M, N> d; aMx1ofN<M-1, N> x[2]) {
            bool do = d.a; // for convience
            bool xi[2]; // for convienence
            xi[0] = x[0].a;
            xi[1] = x[1].a;
            prs {
                (: m : 1..M-1 :
                    d.m[0].n[0] & d.m[m].n[0] -> x[0].m[m-1].n[0]+
                    ~d.m[0].n[0] & ~d.m[m].n[0] -> x[0].m[m-1].n[0]-

                    d.m[0].n[0] & d.m[m].n[1] -> x[0].m[m-1].n[1]+
                    ~d.m[0].n[0] & ~d.m[m].n[1] -> x[0].m[m-1].n[1]-

                    d.m[0].n[1] & d.m[m].n[0] -> x[1].m[m-1].n[0]+
                    ~d.m[0].n[1] & ~d.m[m].n[0] -> x[1].m[m-1].n[0]-

                    d.m[0].n[1] & d.m[m].n[1] -> x[1].m[m-1].n[1]+
                    ~d.m[0].n[1] & ~d.m[m].n[1] -> x[1].m[m-1].n[1]-
                )

                xi[0] | xi[1] => do+
            }
        }

        export
        template <pint M, NN>
        defproc AERV (bool ri[NN], ro[NN]; aMx1ofN<M,N> d) {
            bool do = d.a; // for convience
            [ M = 1 ->
                NN = N; // assert NN=N. checks for NN=N^M overall
                NODE_LEAF node_leaf(ri, ro, d);
            [] M > 1 ->
                AERV<M-1, NN/2> aerv[2];
                NODE_INT<M> node_int(d,);
                aerv[0].ri = ri[0..NN/2-1];
                aerv[1].ri = ri[NN/2..NN-1];
                aerv[0].ro = ro[0..NN/2-1];
                aerv[1].ro = ro[NN/2..NN-1];
                node_int.x[0] = aerv[0].d;
                node_int.x[1] = aerv[1].d;
            ]
        }

        namespace test {
        } // namespace test
    } // namespace receiver

    export
    template <pint M, NN>
    defproc AER (globals g; bool si[NN], so[NN], ri[NN], ro[NN]) {
        transmitter::AEXT<M, NN, true> aext(g, si, so,);
        receiver::AERV<M, NN> aerv(ri, ro,);
        aext.x = aerv.d;
    }

    namespace test {
        export
        template <pint M, NN>
        defproc TEST_AER (globals g) {
            active_handshaker<NN> s(g,,);
            passive_handshaker<NN> r(,);
            AER<M, NN> aer(g, s.o, s.i, r.o, r.i);
        }

        export
        template <pint M, NN>
        defproc TEST_AER1 (globals g) {
            active_handshaker<1> s(g,,);
            passive_handshaker<1> r(,);
            AER<M, NN> aer(g,,,,);
            aer.si[0] = s.o[0];
            aer.so[0] = s.i[0];
            aer.ri[0] = r.o[0];
            aer.ro[0] = r.i[0];
            (; nn : 1..NN-1 :
                aer.si[nn] = g.GND;
                aer.ri[nn] = g.GND;
            )
        }
    } // namespace test
} // namespace aer

