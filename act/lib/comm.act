// Defines processes used in data communication
import "channel.act";
import "logic.act";

export
template <pint M, N>
defproc VN_aMx1ofN (globals g; aMx1ofN<M, N> d) {
    // detects data validity/neutrality on d
    // [V(d.m)];d.a+;[~V(d.m)];d.a-
    OR<N> or[M];
    (; m : M :
        or[m].g = g;
        (; n : N :
            or[m].i[n] = d.m[m].n[n];
        )
    )
    C_TREE<M> c_tree(g,,);
    (; k : M :
        or[k].o = c_tree.i[k];
    )
    c_tree.o = d.a;
}

export
template <pint N>
defproc VN_a1ofN (globals g; a1of<N> d) {
    // detects data validity/neutrality on d
    // [V(d.m)];d.a+;[~V(d.m)];d.a-
    OR<N> or(g, d.d, d.a);
}

export
template <pint M, N>
defproc _VN (globals g; c1of<N> _d[M]; bool _o) {
    // active low version of VN
    _OR<N> _or[M];
    (; m : M :
        _or[m].g = g;
        (; n : N :
            _or[m]._i[n] = _d[m].n[n];
        )
    )

    C_TREE<M> c_tree(g, ,_o);

    (; k : M :
        _or[k]._o = c_tree.i[k];
    )
}

export
template <pint N>
defproc VN_e1ofN (globals g; e1of<N> d) {
    // detects data validity/neutrality on d
    // d.e+;[V(d.m)];d.e-;[~V(d.m)]
    OR<N> or(g, d.d,);
    prs<g.Vdd, g.GND> {
        or.o => d.e-
    }
}

export
template <pint M, N>
defproc VN_eMx1ofN (globals g; eMx1ofN<M, N> d) {
    // detects data validity/neutrality on d
    // d.e+;[V(d.m)];d.e-;[~V(d.m)]
    OR<N> or[M];
    (; m : M :
        or[m].g = g;
        (; n : N :
            or[m].i[n] = d.m[m].n[n];
        )
    )

    [ M = 1 ->
        prs<g.Vdd, g.GND> {
            g._sReset<18> & or[0].o<18> -> d.e-
            ~g._sReset | ~or[0].o<18> -> d.e+
        }
    [] M > 1 ->
        C_TREE<M> c_tree(g,,);
        (; k : M :
            or[k].o = c_tree.i[k];
        )

        prs<g.Vdd, g.GND> {
            g._sReset<18> & c_tree.o<18> -> d.e-
            ~g._sReset | ~c_tree.o<18> -> d.e+
        }
    ]
}

template <pint M, N>
defproc Mx1ofN_WIRES (globals g; c1of<N> d[M]; bool o[M*N]) {
    // Connect a Mx1ofN channel to NN wires
    pint MN = M*N;
    (; n : N :
        d[0].n[n] = o[n];
    )
    [ M > 1 ->
        Mx1ofN_WIRES<M-1, N> w(g, d[1..M-1], o[N..MN-1]);
    ]
}

export
template <pint M, N, NN>
defproc N_DETECT (globals g; aMx1ofN<M, N> d) {
    // detects data neutrality on d
    bool x[NN];
    Mx1ofN_WIRES<M, N> wires(g, d.m, x);
    OR<NN> or(g, x, d.a);
}

export
template <pint M, N>
defproc A_TO_E (globals g; aMx1ofN<M, N> i; eMx1ofN<M, N> o) {
    // converts aMx1ofN to eMx1ofN
    // [o.e];i.a-;[I];O+;[~o.e];i.a+;[~I];O-
    prs<g.Vdd, g.GND> {
        (: m : M :
            (: n : N :
                i.m[m].n[n] => o.m[m].n[n]+ // wires. prs to test delays
            )
        )
        o.e => i.a-
    }
}

export
template <pint M_1of2, M_1of4>
defproc Mx1of2_to_Mx1of4 (globals g; c1of2 x[M_1of2]; c1of4 y[M_1of4]) {
    // converts an Mx1of2 channel to an Mx1of4 channel
    [ M_1of2 != (M_1of4*2) ->
        0 = 1; // assert false
    ]
    c1of4 _y[M_1of4];
    prs<g.Vdd, g.GND> {
        (: m4 : M_1of4 :
            x[m4*2].d[0]<10> & x[m4*2+1].d[0]<10> -> _y[m4].d[0]-
            ~x[m4*2].d[0]<20> & ~x[m4*2+1].d[0]<20> -> _y[m4].d[0]+

            x[m4*2].d[1]<10> & x[m4*2+1].d[0]<10> -> _y[m4].d[1]-
            ~x[m4*2].d[1]<20> & ~x[m4*2+1].d[0]<20> -> _y[m4].d[1]+

            x[m4*2].d[0]<10> & x[m4*2+1].d[1]<10> -> _y[m4].d[2]-
            ~x[m4*2].d[0]<20> & ~x[m4*2+1].d[1]<20> -> _y[m4].d[2]+

            x[m4*2].d[1]<10> & x[m4*2+1].d[1]<10> -> _y[m4].d[3]-
            ~x[m4*2].d[1]<20> & ~x[m4*2+1].d[1]<20> -> _y[m4].d[3]+
        )
        (: m4 : M_1of4 :
            (: n : 4 :
                ~_y[m4].d[n]<12> -> y[m4].d[n]+
                _y[m4].d[n]<9> -> y[m4].d[n]-
            )
        )
    }
}

export
template <pint M_1of2, M_1of4>
defproc eMx1of2_to_eMx1of4 (globals g; eMx1of2<M_1of2> x; eMx1of4<M_1of4> y) {
    // converts an eMx1of2 channel to an eMx1of4 channel
    Mx1of2_to_Mx1of4<M_1of2, M_1of4> _(g,,);
    _.x = x.m;
    _.y = y.m;
    x.e = y.e;
}
