// Defines N input logic gates
import "globals.act";
import "channel.act";
import "logic.h"; // forward declare functions

export
template <pint N>
defproc AND (globals g; bool i[N], o) {
    // Logical AND implemented with as few transistors as possible
    // Implemented as an AND tree with 2 and 3 input NANDs and 2 input NORs
    // We don't use 3 input NORs because the pullup chain would be too slow
    [ N = 1 ->
        0 = 1; // assert false, cosim's netgen cannot handly empty subcircuits
    [] N = 2 ->
        bool _x01;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] => _x01-
            _x01 => o-
        }
    [] N = 3 ->
        bool _x012;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            _x012 => o-
        }
    [] N = 4 ->
        bool _x012, _x3;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] => _x3-
            _x012 | _x3 => o-
        }
    [] N = 5 ->
        bool _x012, _x34;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] => _x34-
            _x012 | _x34 => o-
        }
    [] N = 6 ->
        bool _x012, _x345;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            _x012 | _x345 => o-
        }
    [] N = 7 ->
        bool _x012, _x345, _x6;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            i[6] => _x6-
            _x012 | _x345 | _x6  => o-
        }
    [] N = 8 ->
        bool _x012, _x345, _x67;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            i[6] & i[7] => _x67-
            _x012 | _x345 | _x67  => o-
        }
    [] N = 9 ->
        bool _x012, _x345, _x678;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            i[6] & i[7] & i[8] => _x678-
            _x012 | _x345 | _x678  => o-
        }
    [] N > 9 ->
        [ N < 18 ->
            AND<9> and9(g,, o);
            AND<N-8> andr(g, i[8..N-1],);
            (; n : 8 :
                and9.i[n] = i[n];
            )
            and9.i[8] = andr.o;
        [] N >= 18 ->
            pint k = N/9;
            AND<k> and07[8];
            (; n : 8 :
                and07[n].g = g;
                and07[n].i = i[n*k..(n+1)*k-1];
            )
            AND<N-8*k> and8(g, i[8*k..N-1],);
            AND<9> and9(g,, o);
            (; n : 8 :
                and07[n].g = g;
                and07[n].o = and9.i[n];
            )
            and8.o = and9.i[8];
        ]
    ]
}

export
template <pint N>
defproc _AND (globals g; bool _i[N], _o) {
    // active low version of AND
    OR<N> _(g, _i, _o);
}

export
template <pint N>
defproc AND_LINE (globals g; bool i[N], o) {
    // Logical AND implemented as a line of AND gates
    // Implemented with 2 input NANDs
    [ N = 1 ->
        i[0] = o;
    [] N >= 2 ->
        AND_LINE<N-1> and(g, i[0..N-2],);
        bool _o;
        prs<g.Vdd, g.GND> {
            and.o & i[N-1] => _o-
            _o => o-
        }
    ]
}

export
template <pint N>
defproc OR (globals g; bool i[N], o) {
    // Logical OR implemented with as few transistors as possible
    // Implemented as an OR tree with 3 input NANDs and NORs
    [ N = 1 ->
        0 = 1; // assert false, cosim's netgen cannot handly empty subcircuits
    [] N = 2 ->
        bool _x01;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] => _x01-
                _x01 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> -> _x01-
                ~i[0]<3*6> & ~i[1]<3*6> -> _x01+
                _x01<6> -> o-
                ~_x01<1.5*6> -> o+
            }
        ]
    [] N = 3 ->
        bool _x012;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                _x012 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> | i[2]<6> -> _x012-
                ~i[0]<5*6> & ~i[1]<5*6> & ~i[2]<5*6> -> _x012+
                _x012<6> -> o-
                ~_x012<1.5*6> -> o+
            }
        ]
    [] N = 4 ->
        bool _x012, _x3;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] => _x3-
                _x012 & _x3 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> | i[2]<6> -> _x012-
                ~i[0]<5*6> & ~i[1]<5*6> & ~i[2]<5*6> -> _x012+
                i[3]<6> -> _x3-
                ~i[3]<1.5*6> -> _x3+
                _x012<2*6> & _x3<2*6> -> o-
                ~_x012<2*6> | ~_x3<2*6> -> o+
            }
        ]
    [] N = 5 ->
        bool _x012, _x34;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] => _x34-
                _x012 & _x34 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> | i[2]<6> -> _x012-
                ~i[0]<5*6> & ~i[1]<5*6> & ~i[2]<5*6> -> _x012+
                i[3]<6> | i[4]<6> -> _x34-
                ~i[3]<3*6> & ~i[4]<3*6> -> _x34+
                _x012<2*6> & _x34<2*6> -> o-
                ~_x012<1.5*6> | ~_x34<1.5*6> -> o+
            }
        ]
    [] N = 6 ->
        bool _x012, _x345;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                _x012 & _x345 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> | i[2]<6> -> _x012-
                ~i[0]<5*6> & ~i[1]<5*6> & ~i[2]<5*6> -> _x012+
                i[3]<6> | i[4]<6> | i[5]<6> -> _x345-
                ~i[3]<5*6> & ~i[4]<5*6> & ~i[5]<5*6> -> _x345+
                _x012<2*6> & _x345<2*6> -> o-
                ~_x012<1.5*6> | ~_x345<1.5*6> -> o+
            }
        ]
    [] N = 7 ->
        bool _x012, _x345, _x6;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                i[6] => _x6-
                _x012 & _x345 & _x6 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> | i[2]<6> -> _x012-
                ~i[0]<5*6> & ~i[1]<5*6> & ~i[2]<5*6> -> _x012+
                i[3]<6> | i[4]<6> | i[5]<6> -> _x345-
                ~i[3]<5*6> & ~i[4]<5*6> & ~i[5]<5*6> -> _x345+
                i[6]<6> -> _x6-
                ~i[6]<1.5*6> -> _x6+
                _x012<3*6> & _x345<3*6> & _x6<3*6> -> o-
                ~_x012<1.5*6> | ~_x345<1.5*6> | ~_x6<1.5*6> -> o+
            }
        ]
    [] N = 8 ->
        bool _x012, _x345, _x67;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                i[6] | i[7] => _x67-
                _x012 & _x345 & _x67 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> | i[2]<6> -> _x012-
                ~i[0]<5*6> & ~i[1]<5*6> & ~i[2]<5*6> -> _x012+
                i[3]<6> | i[4]<6> | i[5]<6> -> _x345-
                ~i[3]<5*6> & ~i[4]<5*6> & ~i[5]<5*6> -> _x345+
                i[6]<6> | i[7]<6> -> _x67-
                ~i[6]<3*6> & ~i[7]<3*6> -> _x67+
                _x012<3*6> & _x345<3*6> & _x67<3*6> -> o-
                ~_x012<1.5*6> | ~_x345<1.5*6> | ~_x67<1.5*6> -> o+
            }
        ]
    [] N = 9 ->
        bool _x012, _x345, _x678;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                i[6] | i[7] | i[8] => _x678-
                _x012 & _x345 & _x678 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<6> | i[1]<6> | i[2]<6> -> _x012-
                ~i[0]<5*6> & ~i[1]<5*6> & ~i[2]<5*6> -> _x012+
                i[3]<6> | i[4]<6> | i[5]<6> -> _x345-
                ~i[3]<5*6> & ~i[4]<5*6> & ~i[5]<5*6> -> _x345+
                i[6]<6> | i[7]<6> | i[8]<6> -> _x678-
                ~i[6]<5*6> & ~i[7]<5*6> & ~i[8]<5*6> -> _x678+
                _x012<3*6> & _x345<3*6> & _x678<3*6> -> o-
                ~_x012<1.5*6> | ~_x345<1.5*6> | ~_x678<1.5*6> -> o+
            }
        ]
    [] N > 9 ->
        [ N < 18 ->
            OR<9> or9(g,, o);
            OR<N-8> orr(g, i[8..N-1],);
            (; n : 8 :
                or9.i[n] = i[n];
            )
            or9.i[8] = orr.o;
        [] N >= 18 ->
            pint k = N/9;
            OR<k> or07[8];
            (; n : 8 :
                or07[n].g = g;
                or07[n].i = i[n*k..(n+1)*k-1];
            )
            OR<N-8*k> or8(g, i[8*k..N-1],);
            OR<9> or9(g,, o);
            (; n : 8 :
                or07[n].g = g;
                or07[n].o = or9.i[n];
            )
            or8.o = or9.i[8];
        ]
    ]
}

export
template <pint N>
defproc _OR (globals g; bool _i[N], _o) {
    // active low version of OR
    AND<N> _(g, _i, _o);
}

export
template <pint N>
defproc OR_LINE (globals g; bool i[N], o) {
    // Logical OR implemented as line of OR gates
    // Implemented with 2 input NORs
    [ N = 1 ->
        i[0] = o;
    [] N >= 2 ->
        OR_LINE<N-1> or(g, i[0..N-2],);
        bool _o;
        prs<g.Vdd, g.GND> {
            or.o | i[N-1] => _o-
            _o => o-
        }
    ]
}

defproc NOR (globals g; bool i[2], o) {
    // Logical NOR
    prs<g.Vdd, g.GND> {
        i[0] | i[1] => o-
    }
}

export
template <pint N>
defproc C_TREE (globals g; bool i[N], o) {
    [ N = 1 ->
        0 = 1; // assert false, cosim's netgen cannot handly empty subcircuits
    [] N = 2 -> 
        bool _o;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] -> _o-
            ~i[0] & ~i[1] -> _o+
            _o => o-
        }
    [] N > 2 ->
        [ N < 4 ->
            C_TREE<N-N/2> c_tree1(g, i[N/2..N-1],);
            C_TREE<2> c_tree2(g,, o);
            c_tree2.i[0] = i[0];
            c_tree2.i[1] = c_tree1.o;
        [] N >= 4 ->
            C_TREE<N/2> c_tree0(g, i[0..N/2-1],);
            C_TREE<N-N/2> c_tree1(g, i[N/2..N-1],);
            C_TREE<2> c_tree2(g,, o);
            c_tree2.i[0] = c_tree0.o;
            c_tree2.i[1] = c_tree1.o;
        ]
    ]
}
