// Defines N input logic gates
import "globals.act";
import "channel.act";
import "logic.h"; // forward declare functions

export
template <pint N | pint width>
defproc AND (globals g; bool i[N], o) {
    // Logical AND implemented with as few transistors as possible
    // Implemented as an AND tree with 2 and 3 input NANDs and 2 input NORs
    // We don't use 3 input NORs because the pullup chain would be too slow
    [ N=1 ->
        i[0] = o;
    [] N=2 ->
        bool _x01;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] => _x01-
            _x01 => o-
        }
    [] N=3 ->
        bool _x012;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            _x012 => o-
        }
    [] N=4 ->
        bool _x012, _x3;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] => _x3-
            _x012 | _x3 => o-
        }
    [] N=5 ->
        bool _x012, _x34;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] => _x34-
            _x012 | _x34 => o-
        }
    [] N=6 ->
        bool _x012, _x345;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            _x012 | _x345 => o-
        }
    [] N=7 ->
        bool _x012, _x345, _x6;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            i[6] => _x6-
            _x012 | _x345 | _x6  => o-
        }
    [] N=8 ->
        bool _x012, _x345, _x67;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            i[6] & i[7] => _x67-
            _x012 | _x345 | _x67  => o-
        }
    [] N>=9 ->
        pint k=N/9;
        AND<k, width>     and0(g, i[0..k-1],);
        AND<k, width>     and1(g, i[k..2*k-1],);
        AND<k, width>     and2(g, i[2*k..3*k-1],);
        AND<k, width>     and3(g, i[3*k..4*k-1],);
        AND<k, width>     and4(g, i[4*k..5*k-1],);
        AND<k, width>     and5(g, i[5*k..6*k-1],);
        AND<k, width>     and6(g, i[6*k..7*k-1],);
        AND<k, width>     and7(g, i[7*k..8*k-1],);
        AND<N-8*k, width> and8(g, i[8*k..N-1],);
        bool _x012, _x345, _x678;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] & i[2] => _x012-
            i[3] & i[4] & i[5] => _x345-
            i[6] & i[7] & i[8] => _x678-
            _x012 | _x345 | _x678  => o-
        }
    ]
}

export
template <pint N, width>
defproc _AND (globals g; bool _i[N], _o) {
    // active low version of AND
    OR<N, width> _(g, _i, _o);
}

export
template <pint N, width>
defproc AND_LINE (globals g; bool i[N], o) {
    // Logical AND implemented as a line of AND gates
    // Implemented with 2 input NANDs
    [ N = 1 ->
        i[0] = o;
    [] N >= 2 ->
        AND_LINE<N-1> and(g, i[0..N-2],);
        bool _o;
        prs<g.Vdd, g.GND> {
            and.o & i[N-1] => _o-
            _o => o-
        }
    ]
}

export
template <pint N | pint width>
defproc OR (globals g; bool i[N], o) {
    // Logical OR implemented with as few transistors as possible
    // Implemented as an OR tree with 3 input NANDs and NORs
    [ N=1 ->
        i[0] = o;
            bool dummy;
            prs {
              g.pReset => dummy-
            }
    [] N=2 ->
        bool _x01;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] => _x01-
                _x01 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> -> _x01-
                ~i[0]<3*width> & ~i[1]<3*width> -> _x01+
                _x01<width> -> o-
                ~_x01<1.5*width> -> o+
            }
        ]
    [] N=3 ->
        bool _x012;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                _x012 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> | i[2]<width> -> _x012-
                ~i[0]<5*width> & ~i[1]<5*width> & ~i[2]<5*width> -> _x012+
                _x012<width> -> o-
                ~_x012<1.5*width> -> o+
            }
        ]
    [] N=4 ->
        bool _x012, _x3;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] => _x3-
                _x012 & _x3 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> | i[2]<width> -> _x012-
                ~i[0]<5*width> & ~i[1]<5*width> & ~i[1]<5*width> -> _x012+
                i[3]<width> -> _x3-
                ~i[3]<1.5*width> -> _x3+
                _x012<2*width> & _x3<2*width> -> o-
                ~_x012<1.5*width> | ~_x3<1.5*width> -> o+
            }
        ]
    [] N=5 ->
        bool _x012, _x34;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] => _x34-
                _x012 & _x34 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> | i[2]<width> -> _x012-
                ~i[0]<5*width> & ~i[1]<5*width> & ~i[2]<5*width> -> _x012+
                i[3]<width> | i[4]<width> -> _x34-
                ~i[3]<3*width> & ~i[4]<3*width> -> _x34+
                _x012<2*width> & _x34<2*width> -> o-
                ~_x012<1.5*width> | ~_x34<1.5*width> -> o+
            }
        ]
    [] N=6 ->
        bool _x012, _x345;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                _x012 & _x345 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> | i[2]<width> -> _x012-
                ~i[0]<5*width> & ~i[1]<5*width> & ~i[2]<5*width> -> _x012+
                i[3]<width> | i[4]<width> | i[5]<width> -> _x345-
                ~i[3]<5*width> & ~i[4]<5*width> & ~i[5]<5*width> -> _x345+
                _x012<2*width> & _x345<2*width> -> o-
                ~_x012<1.5*width> | ~_x345<1.5*width> -> o+
            }
        ]
    [] N=7 ->
        bool _x012, _x345, _x6;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                i[6] => _x6-
                _x012 & _x345 & _x6 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> | i[2]<width> -> _x012-
                ~i[0]<5*width> & ~i[1]<5*width> & ~i[2]<5*width> -> _x012+
                i[3]<width> | i[4]<width> | i[5]<width> -> _x345-
                ~i[3]<5*width> & ~i[4]<5*width> & ~i[5]<5*width> -> _x345+
                i[6]<width> -> _x6-
                ~i[6]<1.5*width> -> _x6+
                _x012<3*width> & _x345<3*width> & _x6<3*width> -> o-
                ~_x012<1.5*width> | ~_x345<1.5*width> | ~_x6<1.5*width> -> o+
            }
        ]
    [] N=8 ->
        bool _x012, _x345, _x67;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                i[6] | i[7] => _x67-
                _x012 & _x345 & _x67 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> | i[2]<width> -> _x012-
                ~i[0]<5*width> & ~i[1]<5*width> & ~i[2]<5*width> -> _x012+
                i[3]<width> | i[4]<width> | i[5]<width> -> _x345-
                ~i[3]<5*width> & ~i[4]<5*width> & ~i[5]<5*width> -> _x345+
                i[6]<width> | i[7]<width> -> _x67-
                ~i[6]<3*width> & ~i[7]<3*width> -> _x67+
                _x012<3*width> & _x345<3*width> & _x67<3*width> -> o-
                ~_x012<1.5*width> | ~_x345<1.5*width> | ~_x67<1.5*width> -> o+
            }
        ]
    [] N>=9 ->
        pint k=N/9;
        OR<k, width>     or0(g, i[0..k-1],);
        OR<k, width>     or1(g, i[k..2*k-1],);
        OR<k, width>     or2(g, i[2*k..3*k-1],);
        OR<k, width>     or3(g, i[3*k..4*k-1],);
        OR<k, width>     or4(g, i[4*k..5*k-1],);
        OR<k, width>     or5(g, i[5*k..6*k-1],);
        OR<k, width>     or6(g, i[6*k..7*k-1],);
        OR<k, width>     or7(g, i[7*k..8*k-1],);
        OR<N-8*k, width> or8(g, i[8*k..N-1],);
        bool _x012, _x345, _x678;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0] | i[1] | i[2] => _x012-
                i[3] | i[4] | i[5] => _x345-
                i[6] | i[7] | i[8] => _x678-
                _x012 & _x345 & _x678 => o-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND> {
                i[0]<width> | i[1]<width> | i[2]<width> -> _x012-
                ~i[0]<5*width> & ~i[1]<5*width> & ~i[2]<5*width> -> _x012+
                i[3]<width> | i[4]<width> | i[5]<width> -> _x345-
                ~i[3]<5*width> & ~i[4]<5*width> & ~i[5]<5*width> -> _x345+
                i[6]<width> | i[7]<width> | i[8]<width> -> _x678-
                ~i[6]<5*width> & ~i[7]<5*width> & ~i[8]<5*width> -> _x678+
                _x012<3*width> & _x345<3*width> & _x678<3*width> -> o-
                ~_x012<1.5*width> | ~_x345<1.5*width> | ~_x678<1.5*width> -> o+
            }
        ]
    ]
}

export
template <pint N, width>
defproc _OR (globals g; bool _i[N], _o) {
    // active low version of OR
    AND<N> _(g, _i, _o);
}

export
template <pint N, width>
defproc OR_LINE (globals g; bool i[N], o) {
    // Logical OR implemented as line of OR gates
    // Implemented with 2 input NORs
    [ N = 1 ->
        i[0] = o;
    [] N >= 2 ->
        OR_LINE<N-1> or(g, i[0..N-2],);
        bool _o;
        prs<g.Vdd, g.GND> {
            or.o | i[N-1] => _o-
            _o => o-
        }
    ]
}

defproc NOR (globals g; bool i[2], o) {
    // Logical NOR
    prs<g.Vdd, g.GND> {
        i[0] | i[1] => o-
    }
}

export
template <pint N | pint width>
defproc C_TREE (globals g; bool i[N], o) {
    [ N=1 ->
        i[0] = o;
        bool dummy;
        prs {g.pReset => dummy-}
    [] N=2 -> 
        bool _o;
        prs<g.Vdd, g.GND> {
            i[0] & i[1] -> _o-
            ~i[0] & ~i[1] -> _o+
            _o => o-
        }
    [] N>2 ->
        C_TREE<N/2> c_tree0(g, i[0..N/2-1],);
        C_TREE<N-N/2> c_tree1(g, i[N/2..N-1],);
        bool _o;
        prs<g.Vdd, g.GND> {
            c_tree0.o & c_tree1.o -> _o-
            ~c_tree0.o & ~c_tree1.o -> _o+
            _o => o-
        }
    ]
}
