// This file is the unbubble-reshuffled version of arbiter.act for reference
import "lib/globals.act";
import "channel.act";
import "test.act";

namespace arbiter {
    export
    defproc ARB (bool ai[2], ao[2]) {
        // The basic 2-input arbiter
        bool _a[2];
    
        spec {
            mk_excllo(_a[0], _a[1])
        }
    
        //Cross-Coupled NANDs
        prs {
            ai[0] & _a[1]  => _a[0]-
            ai[1] & _a[0]  => _a[1]-
        }
    
        //Filter
        prs {
            ~_a[0] & _a[1] -> ao[0]+
            _a[0]          -> ao[0]-
    
            ~_a[1] & _a[0] -> ao[1]+
            _a[1]          -> ao[1]-
        }
    }

    defproc CTRL (globals g; bool ci[2], s0i, s0o, s1i, s1o, pi, po) {
        // sequences between children and parent communications
        bool x, y;
        prs<g.Vdd,g.GND> {
            g._sReset & (ci[0] | ci[1]) & y -> po+
            g.pReset | ~s1i & x & ~y -> po-
    
            g._sReset & ~x & y -> s0o+
            g.pReset | x | ~y  -> s0o-
    
            g._sReset & ~s0i & ~x & ~y -> s1o+
            g.pReset | x -> s1o-
    
            g.pReset | s1i & ~y -> x+
            g._sReset & pi & y -> x-
    
            ~pi -> y+
            s0i -> y-
        }
    }
    export
    defproc C_ARB (bool si, so, ci, co) {
        // controlled arbiter cell for use with CTRL
        // arbitrates between child request and CTRL request
        bool cso, sso;
        bool ci_hat, si_hat;
        ARB arb(,);
        arb.ai[0] = ci;
        arb.ai[1] = si;
        arb.ao[0] = ci_hat;
        arb.ao[1] = si_hat;
    
        prs {
            ci_hat & si & ~sso -> cso+
            ~ci_hat -> cso-
    
            ~si & cso -> co+
            si | ~cso -> co-
    
            si_hat & ~co -> sso+
            ~si_hat | co -> sso-
    
            cso | sso => so+
        }
    }

    defproc H_ARB (globals g; bool ci[2], co[2], pi, po) {
        // heirarchical arbiter cell
        // can be arranged in a binary tree to service more than 2 children
        CTRL ctrl(g, ci,,,,, pi, po);
        C_ARB c1_arb(,, ci[0], co[0]), c2_arb(,, ci[1], co[1]);

        ctrl.s0o = c1_arb.si;
        ctrl.s0i = c1_arb.so;
        ctrl.s1o = c2_arb.si;
        ctrl.s1i = c2_arb.so;
    }
    
    template <pint N>
    defproc _N_ARB (globals g; bool ci[N], co[N], pi, po);
    // N-way arbiter used in recursive definition of N_ARB

    export
    template <pint N>
    defproc N_ARB (globals g; bool ci[N], co[N]) {
        // N-way arbiter
        _N_ARB<N> n_arb(g, ci, co,,);
        prs<g.Vdd,g.GND> {
            n_arb.po => n_arb.pi+
        }
    }

    template <pint N>
    defproc _N_ARB (globals g; bool ci[N], co[N], pi, po) {
        // N-way arbiter used in recursive definition of N_ARB
        [ N=1 ->
            ci[0] = po;
            co[0] = pi;
        [] N=2 ->
            H_ARB h_arb(g, ci, co, pi, po);
        [] N>2 ->
            H_ARB h_arb(g,,, pi, po);
            _N_ARB<N/2> n_arb1(g, ci[0..N/2-1], co[0..N/2-1],,);
            _N_ARB<N-N/2> n_arb2(g, ci[N/2..N-1], co[N/2..N-1],,);
            n_arb1.po = h_arb.ci[0];
            n_arb1.pi = h_arb.co[0];
            n_arb2.po = h_arb.ci[1];
            n_arb2.pi = h_arb.co[1];
        ]
    }

    template <pint N>
    defproc N_ARB_C_ (globals g; bool i[N], o[N], pi, po) {
        // utility for N_ARB_C
        [ N = 1 ->
            i[0] = po;
            o[0] = pi;
        [] N > 1 ->
            N_ARB_C_<N/2> n_arb0(g, i[0..N/2-1], o[0..N/2-1],,);
            N_ARB_C_<N-N/2> n_arb1(g, i[N/2..N-1], o[N/2..N-1],,);
    
            bool ai[2], ao[2];
            ai[0] = n_arb0.po;
            ai[1] = n_arb1.po;
            ao[0] = n_arb0.pi;
            ao[1] = n_arb1.pi;
            bool a[2];
            ::arbiter::ARB arb(ai, a);
    
            prs <g.Vdd,g.GND> {
                a[0] & ~ao[1] | a[1] & ~ao[0] -> po+
                g.pReset | ~a[0] & ao[0] | ~a[1] & ao[1] -> po-
    
                pi & a[0] & ~ao[1] -> ao[0]+
                ~pi -> ao[0]-
    
                pi & a[1] & ~ao[0] -> ao[1]+
                ~pi -> ao[1]-
            }
        ]
    }
    
    export
    template <pint N>
    defproc N_ARB_C (globals g; bool i[N], o[N]) {
        // cheap N-way arbiter
        N_ARB_C_<N> _(g, i, o,,);
        prs {
            _.po => _.pi+
        }
    }

    namespace test {
        export
        defproc TEST_ARB (globals g) {
            // tests ARB
            active_handshaker<2> c(g,,);
            ARB arb(,);
            
            c.o = arb.ai;
            c.i = arb.ao;
        }

        export
        template<pint N>
        defproc TEST_N_ARB (globals g) {
            // tests N_ARB
            N_ARB<N> n_arb(g,,);
            active_handshaker<N> c(g,,);
            c.o = n_arb.ci;
            c.i = n_arb.co;
        }

        export
        template <pint N>
        defproc TEST_N_ARB_C (globals g) {
            //tests N_ARB_C
            active_handshaker<N> c(g,,);
            N_ARB_C<N> n_arb(g, c.o, c.i);
        }
    }
}
