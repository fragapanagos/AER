// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";
import "environment.act";

namespace aer {
    namespace interface {
        export
        template <pint N>
        defproc OUT_e1ofN (globals g; bool xi, xo; c1of<N> x; e1of<N> y) {
            // convert AEXT/AERV serial protocol to standard e1ofN channel
            x.d = y.d;
            prs {
                xi & y.e => xo+
            }
        }

        export
        template <pint N>
        defproc OUT_a1ofN (globals g; bool xi, xo; c1of<N> x; a1of<N> y) {
            // convert AEXT/AERV serial protocol to standard a1ofN channel
            x.d = y.d;
            prs {
                xi & ~y.a => xo+
            }
        }

        namespace deserial_ring {
            export
            template <pint M, N>
            defproc SPLIT (globals g; a1of<N> x, y[M]) {
                (; m : M :
                    y[m].d = x.d;
                )
                OR<M> or(g,, x.a);
                (; m : M :
                    y[m].a = or.i[m];
                )
            }
            
            export
            template <pint N>
            defproc NODE (globals g; a1of<N> x; c1of<N> y; bool si, so) {
                bool vy, s;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~s & si & x.d[n] -> y.d[n]+
                        ~si -> y.d[n]-
                    )
            
                    ~so & vy => x.a+
            
                    vy & (& : n : N : ~x.d[n]) -> s+
                    g.pReset | ~vy -> s-
            
                    s => so+

                    (| : n : N : y.d[n]) => vy+
                }
            }
        } // namespace deserial_ring
        
        export
        template <pint M, N>
        defproc DESERIAL_RING (globals g; a1of<N> x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with ring
            deserial_ring::SPLIT<M, N> split(g, x,);
            deserial_ring::NODE<N> node[M];
            (; m : M :
                node[m].g = g;
                node[m].x = split.y[m];
                node[m].y = y.m[m];
            )
            (; m : M-1 :
                node[m].so = node[m+1].si;
            )
            prs<g.Vdd, g.GND> {
                ~g.sReset & ~node[M-1].so & y.e  -> node[0].si+
                g.sReset | node[M-1].so & ~y.e  -> node[0].si-
            }
        }

        namespace deserial_chain {
            export
            template <pint N>
            defproc HEAD (globals g; a1of<N> x; c1of<N> d; bool si, so) {
                // deserializer chain head link
                // parallel output word 0
                bool vd;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        si & x.d[n] -> d.d[n]+
                        ~g._pReset | ~si -> d.d[n]-
                    )
            
                    (& : n : N : ~x.d[n]) & vd => so+
            
                    ~so & vd => x.a+
            
                    (| : n : N : d.d[n]) => vd+
                }
            }
            
            export
            template <pint N>
            defproc NODE (globals g; a1of<N> x, y; c1of<N> d; bool si, so) {
                // deserializer chain intermediate link
                // parallel output words 1 to M-2
                bool vd;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~si & x.d[n] => y.d[n]+
                
                        si & x.d[n] -> d.d[n]+
                        ~si -> d.d[n]-
                    )
                
                    (& : n : N : ~x.d[n]) & vd => so+
                
                    y.a | ~so & vd => x.a+
            
                    (| : n : N : d.d[n]) => vd+
                }
            }

            export
            template <pint N>
            defproc TAIL (globals g; a1of<N> x, y; c1of<N> d; bool si) {
                // deserializer chain tail link
                // parallel output word M-1
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~si & x.d[n] & ~d.d[n] => y.d[n]+
            
                        si & x.d[n] -> d.d[n]+
                        ~si & ~x.d[n] -> d.d[n]-
                    )
            
                    y.a | (| : n : N : d.d[n]) => x.a+
                }
            }
        } // namespace deserial_chain

        export
        template <pint M, N>
        defproc DESERIAL_CHAIN (globals g; a1of<N> x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with chain
            [ M = 1 ->
                (; n : N :
                    x.d[n] = y.m[0].n[n];
                )
                prs <g.Vdd, g.GND> {
                    y.e => x.a-
                }
            [] M > 1 ->
                deserial_chain::HEAD<N> head(g,, y.m[0], y.e,);
                deserial_chain::TAIL<N> tail(g, x,, y.m[M-1],);
            ]

            [ M = 2 ->
                head.x = tail.y;
                head.so = tail.si;
            [] M > 2 ->
                pint MN = M-2;
                deserial_chain::NODE<N> node[MN];
                (; mn : MN :
                    node[mn].g = g;
                    node[mn].d = y.m[mn+1];
                )
                head.x = node[0].y;
                head.so = node[0].si;
                tail.y = node[MN-1].x;
                tail.si = node[MN-1].so;
                (; mn : MN-1 :
                    node[mn].x = node[mn+1].y;
                    node[mn].so = node[mn+1].si;
                )
            ]
        }

        namespace serial_chain {
            export
            template <pint N>
            defproc NODE (globals g; e1of<N> x, y; c1of<N> d) {
                bool u, vy, vd;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        y.e & ~u & d.d[n] | x.d[n] -> y.d[n]+
                        g.pReset | ~y.e & u & ~x.d[n] -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) => vy+

                    (| : n : N : d.d[n]) => vd+

                    vy & vd -> u+
                    g.pReset | ~vy & ~vd -> u-

                    y.e & u & ~vy -> x.e+
                    ~y.e & (~u | vy) -> x.e-
                }
            }

            export
            template <pint N>
            defproc TAIL (globals g; bool xe; e1of<N> y; c1of<N> d) {
                bool u, vy, vd;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        y.e & ~u & d.d[n] -> y.d[n]+
                        g.pReset | ~y.e & u -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) => vy+

                    (| : n : N : d.d[n]) => vd+

                    vy & vd -> u+
                    g.pReset | ~vy & ~vd -> u-

                    y.e & u & ~vy -> xe+
                    ~y.e & ~u -> xe-
                }
            }
        } // namespace serial_chain

        export
        template <pint M, N>
        defproc SERIAL_CHAIN (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with chain
            [ M = 1 ->
                serial_chain::TAIL<N> tail(g,,, x.m[0]);
                tail.y.m = y;
                tail.y.e = yi;
            [] M > 1 ->
                pint MM = M-1;
                serial_chain::NODE<N> node[MM];
                serial_chain::TAIL<N> tail(g,, node[MM-1].x, x.m[M-1]);
                (; m : MM :
                    node[m].g = g;
                    node[m].d = x.m[m];
                )
                (; m : MM-1 :
                    node[m].x = node[m+1].y;
                )
                node[0].y.m = y;
                node[0].y.e = yi;
            ]
            bool s;
            s = yo;
            s = x.e;
            prs<g.Vdd, g.GND> {
                g.pReset | tail.xe & yi -> s-
                ~g.sReset & ~tail.xe & ~yi -> s+
            }
        }

        namespace serial_ring {
            export
            template <pint N>
            defproc NODE (globals g; c1of<N> x; e1of<N> y; bool si, so) {
                bool u;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~u & y.e & si & x.d[n] -> y.d[n]+
                        g.pReset | u & ~y.e -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) & ~y.e -> u+
                    ~si & (& : n : N : ~x.d[n]) -> u-

                    u & (& : n : N : ~y.d[n]) -> so+
                    ~u | (| : n : N : y.d[n]) -> so-
                }
            }

            export
            template <pint M, N>
            defproc MERGE (globals g; e1of<N> x[M], y) {
                OR<M> or[N];
                (; n : N :
                    or[n].g = g;
                    or[n].o = y.d[n];
                    (; m : M :
                        or[n].i[m] = x[m].d[n];
                    )
                )
                (; m : M :
                    x[m].e = y.e;
                )
            }
        } // namespace serial_ring

        export
        template <pint M, N>
        defproc SERIAL_RING (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            serial_ring::NODE<N> node[M];
            serial_ring::MERGE<M, N> merge(g,,);
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[m];
                node[m].y = merge.x[m];
            )
            merge.y.m = y;
            merge.y.e = yi;
            (; m : M-1:
                node[m].so = node[m+1].si;
            )
            bool s; 
            x.e = s;
            yo = s;
            node[0].si = s;
            prs<g.Vdd, g.GND> {
                g.pReset | node[M-1].so & yi -> s-
                ~g.sReset & ~node[M-1].so & ~yi -> s+
            }
        }

        namespace serial_ring2 {
            export
            template <pint N>
            defproc NODE (globals g; c1of<N> x; av1of<N> y; bool si, so) {
                bool u;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        si & x.d[n] & u -> y.d[n]+
                        ~si | ~x.d[n] | ~u -> y.d[n]-
                    )
                    si & (| : n : N : x.d[n]) & u -> y.v+
                    ~si | (& : n : N : ~x.d[n]) | ~u -> y.v-

                    ~si & (& : n : N : ~x.d[n]) -> u+
                    y.a -> u-

                    ~u & ~y.a -> so+
                    u | y.a -> so-
                }
            }

            export
            template <pint M, N>
            defproc MERGE (globals g; av1of<N> x[M]; c1of<N> y; bool yi, si, so) {
                prs<g.Vdd, g.GND> {
                    ~g.sReset & ~yi & ~si -> so+
                    g.pReset | yi & si -> so-
                }

                c1of<N> u;
                OR<M> or[N];
                (; n : N :
                    or[n].g = g;
                    (; m : M :
                        or[n].i[m] = x[m].d[n];
                    )
                    or[n].o = u.d[n];
                )
                bool vy;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        u.d[n] & yi -> y.d[n]+
                        ~u.d[n] -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) -> vy+
                    (& : n : N : ~y.d[n]) -> vy-

                    (: m : M :
                        x[m].v & ~yi & vy -> x[m].a+
                        ~x[m].v & ~vy -> x[m].a-
                    )
                }
            }
        } // namespace serial_ring2

        export
        template <pint M, N>
        defproc SERIAL_RING2 (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            serial_ring2::NODE<N> node[M];
            serial_ring2::MERGE<M, N> merge(g,,y, yi, node[M-1].so,);
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[m];
                node[m].y = merge.x[m];
            )
            merge.y = y;
            (; m : M-1:
                node[m].so = node[m+1].si;
            )
            merge.so = x.e;
            merge.so = node[0].si;
            merge.so = yo; 
        }

        export
        template <pint M, N>
        defproc SERIAL_MERGE (globals g; bool xi[M], xo[M], yi, yo; c1of<N> x[M], y) {
            // merges aext/aerv protocol serial streams
            // M client streams to merge
            // N 1-of-N data
            prs<g.Vdd, g.GND> {
                (| : m : M : xi[m]) => yo+

                (: m : M :
                    xi[m] & yi -> xo[m]+
                    ~yi -> xo[m]-
                )

                (: n : N :
                    (| : m : M : x[m].d[n]) => y.d[n]+
                )
            }
        }
    }

    namespace transmitter {
        export
        template <pint N>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; c1of<N> c[N], p) {
            // AEXT tree NODE controller
            /*--------------------------------------------------------------*/
            // /* // development
                bool c_[N], u;
                c1of<N> w;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c_[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c_[n]) -> po-
                
                    (: n : N :
                        c_[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c_[0] & u & pi & (& : n : 1..N-1 : ~co[n]) -> co[0]+
                    (: n : 1..N-2:
                        c_[n] & u & pi & 
                        (& : nn : 0..n-1 : ~co[nn]) & 
                        (& : nn : n+1..N-1 : ~co[nn]) -> co[n]+
                    )
                    c_[N-1] & u & pi & (& : n : 0..N-2 : ~co[n]) -> co[N-1]+
                    (: n : N :
                        ~pi -> co[n]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c_[N], q[N], u;
                c1of<N> w;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    c_[0] & ~co[1] -> q[0]+
                    g.pReset | ~c_[0] & co[0] -> q[0]-
                    c_[1] & ~co[0] -> q[1]+
                    g.pReset | ~c_[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: nc : N :
                        q[nc] & u & pi -> co[nc]+
                        (~u | (| : n : N : p.d[n])) & ~pi -> co[nc]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            */
            /*--------------------------------------------------------------*/
        }

        export
        template <pint N>
        defproc LEAF (globals g; bool ci[N], co[N], pi, po; c1of<N> p) {
            // leaf node of aext tree
            /*--------------------------------------------------------------*/
            // /* // development
                bool c[N], u;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c[n]) -> po-
                
                    (: n : N :
                        c[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c[0] & u & pi & (& : n : 1..N-1 : ~co[n]) -> co[0]+
                    (: n : 1..N-2:
                        c[n] & u & pi & 
                        (& : nn : 0..n-1 : ~co[nn]) & 
                        (& : nn : n+1..N-1 : ~co[nn]) -> co[n]+
                    )
                    c[N-1] & u & pi & (& : n : 0..N-2 : ~co[n]) -> co[N-1]+
                    (: n : N :
                        ~pi -> co[n]-
                    )
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c[N], q[N], u;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    c[0] & ~co[1] -> q[0]+
                    g.pReset | ~c[0] & co[0] -> q[0]-
                    c[1] & ~co[0] -> q[1]+
                    g.pReset | ~c[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: n : N :
                        q[n] & u & pi -> co[n]+
                        ~u & ~pi -> co[n]-
                    )
                }
            */
        }
    } // namespace transmitter

    export
    template <pint M, N, NN>
    defproc AEXT (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
        // utility for AEXT
        [ M = 1 ->
            NN = N;
            transmitter::LEAF<N> leaf(g, xi, xo, pi, po, p);
        [] M > 1 ->
            pint k = NN/N;
            AEXT<M-1, N, k> _[N];
            (; n : N :
                _[n].g = g;
                _[n].xi = xi[n*k..(n+1)*k-1];
                _[n].xo = xo[n*k..(n+1)*k-1];
            )

            transmitter::NODE<N> node(g,,, pi, po,, p);
            (; n : N :
                node.ci[n] = _[n].po;
                node.co[n] = _[n].pi;
                node.c[n] = _[n].p;
            )
        ]
    }

    namespace receiver {
        export
        template <pint N>
        defproc NODE (globals g; bool pi, po, ci[N], co[N]; c1of<N> p, c[N]) {
            // node in AERV tree
            bool u[N], cco, cci, uu;
            prs<g.Vdd, g.GND> {
                (pi & ~cco | cci) & ~uu => po+

                (: n : N :
                    p.d[n] & ~cco -> u[n]+
                    g.pReset | cco -> u[n]-
                )

                (| : n : N : u[n]) => uu+

                (: n : N :
                    u[n] & ~p.d[n] -> co[n]+
                    ~pi -> co[n]-
                )

                (| : n : N : co[n]) => cco+
                (| : n : N : ci[n]) => cci+

                (: nc : N :
                    (: n : N :
                        co[nc] & p.d[n] => c[nc].d[n]+
                    )
                )
            }
        }

        export
        template <pint N>
        defproc LEAF (globals g; bool pi, po, ci[N]; c1of<N> p, c[N]) {
            // leaf of AERV tree
            bool u[N], co[N], cco, cci, uu;
            prs<g.Vdd, g.GND> {
                (pi | cco) & ~uu & ~cci => po+

                (: n : N :
                    ~cco & p.d[n] -> u[n]+
                    g.pReset | cco -> u[n]-
                )
                (| : n : N : u[n]) => uu+

                (: n : N :
                    u[n] & ~p.d[n] -> co[n]+
                    ~pi -> co[n]-
                )
                (| : n : N : co[n]) => cco+

                (| : n : N : ci[n]) => cci+

                (: nc : N :
                    (: n : N :
                        co[nc] & p.d[n] => c[nc].d[n]+
                    )
                )
            }
        }

        export
        template <pint N>
        defproc LEAF_NODATA (globals g; bool pi, po, ci[N], co[N]; c1of<N> p) {
            // leaf of AERV tree that does not transmit data
            bool u;
            prs<g.Vdd, g.GND> {
                pi & (& : n : N : ~ci[n]) | u => po+

                (: n : N :
                    p.d[n] -> co[n]+
                    ~pi -> co[n]-
                )

                (| : n : N : ci[n] & ~p.d[n]) => u+
            }
        }
    } // namespace receiver

    export
    template <pint M, N, NN>
    defproc AERV_NODATA (globals g; bool yi[NN], yo[NN], pi, po; c1of<N> p) {
        // receiver that does not send data to neurons
        [ M = 1 ->
            NN = N;
            receiver::LEAF_NODATA<N> leaf(g, pi, po, yi, yo, p);
        [] M > 1 ->
            AERV_NODATA<M-1, N, NN/N> _[N];
            receiver::NODE<N> node(g, pi, po,,, p,);
            pint k = NN/N;
            (; n : N :
                _[n].g = g;
                _[n].p = node.c[n];
                _[n].pi = node.co[n];
                _[n].po = node.ci[n];
                _[n].yi = yi[n*k..(n+1)*k-1];
                _[n].yo = yo[n*k..(n+1)*k-1];
            )
        ]
    }

    export
    template <pint M, N, NN>
    defproc AERV_DATA (globals g; bool yi[NN], pi, po; c1of<N> p, c[NN]) {
        // receiver capable of sending data to neuron
        [ M = 1 ->
            NN = N;
            receiver::LEAF<N> leaf(g, pi, po, yi, p, c);
        [] M > 1 ->
            AERV_DATA<M-1, N, NN/N> _[N];
            receiver::NODE<N> node(g, pi, po,,, p,);
            pint k = NN/N;
            (; n : N :
                _[n].g = g;
                _[n].p = node.c[n];
                _[n].pi = node.co[n];
                _[n].po = node.ci[n];
                _[n].yi = yi[n*k..(n+1)*k-1];
                _[n].c = c[n*k..(n+1)*k-1];
            )
        ]
    }

    export
    template <pint M, N, NN>
    defproc AER_NODATA (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // no data sent to receiving neuron
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        AEXT<M, N, NN> aext(g, xi, xo,,,);
        AERV_NODATA<M, N, NN> aerv(g, yi, yo,,,);
        interface::OUT_a1ofN<N> out(g, aext.po, aext.pi, aext.p,);
        interface::DESERIAL_CHAIN<M, N> deserial(g, out.y,);
        interface::SERIAL_CHAIN<M, N> serial(g, deserial.y, aerv.po, aerv.pi, aerv.p);
    }
} // namespace aer
