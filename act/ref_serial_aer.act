// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";
import "environment.act";

namespace aer {
    namespace interface {
        export
        template <pint N>
        defproc OUT_e1ofN (globals g; bool xi, xo; c1of<N> x; e1of<N> y) {
            // convert AEXT/AERV serial protocol to standard e1ofN channel
            x.d = y.d;
            prs {
                xi & y.e => xo+
            }
        }

        export
        template <pint N>
        defproc OUT_a1ofN (globals g; bool xi, xo; c1of<N> x; a1of<N> y) {
            // convert AEXT/AERV serial protocol to standard a1ofN channel
            x.d = y.d;
            prs {
                xi & ~y.a => xo+
            }
        }

        namespace deserial_ring {
            export
            template <pint M, N>
            defproc SPLIT (globals g; a1of<N> x, y[M]) {
                (; m : M :
                    y[m].d = x.d;
                )
                OR<M> or(g,, x.a);
                (; m : M :
                    y[m].a = or.i[m];
                )
            }
            
            export
            template <pint N>
            defproc NODE (globals g; a1of<N> x; c1of<N> y; bool si, so) {
                bool vy, s;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~s & si & x.d[n] -> y.d[n]+
                        ~si -> y.d[n]-
                    )
            
                    ~so & vy => x.a+
            
                    vy & (& : n : N : ~x.d[n]) -> s+
                    g.pReset | ~vy -> s-
            
                    s => so+

                    (| : n : N : y.d[n]) => vy+
                }
            }
        } // namespace deserial_ring
        
        export
        template <pint M, N>
        defproc DESERIAL_RING (globals g; a1of<N> x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with ring
            deserial_ring::SPLIT<M, N> split(g, x,);
            deserial_ring::NODE<N> node[M];
            (; m : M :
                node[m].g = g;
                node[m].x = split.y[m];
                node[m].y = y.m[m];
            )
            (; m : M-1 :
                node[m].so = node[m+1].si;
            )
            prs<g.Vdd, g.GND> {
                ~g.sReset & ~node[M-1].so & y.e  -> node[0].si+
                g.sReset | node[M-1].so & ~y.e  -> node[0].si-
            }
        }

        namespace serial_chain {
            export
            template <pint N>
            defproc NODE (globals g; e1of<N> x, y; c1of<N> d) {
                bool u, vy, vd;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        y.e & ~u & d.d[n] | x.d[n] -> y.d[n]+
                        g.pReset | ~y.e & u & ~x.d[n] -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) => vy+

                    (| : n : N : d.d[n]) => vd+

                    vy & vd -> u+
                    g.pReset | ~vy & ~vd -> u-

                    y.e & u & ~vy -> x.e+
                    ~y.e & (~u | vy) -> x.e-
                }
            }

            export
            template <pint N>
            defproc TAIL (globals g; bool xe; e1of<N> y; c1of<N> d) {
                bool u, vy, vd;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        y.e & ~u & d.d[n] -> y.d[n]+
                        g.pReset | ~y.e & u -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) => vy+

                    (| : n : N : d.d[n]) => vd+

                    vy & vd -> u+
                    g.pReset | ~vy & ~vd -> u-

                    y.e & u & ~vy -> xe+
                    ~y.e & ~u -> xe-
                }
            }
        } // namespace serial_chain

        export
        template <pint M, N>
        defproc SERIAL_CHAIN (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with chain
            [ M = 1 ->
                serial_chain::TAIL<N> tail(g,,, x.m[0]);
                tail.y.m = y;
                tail.y.e = yi;
            [] M > 1 ->
                pint MM = M-1;
                serial_chain::NODE<N> node[MM];
                serial_chain::TAIL<N> tail(g,, node[MM-1].x, x.m[M-1]);
                (; m : MM :
                    node[m].g = g;
                    node[m].d = x.m[m];
                )
                (; m : MM-1 :
                    node[m].x = node[m+1].y;
                )
                node[0].y.m = y;
                node[0].y.e = yi;
            ]
            bool s;
            s = yo;
            s = x.e;
            prs<g.Vdd, g.GND> {
                g.pReset | tail.xe & yi -> s-
                ~g.sReset & ~tail.xe & ~yi -> s+
            }
        }

        namespace serial_ring {
            export
            template <pint N>
            defproc NODE (globals g; bool si, so; c1of<N> x; a1of<N> y) {
                bool u;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        x.d[n] & ~u & si -> y.d[n]+
                        g.pReset | u & ~so -> y.d[n]-
                    )
            
                    si & y.a -> u+
                    g.pReset | ~si -> u-
            
                    u & ~y.a -> so+
                    ~u & (& : n : N : ~x.d[n]) -> so-
                }
            }
            
            export
            template <pint N>
            defproc MERGE (globals g; bool si, so, yi, yo; a1of<N> x; c1of<N> y) {
                prs<g.Vdd, g.GND> {
                    (| : n : N : x.d[n]) -> yo+
                    g.pReset | ~si & yi -> yo-
            
                    si -> so+
                    ~si & ~yi & ~yo -> so-
            
                    (: n : N :
                        yi & x.d[n] -> y.d[n]+
                        ~x.d[n] -> y.d[n]-
                    )
            
                    (| : n : N : y.d[n]) & ~yi -> x.a+
                    g.pReset | yi -> x.a-
                }
            }
        } // namespace serial_ring

        export
        template <pint M, N>
        defproc SERIAL_RING (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            // highest order in word in input is first word in output
            bool s = x.e;
            serial_ring::NODE<N> node[M];
            serial_ring::MERGE<N> merge(g, s, node[0].si, yi, yo,, y);
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[M-1-m];
                node[m].y = merge.x;
            )
            (; m : M-1 :
                node[m].so = node[m+1].si;
            )
            prs<g.Vdd, g.GND> {
                node[M-1].so => s-
            }
        }

        namespace serial_ring2 {
            export
            template <pint N>
            defproc NODE (globals g; c1of<N> x; av1of<N> y; bool si, so) {
                bool u;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        si & x.d[n] & u -> y.d[n]+
                        ~si | ~x.d[n] | ~u -> y.d[n]-
                    )
                    si & (| : n : N : x.d[n]) & u -> y.v+
                    ~si | (& : n : N : ~x.d[n]) | ~u -> y.v-

                    ~si & (& : n : N : ~x.d[n]) -> u+
                    y.a -> u-

                    ~u & ~y.a -> so+
                    u | y.a -> so-
                }
            }

            export
            template <pint M, N>
            defproc MERGE (globals g; av1of<N> x[M]; c1of<N> y; bool yi, si, so) {
                prs<g.Vdd, g.GND> {
                    ~g.sReset & ~yi & ~si -> so+
                    g.pReset | yi & si -> so-
                }

                c1of<N> u;
                OR<M> or[N];
                (; n : N :
                    or[n].g = g;
                    (; m : M :
                        or[n].i[m] = x[m].d[n];
                    )
                    or[n].o = u.d[n];
                )
                bool vy;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        u.d[n] & yi -> y.d[n]+
                        ~u.d[n] -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) -> vy+
                    (& : n : N : ~y.d[n]) -> vy-

                    (: m : M :
                        x[m].v & ~yi & vy -> x[m].a+
                        ~x[m].v & ~vy -> x[m].a-
                    )
                }
            }
        } // namespace serial_ring2

        export
        template <pint M, N>
        defproc SERIAL_RING2 (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            serial_ring2::NODE<N> node[M];
            serial_ring2::MERGE<M, N> merge(g,,y, yi, node[M-1].so,);
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[m];
                node[m].y = merge.x[m];
            )
            merge.y = y;
            (; m : M-1:
                node[m].so = node[m+1].si;
            )
            merge.so = x.e;
            merge.so = node[0].si;
            merge.so = yo; 
        }

        export
        template <pint M, N>
        defproc SERIAL_MERGE (globals g; bool xi[M], xo[M], yi, yo; c1of<N> x[M], y) {
            // merges aext/aerv protocol serial streams
            // M client streams to merge
            // N 1-of-N data
            ::arbiter::N_ARB_S_PREQ<M> arb_req(g, xi, xo, yi, yo);
            prs<g.Vdd, g.GND> {
                (: n : N :
                    (| : m : M : x[m].d[n]) => y.d[n]+
                )
            }
        }
    }

    namespace transmitter {
        export
        template <pint N>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; c1of<N> c[N], p) {
            // AEXT tree NODE controller
            /*--------------------------------------------------------------*/
            // /* // development
                bool c_[N], u;
                c1of<N> w;
                ::arbiter::N_ARB_S<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c_[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c_[n]) -> po-
                
                    (: n : N :
                        c_[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c_[0] & u & pi & (& : n : 1..N-1 : ~co[n]) -> co[0]+
                    (: n : 1..N-2:
                        c_[n] & u & pi & 
                        (& : nn : 0..n-1 : ~co[nn]) & 
                        (& : nn : n+1..N-1 : ~co[nn]) -> co[n]+
                    )
                    c_[N-1] & u & pi & (& : n : 0..N-2 : ~co[n]) -> co[N-1]+
                    (: n : N :
                        ~pi -> co[n]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c_[N], q[N], u;
                c1of<N> w;
                ::arbiter::N_ARB_S<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    c_[0] & ~co[1] -> q[0]+
                    g.pReset | ~c_[0] & co[0] -> q[0]-
                    c_[1] & ~co[0] -> q[1]+
                    g.pReset | ~c_[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: nc : N :
                        q[nc] & u & pi -> co[nc]+
                        (~u | (| : n : N : p.d[n])) & ~pi -> co[nc]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            */
            /*--------------------------------------------------------------*/
        }

        export
        template <pint N>
        defproc LEAF (globals g; bool ci[N], co[N], pi, po; c1of<N> p) {
            // leaf node of aext tree
            /*--------------------------------------------------------------*/
            // /* // development
                bool c[N], u;
                ::arbiter::N_ARB_S<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    ~u & (| : n : N : c[n]) -> po+
                    g.pReset | (| : n : N : co[n] & ~c[n]) -> po-
                
                    (: n : N :
                        c[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    (& : n : N : ~co[n]) & ~po -> u-
                    
                    c[0] & u & pi & (& : n : 1..N-1 : ~co[n]) -> co[0]+
                    (: n : 1..N-2:
                        c[n] & u & pi & 
                        (& : nn : 0..n-1 : ~co[nn]) & 
                        (& : nn : n+1..N-1 : ~co[nn]) -> co[n]+
                    )
                    c[N-1] & u & pi & (& : n : 0..N-2 : ~co[n]) -> co[N-1]+
                    (: n : N :
                        ~pi -> co[n]-
                    )
                }
            // */
            /*--------------------------------------------------------------*/
            /* // reference
                bool c[N], q[N], u;
                ::arbiter::N_ARB_S<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    c[0] & ~co[1] -> q[0]+
                    g.pReset | ~c[0] & co[0] -> q[0]-
                    c[1] & ~co[0] -> q[1]+
                    g.pReset | ~c[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: n : N :
                        q[n] & u & pi -> co[n]+
                        ~u & ~pi -> co[n]-
                    )
                }
            */
        }
    } // namespace transmitter

    export
    template <pint M, N, NN>
    defproc AEXT (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
        // utility for AEXT
        [ M = 1 ->
            NN = N;
            transmitter::LEAF<N> leaf(g, xi, xo, pi, po, p);
        [] M > 1 ->
            pint k = NN/N;
            AEXT<M-1, N, k> _[N];
            (; n : N :
                _[n].g = g;
                _[n].xi = xi[n*k..(n+1)*k-1];
                _[n].xo = xo[n*k..(n+1)*k-1];
            )

            transmitter::NODE<N> node(g,,, pi, po,, p);
            (; n : N :
                node.ci[n] = _[n].po;
                node.co[n] = _[n].pi;
                node.c[n] = _[n].p;
            )
        ]
    }

    namespace receiver {
        export
        template <pint F, D>
        defproc NODE (globals g; bool pi, po, ci[F], co[F]; c1of<D> p, c[F]) {
            // node in AERV tree
            // F fanout (radix)
            // D 1-of-D data
            bool u[F], cco, cci, uu;
            prs<g.Vdd, g.GND> {
                (pi & ~cco | cci) & ~uu => po+

                (: f : F :
                    p.d[f] & ~cco -> u[f]+
                    g.pReset | cco -> u[f]-
                )

                (| : f : F : u[f]) => uu+

                (: f : F :
                    u[f] & ~p.d[f] -> co[f]+
                    ~pi -> co[f]-
                )

                (| : f : F : co[f]) => cco+
                (| : f : F : ci[f]) => cci+

                (: f : F :
                    (: d : D :
                        co[f] & p.d[d] => c[f].d[d]+
                    )
                )
            }
        }

        export
        template <pint F, D>
        defproc LEAF (globals g; bool pi, po, ci[F]; c1of<D> p, c[F]) {
            // leaf of AERV tree
            // F fanout (number of clients)
            // D 1-of-D data
            bool u[F], cc[F], ccc, cci, uu;
            prs<g.Vdd, g.GND> {
                (pi | ccc) & ~uu & ~cci => po+

                (: f : F :
                    ~ccc & p.d[f] -> u[f]+
                    g.pReset | ccc -> u[f]-
                )
                (| : f : F : u[f]) => uu+

                (: f : F :
                    u[f] & ~p.d[f] -> cc[f]+
                    ~pi -> cc[f]-
                )
                (| : f : F : cc[f]) => ccc+

                (| : f : F : ci[f]) => cci+

                (: f : F :
                    (: d : D :
                        cc[f] & p.d[d] => c[f].d[d]+
                    )
                )
            }
        }

        export
        template <pint N>
        defproc LEAF_NODATA (globals g; bool pi, po, ci[N], co[N]; c1of<N> p) {
            // leaf of AERV tree that does not transmit data
            bool u;
            prs<g.Vdd, g.GND> {
                pi & (& : n : N : ~ci[n]) | u => po+

                (: n : N :
                    p.d[n] -> co[n]+
                    ~pi -> co[n]-
                )

                (| : n : N : ci[n] & ~p.d[n]) => u+
            }
        }
    } // namespace receiver

    export
    template <pint M, F_INT, F_LEAF, T, D>
    defproc AERV (globals g; bool yi[T], pi, po; c1of<D> y[T], p) {
        // receiver capable of sending data to neuron
        // M tree levels
        // F_INT intermediate node fanout (radix)
        // F_LEAF leaf node fanout (radix)
        // T targets. T = F_LEAF * F_INT^(M-1)
        // D 1-of-D data
        [ M = 1 ->
            T = F_LEAF;
            receiver::LEAF<F_LEAF, D> leaf(g, pi, po, yi, p, y);
        [] M > 1 ->
            AERV<M-1, F_INT, F_LEAF, T/F_INT, D> _[F_INT];
            receiver::NODE<F_INT, D> node(g, pi, po,,, p,);
            pint k = T/F_INT;
            (; f : F_INT :
                _[f].g = g;
                _[f].p = node.c[f];
                _[f].pi = node.co[f];
                _[f].po = node.ci[f];
                _[f].yi = yi[f*k..(f+1)*k-1];
                _[f].y = y[f*k..(f+1)*k-1];
            )
        ]
    }

    export
    template <pint M, N, NN>
    defproc AERV_NODATA (globals g; bool yi[NN], yo[NN], pi, po; c1of<N> p) {
        // receiver that does not send data to neurons
        [ M = 1 ->
            NN = N;
            receiver::LEAF_NODATA<N> leaf(g, pi, po, yi, yo, p);
        [] M > 1 ->
            AERV_NODATA<M-1, N, NN/N> _[N];
            receiver::NODE<N, N> node(g, pi, po,,, p,);
            pint k = NN/N;
            (; n : N :
                _[n].g = g;
                _[n].p = node.c[n];
                _[n].pi = node.co[n];
                _[n].po = node.ci[n];
                _[n].yi = yi[n*k..(n+1)*k-1];
                _[n].yo = yo[n*k..(n+1)*k-1];
            )
        ]
    }

    export
    template <pint M, M_SPK, M_MEM, N_SYN, N_MEM>
    defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                        eMx1of4<M_MEM> x_mem;
                        a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> y_mem[N_MEM]) {
        // braindrop / brainstorm receiver system
        // M tree depth
        //     M = 5 (in production)
        // M_SPK packet length of spike to deliver to synapse.
        //     M_SPK = M + 1
        //     M_SPK = 6 (in production)
        // M_MEM packet length to write config memory
        //     M_MEM = M + memory packet length
        //     M_MEM = 9 (in production)
        // N_SYN synapses
        //     N_SYN = 4^M
        //     N_SYN = 1024 (in production)
        // N_MEM configuration memories
        //     N_MEM = 4^(M-1)
        //     N_MEM = 256 (in production)
        pint F_INT = 4;
        pint F_LEAF = 3;
        pint D = 4;
        pint AERV_TGTS = N_SYN/2 + N_MEM;

        interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
        interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
        serial_spk.x.m = x_spk.m;
        serial_mem.x.m = x_mem.m;
        serial_spk.x.e = x_spk.e;
        serial_mem.x.e = x_mem.e;

        bool merge_xi[2];
        bool merge_xo[2];
        c1of<D> merge_x[2];
        merge_xi[0] = serial_spk.yo;
        merge_xi[1] = serial_mem.yo;
        merge_xo[0] = serial_spk.yi;
        merge_xo[1] = serial_mem.yi;
        merge_x[0] = serial_spk.y;
        merge_x[1] = serial_mem.y;

        interface::SERIAL_MERGE<2, D> merge(g, merge_xi, merge_xo,,, merge_x,);

        interface::DESERIAL_RING<M_MEM-M, D> mem_deserial[N_MEM];
        (; n : N_MEM :
            mem_deserial[n].g = g;
            mem_deserial[n].y.m = y_mem[n].m;
            mem_deserial[n].y.e = y_mem[n].e;
        )
        
        OR<2> or_a[N_SYN/2];
        bool aerv_yi[AERV_TGTS];
        (; n : N_SYN/2 :
            or_a[n].g = g;
            or_a[n].i[0] = y_syn[2*n].a;
            or_a[n].i[1] = y_syn[2*n+1].a;
        )
        (; n : N_SYN/4 :
            or_a[2*n].o = aerv_yi[3*n];
            or_a[2*n+1].o = aerv_yi[3*n+1];
            mem_deserial[n].x.a = aerv_yi[3*n+2];
        )

        c1of<D> aerv_y[AERV_TGTS];
        (; n : AERV_TGTS/3 :
            aerv_y[3*n].d[0..1] = y_syn[4*n].d;
            aerv_y[3*n].d[2..3] = y_syn[4*n+1].d;
            aerv_y[3*n+1].d[0..1] = y_syn[4*n+2].d;
            aerv_y[3*n+1].d[2..3] = y_syn[4*n+3].d;
            aerv_y[3*n+2].d = mem_deserial[n].x.d;
        )

        AERV<M, F_INT, F_LEAF, AERV_TGTS, D> aerv(
            g, aerv_yi, merge.yo, merge.yi, aerv_y, merge.y);
    }

    export
    template <pint M, N, NN>
    defproc AER_NODATA (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // no data sent to receiving neuron
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        AEXT<M, N, NN> aext(g, xi, xo,,,);
        AERV_NODATA<M, N, NN> aerv(g, yi, yo,,,);
        interface::OUT_a1ofN<N> out(g, aext.po, aext.pi, aext.p,);
        interface::DESERIAL_RING<M, N> deserial(g, out.y,);
        interface::SERIAL_CHAIN<M, N> serial(g, deserial.y, aerv.po, aerv.pi, aerv.p);
    }
} // namespace aer
