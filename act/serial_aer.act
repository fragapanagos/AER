// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";
import "environment.act";

namespace aer {
    namespace interface {
        export
        template <pint N>
        defproc OUT_a1ofN (globals g; bool xi, xo; c1of<N> x; a1of<N> y) {
            // convert AEXT/AERV serial protocol to standard a1ofN channel
            bool _xi;
            x.d = y.d;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    xi => _xi-
                    ~_xi & ~y.a => xo+
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~xi<12> -> _xi+
                    xi<9> -> _xi-

                    ~_xi<40> & ~y.a<40> -> xo+
                    _xi<16> | y.a<16> -> xo-
                }
            ]
        }

        export
        template <pint N>
        defproc OUT_e1ofN (globals g; bool xi, xo; c1of<N> x; e1of<N> y) {
            // convert AEXT/AERV serial protocol to standard e1ofN channel
            OUT_a1ofN<N> _(g, xi, xo, x,);
            y.d = _.y.d;
            prs<g.Vdd, g.GND> {
                y.e => _.y.a-
            }
        }

        namespace deserial_ring {
            export
            template <pint M, N>
            defproc SPLIT (globals g; a1of<N> x, _y[M]) {
                // SPLIT with active high input
                c1of<N> _x;
                (; m : M :
                    _y[m].m = _x;
                )
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        (: n : N:
                            x.d[n] => _x.d[n]-
                        )
                    }
                    _OR<M> or(g,,);
                    (; m : M :
                        _y[m].a = or._i[m];
                    )
                    prs<g.Vdd, g.GND> {
                        or._o => x.a-
                    }
                [] LAYOUT ->
                    // _x.d[0..N]
                    [ M = 4 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N:
                                x.d[n]<8> -> _x.d[n]-
                                ~x.d[n]<16> -> _x.d[n]+
                            )
                        }
                    [] M = 6 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N:
                                x.d[n]<12> -> _x.d[n]-
                                ~x.d[n]<18> -> _x.d[n]+
                            )
                        }
                    [] ((M != 4) | (M != 6)) ->
                        prs<g.Vdd, g.GND> {
                            (: n : N:
                                x.d[n]<6*M> -> _x.d[n]-
                                ~x.d[n]<9*M> -> _x.d[n]+
                            )
                        }
                    ]

                    // x.a
                    [ M = 4 ->
                        prs<g.Vdd, g.GND> {
                            (| : m : M : ~_y[m].a<12>) -> x.a+
                            (& : m : M : _y[m].a<24>) -> x.a-
                        }
                    [] (M != 4) ->
                        _OR<M> or(g,,);
                        (; m : M :
                            _y[m].a = or._i[m];
                        )
                        prs<g.Vdd, g.GND> {
                            ~or._o<10> -> x.a+
                            or._o<6> -> x.a-
                        }
                    ]
                ]
            }

            export
            template <pint N>
            defproc NODE (globals g; a1of<N> _x; c1of<N> y; bool _si, _so) {
                bool _s, __s, vy;
                c1of<N> _y;
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _s => __s-

                        (: n : N :
                            ~__s & ~_si & ~_x.d[n] -> y.d[n]+
                            _si -> y.d[n]-
                        )

                        _so & vy => _x.a-

                        vy & (& : n : N : _x.d[n]) -> _s-
                        ~g._pReset | ~vy -> _s+

                        __s => _so-

                        (: n : N :
                            y.d[n] => _y.d[n]-
                        )

                        (| : n : N : ~_y.d[n]) => vy+
                    }
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        ~_s<16> -> __s+
                        _s<10> -> __s-

                        (: n : N :
                            ~__s<35> & ~_si<35> & ~_x.d[n]<35> -> y.d[n]+
                            _si<15> -> y.d[n]-
                        )

                        _so<12> & vy<12> -> _x.a-
                        ~_so<12> | ~vy<12> -> _x.a+

                        vy<34> & (& : n : N : _x.d[n]<34>) -> _s-
                        ~g._pReset | ~vy<19> -> _s+

                        __s<12> -> _so-
                        ~__s<18> -> _so+

                        (: n : N :
                            ~y.d[n]<12> -> _y.d[n]+
                            y.d[n]<12> -> _y.d[n]-
                        )

                        (| : n : N : ~_y.d[n]<16>) -> vy+
                        (& : n : N : _y.d[n]<24>) -> vy-
                    }
                ]
            }
        } // namespace deserial_ring

        export
        template <pint M, N>
        defproc DESERIAL_RING (globals g; a1of<N> x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with ring
            // first word in input is highest order word in output
            deserial_ring::SPLIT<M, N> split(g, x,);
            deserial_ring::NODE<N> node[M];
            (; m : M :
                node[m].g = g;
                node[m]._x = split._y[m];
                node[m].y = y.m[M-1-m];
            )

            (; m : M-1 :
                node[m]._so = node[m+1]._si;
            )
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~g._sReset | ~node[M-1]._so & ~y.e  -> node[0]._si+
                    g._sReset & node[M-1]._so & y.e  -> node[0]._si-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~g._sReset | ~node[M-1]._so<30> & ~y.e<30> -> node[0]._si+
                    g._sReset<20> & y.e<20> & node[M-1]._so<20> -> node[0]._si-
                }
            ]
        }

        namespace serial_ring {
            export
            template <pint M, N>
            defproc RING (globals g; bool _si, _so; c1of<N> x[M]; a1of<N> _y) {
                bool _u[M], __u[M], ___u[M], _si_[M], __si[M], so[M], _so_[M];
                _si = _si_[0];
                _so = _so_[M-1];
                bool ya = _y.a; // active high
                [ M > 1 ->
                    (; m : 1..M-1 :
                        _si_[m] = _so_[m-1];
                    )
                ]
                c1of<N> _x[M];
                c1of<N> y;
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        (: m : M :
                            (: n : N :
                                x[m].d[n] => _x[m].d[n]-
                            )
                        )

                        (: m : M :
                            _u[m] => __u[m]-
                        )

                        (: m : M :
                            so[m] => _so_[m]-
                        )

                        (: n : N :
                            (| : m : M : ~_x[m].d[n] & ~__u[m] & ~_si_[m]) -> y.d[n]+
                            g.pReset | (| : m : M : _so_[m] & __u[m]) -> y.d[n]-
                        )

                        (: m : M :
                            _si_[m] => __si[m]-
                        )

                        (: m : M :
                            __si[m] & ya -> _u[m]-
                            ~g._pReset | ~__si[m] -> _u[m]+
                        )

                        (: m : M :
                            __u[m] => ___u[m]-
                        )

                        (: m : M :
                            ~___u[m] & ~ya -> so[m]+
                            ___u[m] & (& : n : N : _x[m].d[n]) -> so[m]-
                        )
                    }
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            ~y.d[n] -> _y.d[n]+
                            y.d[n] -> _y.d[n]-
                        )
                    }
                [] LAYOUT ->
                    [ M = 6 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                (| : m : M : ~_x[m].d[n]<90> & ~_si_[m]<90> & ~__u[m]<90>) -> y.d[n]+
                                g.pReset | (| : m : M : _so_[m]<40> & __u[m]<40>) -> y.d[n]-
                            )
                        }
                    [] M = 9 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                (| : m : M : ~_x[m].d[n]<120> & ~_si_[m]<120> & ~__u[m]<120>) -> y.d[n]+
                                g.pReset | (| : m : M : _so_[m]<60> & __u[m]<60>) -> y.d[n]-
                            )
                        }
                    [] (M != 6) & (M != 9) ->
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                (| : m : M : ~_x[m].d[n]<48> & ~_si_[m]<48> & ~__u[m]<48>) -> y.d[n]+
                                g.pReset | (| : m : M : _so_[m]<45> & __u[m]<45>) -> y.d[n]-
                            )
                        }
                    ]
                    prs<g.Vdd, g.GND> {
                        (: m : M :
                            (: n : N :
                                ~x[m].d[n]<12> -> _x[m].d[n]+
                                x[m].d[n]<9> -> _x[m].d[n]-
                            )
                        )

                        (: m : M :
                            ~_u[m]<24> -> __u[m]+
                            _u[m]<16> -> __u[m]-
                        )

                        (: m : M :
                            ~so[m]<23> -> _so_[m]+
                            so[m]<16> -> _so_[m]-
                        )

                        (: m : M :
                            ~_si_[m]<12> -> __si[m]+
                            _si_[m]<8> -> __si[m]-
                        )

                        (: m : M :
                            ya<18> & __si[m]<18> -> _u[m]-
                            ~g._pReset | ~__si[m]<16> -> _u[m]+
                        )

                        (: m : M :
                            ~__u[m]<18> -> ___u[m]+
                            __u[m]<12> -> ___u[m]-
                        )

                        (: m : M :
                            ~___u[m]<36> & ~ya<36> -> so[m]+
                            ___u[m]<40> & (& : n : N : _x[m].d[n]<40>) -> so[m]-
                        )
                    }
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            ~y.d[n]<12> -> _y.d[n]+
                            y.d[n]<12> -> _y.d[n]-
                        )
                    }
                ]
            }

            export
            template <pint N | pint M>
            defproc SEQ (globals g; bool _si, _so, yi, yo; a1of<N> _x; c1of<N> y) {
                bool __si;
                bool xa = _x.a; // active high
                c1of<N> __x, _y;
                c1of<N> __y = y;
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        (| : n : N : ~_x.d[n]) -> yo+
                        g.pReset | _si & yi -> yo-

                        _si => __si-

                        __si -> _so-
                        ~__si & ~yi & ~yo -> _so+

                        (: n : N :
                            _x.d[n] => __x.d[n]-
                        )

                        (: n : N :
                            yi & __x.d[n] -> _y.d[n]-
                            ~__x.d[n] -> _y.d[n]+
                        )

                        (| : n : N : ~_y.d[n]) & ~yi -> xa+
                        g.pReset | yi -> xa-
                    }
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            _y.d[n] => __y.d[n]-
                        )
                    }
                [] LAYOUT ->
                    [ M = 6 ->
                        prs<g.Vdd, g.GND> {
                            (| : n : N : ~_y.d[n]<40>) & ~yi<40> -> xa+
                            g.pReset | yi<18> -> xa-
                        }
                    [] M = 9 ->
                        prs<g.Vdd, g.GND> {
                            (| : n : N : ~_y.d[n]<45>) & ~yi<45> -> xa+
                            g.pReset | yi<18> -> xa-
                        }
                    [] (M != 6) & (M !=9) ->
                        prs<g.Vdd, g.GND> {
                            (| : n : N : ~_y.d[n]<M*12>) & ~yi<M*12> -> xa+
                            g.pReset | yi<M*6> -> xa-
                        }
                    ]
                    prs<g.Vdd, g.GND> {
                        (| : n : N : ~_x.d[n]<15>) -> yo+
                        g.pReset | _si<18> & yi<18> -> yo-

                        ~_si<12> -> __si+
                        _si<9> -> __si-

                        __si<20> -> _so-
                        ~__si<36> & ~yi<36> & ~yo<36> -> _so+

                        (: n : N :
                            ~_x.d[n]<11> -> __x.d[n]+
                            _x.d[n]<9> -> __x.d[n]-
                        )

                        (: n : N :
                            yi<16> & __x.d[n]<16> -> _y.d[n]-
                            ~__x.d[n]<16> -> _y.d[n]+
                        )

                    }
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            ~_y.d[n]<12> -> __y.d[n]+
                            _y.d[n]<9> -> __y.d[n]-
                        )
                    }
                ]
            }
        } // namespace serial_ring

        export
        template <pint M, N>
        defproc SERIAL_RING (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            // highest order in word in input is first word in output
            bool _s = x.e;
            serial_ring::RING<M, N> ring(g,, _s,,);
            serial_ring::SEQ<N, M> seq(g,, ring._si, yi, yo, ring._y, y);
            (; m : M :
                ring.x[m] = x.m[M-1-m];
            )
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    _s => seq._si-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~_s<12> -> seq._si+
                    _s<6> -> seq._si-
                }
            ]
        }

        export
        template <pint M, N>
        defproc SERIAL_MERGE (globals g; bool xi[M], xo[M], yi, yo; c1of<N> x[M], y) {
            // merges aext/aerv protocol serial streams
            // M client streams to merge
            // N 1-of-N data
            ::arbiter::N_ARB_S_PREQ<M> arb_req(g, xi, xo, yi, yo);
            c1of<N> b;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        (| : m : M : x[m].d[n]) => b.d[n]-
                        b.d[n] => y.d[n]-
                    )
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        (| : m : M : x[m].d[n]<6>) -> b.d[n]-
                        (& : m : M : ~x[m].d[n]<12>) -> b.d[n]+
                        b.d[n]<6> -> y.d[n]-
                        ~b.d[n]<12> -> y.d[n]+
                    )
                }
            ]
        }
    }

    namespace transmitter {
        export
        template <pint N, root>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; c1of<N> _c[N], _p) {
            // AEXT tree NODE
            bool c_[N], _co[N], _po, u, _u;
            c1of<N> _w, p;
            ::arbiter::N_ARB_S<N> arb(g, ci, c_);

            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    _u & (| : n : N : c_[n]) -> _po-
                    ~g._pReset | (| : n : N : ~_co[n] & ~c_[n]) -> _po+

                    _po => po-

                    (: n : N :
                        c_[n] & pi & _u -> _w.d[n]-
                        ~g._pReset | ~_u -> _w.d[n]+
                    )

                    ~pi & (| : n : N : ~_w.d[n]) -> u+
                    _po & (& : n : N : _co[n]) -> u-

                    u => _u-

                    c_[0] & u & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                    (: n : 1..N-2:
                        c_[n] & u & pi & 
                            (& : nn : 0..n-1 : _co[nn]) & 
                            (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                    )
                    c_[N-1] & u & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                    (: n : N :
                        ~pi -> _co[n]+

                        _co[n] => co[n]-
                    )

                    (: n : N :
                        (| : nc : N : ~_c[nc].d[n]) | ~_w.d[n] => p.d[n]+
                    )
                }

                [ root = 0 ->
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            p.d[n] => _p.d[n]-
                        )
                    }
                [] root = 1 ->
                    p = _p;
                ]
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    _u<26> & (| : n : N : c_[n]<26>) -> _po-
                    ~g._pReset | (| : n : N : ~_co[n]<45> & ~c_[n]<45>) -> _po+

                    ~_po<12> -> po+
                    _po<8> -> po-

                    (: n : N :
                        c_[n]<20> & pi<20> & _u<20> -> _w.d[n]-
                        ~g._pReset | ~_u<16> -> _w.d[n]+
                    )

                    ~pi<45> & (| : n : N : ~_w.d[n]<45>) -> u+
                    _po<40> & (& : n : N : _co[n]<40>) -> u-

                    ~u<15> -> _u+
                    u<9> -> _u-

                    c_[0]<48> & u<48> & pi<48> & 
                        (& : n : 1..N-1 : _co[n]<48>) -> _co[0]-
                    (: n : 1..N-2:
                        c_[n]<48> & u<48> & pi<48> & 
                            (& : nn : 0..n-1 : _co[nn]<48>) & 
                            (& : nn : n+1..N-1 : _co[nn]<48>) -> _co[n]-
                    )
                    c_[N-1]<48> & u<48> & pi<48> &
                        (& : n : 0..N-2 : _co[n]<48>) -> _co[N-1]-
                    (: n : N :
                        ~pi<27> -> _co[n]+

                        ~_co[n]<24> -> co[n]+
                        _co[n]<15> -> co[n]-
                    )

                    (: n : N :
                        (| : nc : N : ~_c[nc].d[n]<18>) | ~_w.d[n]<18> -> p.d[n]+
                        (& : nc : N : _c[nc].d[n]<30>) & _w.d[n]<30> -> p.d[n]-
                    )
                }

                [ root = 0 ->
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            ~p.d[n]<12> -> _p.d[n]+
                            p.d[n]<9> -> _p.d[n]-
                        )
                    }
                [] root = 1 ->
                    p = _p;
                ]
            ]
        }

        export
        template <pint N, root>
        defproc LEAF (globals g; bool ci[N], co[N], pi, po; c1of<N> _p) {
            // AEXT tree LEAF
            bool c[N], _co[N], _u, u, _po;
            c1of<N> _p_;
            ::arbiter::N_ARB_S<N> arb(g, ci, c);

            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    _u & (| : n : N : c[n]) -> _po-
                    ~g._pReset | (| : n : N : ~_co[n] & ~c[n]) -> _po+

                    _po => po-

                    (: n : N :
                        c[n] & pi & _u -> _p_.d[n]-
                        ~g._pReset | ~_u -> _p_.d[n]+
                    )

                    ~pi & (| : n : N : ~_p_.d[n]) -> u+
                    _po & (& : n : N : _co[n]) -> u-

                    ~u -> _u+
                    u -> _u-

                    c[0] & u & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                    (: n : 1..N-2:
                        c[n] & u & pi & 
                        (& : nn : 0..n-1 : _co[nn]) & 
                        (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                    )
                    c[N-1] & u & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                    (: n : N :
                        ~pi -> _co[n]+

                        ~_co[n] -> co[n]+
                        _co[n] -> co[n]-
                    )
                }

                [ root = 0 ->
                    _p_ = _p;
                [] root = 1 ->
                    // present normal sense interface
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            ~_p_.d[n] -> _p.d[n]+
                            _p_.d[n] -> _p.d[n]-
                        )
                    }
                ]
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    _u<26> & (| : n : N : c[n]<26>) -> _po-
                    ~g._pReset | (| : n : N : ~_co[n]<44> &
                        ~c[n]<44>) -> _po+

                    ~_po<12> -> po+
                    _po<8> -> po-

                    (: n : N :
                        c[n]<18> & pi<18> & _u<18> -> _p_.d[n]-
                        ~g._pReset | ~_u<16> -> _p_.d[n]+
                    )

                    (| : n : N : ~_p_.d[n]<45>) & ~pi<45> -> u+
                    _po<40> & (& : n : N : _co[n]<40>) -> u-

                    ~u<15> -> _u+
                    u<10> -> _u-

                    c[0]<45> & u<45> & pi<45> &
                        (& : n : 1..N-1 : _co[n]<45>) -> _co[0]-
                    (: n : 1..N-2:
                        c[n]<45> & u<45> & pi<45> & 
                        (& : nn : 0..n-1 : _co[nn]<45>) & 
                        (& : nn : n+1..N-1 : _co[nn]<45>) -> _co[n]-
                    )
                    c[N-1]<45> & u<45> & pi<45> &
                        (& : n : 0..N-2 : _co[n]<45>) -> _co[N-1]-
                    (: n : N :
                        ~pi<30> -> _co[n]+

                        ~_co[n]<12> -> co[n]+
                        _co[n]<9> -> co[n]-
                    )
                }

                [ root = 0 ->
                    _p_ = _p;
                [] root = 1 ->
                    // present normal sense interface
                    c1of<N> p = _p;
                    prs<g.Vdd, g.GND> {
                        (: n : N :
                            ~_p_.d[n]<12> -> p.d[n]+
                            _p_.d[n]<6> -> p.d[n]-
                        )
                    }
                ]
            ]
        }

        export
        template <pint M, N, NN, root>
        defproc AEXT_ (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
            // utility for AEXT
            [ M = 1 ->
                NN = N;
                LEAF<N, root> leaf(g, xi, xo, pi, po, p);
            [] M > 1 ->
                pint k = NN/N;
                AEXT_<M-1, N, k, 0> _[N];
                (; n : N :
                    _[n].g = g;
                    _[n].xi = xi[n*k..(n+1)*k-1];
                    _[n].xo = xo[n*k..(n+1)*k-1];
                )

                NODE<N, root> node(g,,, pi, po,, p);
                (; n : N :
                    node.ci[n] = _[n].po;
                    node.co[n] = _[n].pi;
                    node._c[n] = _[n].p;
                )
            ]
        }
    } // namespace transmitter

    export
    template <pint M, N, NN>
    defproc AEXT (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
        // Transmitter
        transmitter::AEXT_<M, N, NN, 1> _(g, xi, xo, pi, po, p);
    }

    namespace receiver {
        export
        template <pint F, D>
        defproc NODE (globals g; bool _pi, _po, _ci[F], _co[F]; c1of<D> p, c[F]) {
            // AERV tree NODE
            // F fanout (radix)
            // D 1-of-D data
            bool u[F], _u[F], uu, _v, __v, po;
            c1of<D> _p;
            prs<g.Vdd, g.GND> {
                (: f : F :
                    u[f] => _u[f]-
                )

                (| : f : F : ~_u[f]) => uu+

                ~_pi & ~uu | (| : f : F : ~_ci[f]) => po+

                _v => __v-

                (: d : D :
                    p.d[d] => _p.d[d]-
                )

                (: f : F :
                    ~_p.d[f] & ~__v -> u[f]+
                    _pi -> u[f]-
                )

                uu & (& : f : F : _p.d[f]) -> _v-
                ~uu -> _v+

                (: f : F :
                    __v & u[f] => _co[f]-
                )

                (: f : F :
                    (: d : D :
                        ~_p.d[d] & ~_co[f] => c[f].d[d]+
                    )
                )
            }
            prs<g.Vdd, g.GND> {
                po => _po-
            }
        }

        export
        template <pint N>
        defproc LEAF_NODATA (globals g; bool pi, po, ci[N], co[N]; c1of<N> p) {
            // AERV tree LEAF that does not transmit data
            // N clients
            bool u, _po, _ci[N], _co[N];
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ci[n] => _ci[n]-
                    )

                    pi & (& : n : N : _ci[n]) | u => _po-

                    (: n : N :
                        p.d[n] -> _co[n]-
                        ~pi -> _co[n]+
                    )

                    (| : n : N : ~_ci[n] & ~p.d[n]) => u+
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        _co[n] => co[n]-
                    )

                    _po => po-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~ci[n]<9> -> _ci[n]+
                        ci[n]<6> -> _ci[n]-
                    )

                    pi<30> & (& : n : N : _ci[n]<30>) | u<6> -> _po-
                    (~pi<24> | (| : n : N : ~_ci[n]<24>)) & ~u<24> -> _po+

                    (: n : N :
                        p.d[n]<6> -> _co[n]-
                        ~pi<9> -> _co[n]+
                    )

                    (| : n : N : ~_ci[n]<24> & ~p.d[n]<24>) -> u+
                    (& : n : N : _ci[n]<24> | p.d[n]<24>) -> u-
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_co[n]<9> -> co[n]+
                        _co[n]<6> -> co[n]-
                    )

                    ~_po<9> -> po+
                    _po<6> -> po-
                }
            ]
        }

        export
        template <pint M, F_INT, F_LEAF, T, D>
        defproc AERV_ (globals g; bool _yi[T], _yo[T], _pi, _po; c1of<D> y[T], p) {
            // utility for AERV
            [ M = 1 ->
                NODE<F_LEAF, D> leaf(g, _pi, _po, _yi, _yo, p, y);
            [] M > 1 ->
                AERV_<M-1, F_INT, F_LEAF, T/F_INT, D> _[F_INT];
                NODE<F_INT, D> node(g, _pi, _po,,, p,);
                pint k = T/F_INT;
                (; f : F_INT :
                    _[f].g = g;
                    _[f].p = node.c[f];
                    _[f]._pi = node._co[f];
                    _[f]._po = node._ci[f];
                    _[f]._yi = _yi[f*k..(f+1)*k-1];
                    _[f]._yo = _yo[f*k..(f+1)*k-1];
                    _[f].y = y[f*k..(f+1)*k-1];
                )
            ]
        }

        export
        template <pint M, N, NN>
        defproc AERV_NODATA_ (globals g; bool yi[NN], yo[NN], _pi, _po; c1of<N> p) {
            // utility for AERV_NODATA
            [ M = 1 ->
                NN = N;
                LEAF_NODATA<N> leaf(g,,, yi, yo, p);
                prs<g.Vdd, g.GND> {
                    _pi => leaf.pi-
                    leaf.po => _po-
                }
            [] M > 1 ->
                AERV_NODATA_<M-1, N, NN/N> _[N];
                NODE<N, N> node(g, _pi, _po,,, p,);
                pint k = NN/N;
                (; n : N :
                    _[n].g = g;
                    _[n].p = node.c[n];
                    _[n]._pi = node._co[n];
                    _[n]._po = node._ci[n];
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].yo = yo[n*k..(n+1)*k-1];
                )
            ]
        }
    } // namespace receiver

    export
    template <pint M, F_INT, F_LEAF, T, D>
    defproc AERV (globals g; bool _yi[T], yo[T], pi, po; c1of<D> y[T], p) {
        // receiver capable of sending data to neuron
        // M tree levels
        // F_INT intermediate node fanout (radix)
        // F_LEAF leaf node fanout (radix)
        // T targets. T = F_LEAF * F_INT^(M-1)
        // D 1-of-D data
        receiver::AERV_<M, F_INT, F_LEAF, T, D> _(g, _yi,,,, y, p);
        prs<g.Vdd, g.GND> {
            (: t : T :
                _._yo[t] => yo[t]-
            )
            pi => _._pi-
            _._po => po-
        }
    }

    export
    template <pint M, N, NN>
    defproc AERV_NODATA (globals g; bool yi[NN], yo[NN], pi, po; c1of<N> p) {
        // basic receiver that only sends spikes to neurons
        // single spike type, no excitatory/inhibitory spike types 
        [ M = 1 ->
            NN = N;
            receiver::LEAF_NODATA<N> leaf(g, pi, po, yi, yo, p);
        [] M > 1 ->
            receiver::AERV_NODATA_<M, N, NN> _(g, yi, yo,,, p);
            prs<g.Vdd, g.GND> {
                pi => _._pi-
                _._po => po-
            }
        ]
    }

    namespace brain_receiver {
        export
        template <pint C>
        defproc MERGE_ACK (globals g; bool pp, _po, ci[C]) {
            // merges acknowledges from children with pphi acknowledge
            // C clients
            bool _cci;
            prs<g.Vdd, g.GND> {
                (& : c : C : ~ci[c]) => _cci+
                pp & _cci => _po-
            }
        }
    } // namespace brain_receiver

    export
    template <pint M, M_SPK, M_MEM, N_SYN, N_MEM>
    defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                        eMx1of4<M_MEM> x_mem;
                        a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> y_mem[N_MEM]) {
        // braindrop / brainstorm receiver system
        // M tree depth
        //     M = 5 (in production)
        // M_SPK packet length of spike to deliver to synapse.
        //     M_SPK = M + 1
        //     M_SPK = 6 (in production)
        // M_MEM packet length to write config memory
        //     M_MEM = M + memory packet length
        //     M_MEM = 9 (in production)
        // N_SYN synapses
        //     N_SYN = 4^M
        //     N_SYN = 1024 (in production)
        // N_MEM configuration memories
        //     N_MEM = 4^(M-1)
        //     N_MEM = 256 (in production)
        pint F_INT = 4;
        pint F_LEAF = 3;
        pint D = 4;
        pint AERV_TGTS = N_SYN/2 + N_MEM;

        interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
        interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
        (; m : M_SPK :
            serial_spk.x.m[m].d = x_spk.m[m].d;
        )
        (; m : M_MEM :
            serial_mem.x.m[m].d = x_mem.m[m].d;
        )
        serial_spk.x.e = x_spk.e;
        serial_mem.x.e = x_mem.e;

        bool merge_xi[2];
        bool merge_xo[2];
        c1of<D> merge_x[2];
        merge_xi[0] = serial_spk.yo;
        merge_xi[1] = serial_mem.yo;
        merge_xo[0] = serial_spk.yi;
        merge_xo[1] = serial_mem.yi;
        merge_x[0] = serial_spk.y;
        merge_x[1] = serial_mem.y;

        interface::SERIAL_MERGE<2, D> merge(g, merge_xi, merge_xo,,, merge_x,);

        interface::DESERIAL_RING<M_MEM-M, D> mem_deserial[N_MEM];
        (; n : N_MEM :
            mem_deserial[n].g = g;
            (; m : M_MEM - M :
                mem_deserial[n].y.m[m].d = y_mem[n].m[m].d;
            )
            mem_deserial[n].y.e = y_mem[n].e;
        )
        
        brain_receiver::MERGE_ACK<2> ack_syn[N_SYN/2]; // ack syns
        brain_receiver::MERGE_ACK<1> ack_mem[N_SYN/4]; // ack mems
        bool aerv__yi[AERV_TGTS];
        bool aerv_yo[AERV_TGTS];
        (; n : N_SYN/2 :
            ack_syn[n].g = g;
            // connect synapse ack to ack_syn
            ack_syn[n].ci[0] = y_syn[2*n].a;
            ack_syn[n].ci[1] = y_syn[2*n+1].a;
        )
        (; n : N_SYN/4 :
            // connect aerv pphi to ack_syn 
            ack_syn[2*n].pp = aerv_yo[3*n];
            ack_syn[2*n+1].pp = aerv_yo[3*n+1];
            // connect ack_syn ack to aerv
            ack_syn[2*n]._po = aerv__yi[3*n];
            ack_syn[2*n+1]._po = aerv__yi[3*n+1];
            // connect mem ack to ack_mem
            ack_mem[n].ci[0] = mem_deserial[n].x.a;
            // connect aerv pphi to ack_mem
            ack_mem[n].pp = aerv_yo[3*n+2];
            // connect ack_mem ack to aerv
            ack_mem[n]._po = aerv__yi[3*n+2];
        )

        c1of<D> aerv_y[AERV_TGTS];
        (; n : AERV_TGTS/3 :
            aerv_y[3*n].d[0..1] = y_syn[4*n].d;
            aerv_y[3*n].d[2..3] = y_syn[4*n+1].d;
            aerv_y[3*n+1].d[0..1] = y_syn[4*n+2].d;
            aerv_y[3*n+1].d[2..3] = y_syn[4*n+3].d;
            aerv_y[3*n+2].d = mem_deserial[n].x.d;
        )

        AERV<M, F_INT, F_LEAF, AERV_TGTS, D> aerv(
            g, aerv__yi, aerv_yo, merge.yo, merge.yi, aerv_y, merge.y);
    }

    export
    template <pint M, N, NN>
    defproc AER_NODATA (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // no data sent to receiving neuron
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        AEXT<M, N, NN> aext(g, xi, xo,,,);
        interface::OUT_a1ofN<N> out(g, aext.po, aext.pi, aext.p,);
        interface::DESERIAL_RING<M, N> deserial(g, out.y,);
        interface::SERIAL_RING<M, N> serial(g, deserial.y,,,);
        AERV_NODATA<M, N, NN> aerv(g, yi, yo, serial.yo, serial.yi, serial.y);
    }
} // namespace aer
