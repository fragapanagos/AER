// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";
import "environment.act";

namespace aer {
    namespace interface {
        export
        template <pint N | pint width>
        defproc OUT_e1ofN (globals g; bool xi, xo; c1of<N> x; e1of<N> y) {
            // convert AEXT/AERV serial protocol to standard e1ofN channel
            x.d = y.d;
            prs {
                xi & y.e => xo+
            }
        }

        export
        template <pint N | pint width>
        defproc OUT_a1ofN (globals g; bool xi, xo; c1of<N> x; a1of<N> _y) {
            // convert AEXT/AERV serial protocol to standard a1ofN channel
            bool _xo;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    xi & _y.a => _xo-
                    _xo => xo-
                    (: n : N :
                        x.d[n] => _y.d[n]-
                    )
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    xi<2*width> & _y.a<2*width> -> _xo-
                    ~xi<1.5*width> | ~_y.a<1.5*width> -> _xo+
                    
                    ~_xo<1.5*width> -> xo+
                    _xo<width> -> xo-

                    (: n : N :
                        ~x.d[n]<1.5*width> -> _y.d[n]+
                        x.d[n]<width> -> _y.d[n]-
                    )
                }
            ]
        }

        namespace deserial_ring {
            export
            template <pint M, N, width>
            defproc SPLIT (globals g; a1of<N> _x, _y[M]) {
                bool ya[M];
                (; m : M :
                    _y[m].d = _x.d;
                    _y[m].a = ya[m]; // normal sense
                )
                OR<M, width> or(g,,);
                (; m : M :
                    ya[m] = or.i[m];
                )
                prs<g.Vdd, g.GND> {
                    ~or.o<1.5*width> -> _x.a+
                    or.o<width> -> _x.a-
                }
            }
            
            export
            template <pint N | pint width>
            defproc NODE (globals g; a1of<N> _x; c1of<N> y; bool _si, _so) {
                bool _vy, __vy, _s, __s;
                bool xa = _x.a; // normal sense
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _s => __s-

                        (: n : N :
                            ~__s & ~_si & ~_x.d[n] -> y.d[n]+
                            _si -> y.d[n]-
                        )
            
                        ~__s & ~_vy => xa+
            
                        _vy => __vy-

                        __vy & (& : n : N : _x.d[n]) -> _s-
                        ~g._pReset | ~__vy -> _s+
            
                        __s => _so-

                        (| : n : N : y.d[n]) => _vy-
                    }
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        ~_s<width> -> __s+
                        _s<width> -> __s-

                        (: n : N :
                            ~__s<width*3> & ~_si<width*3> & ~_x.d[n]<width*3> -> y.d[n]+
                            _si<width> -> y.d[n]-
                        )
            
                        ~__s<3*width> & ~_vy<3*width> -> xa+
                        __s<width> | _vy<width> -> xa-
            
                        ~_vy<1.5*width> -> __vy+
                        _vy<width> -> __vy-

                        __vy<width*5> & (& : n : N : _x.d[n]<width*5>) -> _s-
                        ~g._pReset<width> | ~__vy<1.5*width> -> _s+
            
                        ~__s<1.5*width> -> _so+
                        __s<width> -> _so-

                        (| : n : N : y.d[n]<width>) -> _vy-
                        (& : n : N : ~y.d[n]<5*width>) -> _vy+
                    }
                ]
            }
        } // namespace deserial_ring
        
        export
        template <pint M, N | pint width>
        defproc DESERIAL_RING (globals g; a1of<N> _x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with ring
            deserial_ring::SPLIT<M, N, width> split(g, _x,);
            deserial_ring::NODE<N, width> node[M];
            (; m : M :
                node[m].g = g;
                node[m]._x = split._y[m];
                node[m].y = y.m[m];
            )
            (; m : M-1 :
                node[m]._so = node[m+1]._si;
            )
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    g._sReset & node[M-1]._so & y.e  -> node[0]._si-
                    ~g._pReset | ~node[M-1]._so & ~y.e  -> node[0]._si+
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    g._sReset<3*width> & node[M-1]._so<3*width> & y.e<3*width>  -> node[0]._si-
                    ~g._pReset | ~node[M-1]._so<3*width> & ~y.e<3*width>  -> node[0]._si+
                }
            ]
        }

        namespace deserial_chain {
            export
            template <pint N>
            defproc HEAD (globals g; a1of<N> x; c1of<N> d; bool si, so) {
                // deserializer chain head link
                // parallel output word 0
                bool vd, _vd, _so;
                bool _xa;
                c1of<N> _d;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        si & x.d[n] -> _d.d[n]-
                        ~g._pReset | ~si -> _d.d[n]+

                        ~_d.d[n] -> d.d[n]+
                        _d.d[n] -> d.d[n]-
                    )
            
                    (& : n : N : ~x.d[n]) & ~_vd -> so+
                    (| : n : N : x.d[n]) | _vd -> so-

                    ~so -> _so+
                    so -> _so-

                    _so & vd -> _xa-
                    ~_so | ~vd -> _xa+
            
                    (| : n : N : ~_d.d[n]) -> vd+
                    (& : n : N : _d.d[n]) -> vd-

                    ~vd -> _vd+
                    vd -> _vd-
                }

                prs<g.Vdd, g.GND> {
                    ~_xa -> x.a+
                    _xa -> x.a-
                }
            }
            
            export
            template <pint N>
            defproc NODE (globals g; a1of<N> x, y; c1of<N> d; bool si, so) {
                // deserializer chain intermediate link
                // parallel output words 1 to M-2
                bool _xa, vd, _vd, _si, _so, ___so;
                c1of<N> _x;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~x.d[n] -> _x.d[n]+
                        x.d[n] -> _x.d[n]-
                    )

                    (: n : N :
                        ~si & ~_x.d[n] -> y.d[n]+
                        si | _x.d[n] -> y.d[n]-
                    )

                    ~si -> _si+
                    si -> _si-

                    (: n : N :
                        ~_si & ~_x.d[n] -> d.d[n]+
                        _si -> d.d[n]-
                    )

                    ~_vd -> vd+
                    _vd -> vd-

                    (& : n : N : _x.d[n]) & vd -> _so-
                    (| : n : N : ~_x.d[n]) | ~vd -> _so+

                    ~so -> ___so+
                    so -> ___so-

                    y.a | ___so & vd -> _xa-
                    ~y.a & (~___so | ~vd) ->_xa+
            
                    (| : n : N : d.d[n]) -> _vd-
                    (& : n : N : ~d.d[n]) -> _vd+
                }
                prs<g.Vdd, g.GND> {
                    ~_xa -> x.a+
                    _xa -> x.a-

                    ~_so -> so+
                    _so -> so-
                }

            }

            export
            template <pint N>
            defproc TAIL (globals g; a1of<N> _x, y; c1of<N> d; bool si) {
                // deserializer chain tail link
                // parallel output word M-1
                bool _si;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~si & ~_x.d[n] & ~d.d[n] -> y.d[n]+
                        si | _x.d[n] | d.d[n] -> y.d[n]-
                    )

                    ~si -> _si+
                    si -> _si-

                    (: n : N :
                        ~_si & ~_x.d[n] -> d.d[n]+
                        _si & _x.d[n] -> d.d[n]-
                    )
            
                    y.a | (| : n : N : d.d[n]) -> _x.a-
                    ~y.a & (& : n : N : ~d.d[n]) -> _x.a+
                }
            }
        } // namespace deserial_chain

        export
        template <pint M, N | pint width>
        defproc DESERIAL_CHAIN (globals g; a1of<N> _x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with chain
            [ M = 1 ->
                _x.a = y.e;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_x.m.n[n] -> y.m[0].n[n]+
                        _x.m.n[n] -> y.m[0].n[n]-
                    )
                }
            [] M > 1 ->
                deserial_chain::HEAD<N> head(g,, y.m[0], y.e,);
                deserial_chain::TAIL<N> tail(g, _x,, y.m[M-1],);
            ]

            [ M = 2 ->
                head.x = tail.y;
                head.so = tail.si;
            [] M > 2 ->
                pint MM = M-2;
                deserial_chain::NODE<N> node[MM];
                (; mm : MM :
                    node[mm].g = g;
                    node[mm].d = y.m[mm+1];
                )
                node[0].y = head.x;
                node[0].si = head.so;
                node[MM-1].x = tail.y;
                node[MM-1].so = tail.si;
                (; mm : MM-1 :
                    node[mm].x = node[mm+1].y;
                    node[mm].so = node[mm+1].si;
                )
            ]
        }

        namespace serial_chain {
            export
            template <pint N>
            defproc NODE (globals g; e1of<N> x, y; c1of<N> d) {
                bool u, _u, __u, _vy, _vd, _xe;
                c1of<N> _y;
                c1of<N> __y = y.m;
                prs<g.Vdd, g.GND> {
                    ~u -> _u+
                    u -> _u-

                    (: n : N :
                        y.e & _u & d.d[n] | x.d[n] -> _y.d[n]-
                        g.pReset | ~y.e & ~_u & ~x.d[n] -> _y.d[n]+
                    )

                    (: n : N :
                        ~_y.d[n] -> __y.d[n]+
                        _y.d[n] -> __y.d[n]-
                    )

                    (| : n : N : __y.d[n]) -> _vy-
                    (& : n : N : ~__y.d[n]) -> _vy+

                    (| : n : N : d.d[n]) -> _vd-
                    (& : n : N : ~d.d[n]) -> _vd+

                    ~_vy & ~_vd -> u+
                    g.pReset | _vy & _vd -> u-

                    ~_u -> __u+
                    _u -> __u-

                    y.e & __u & _vy -> _xe-
                    ~y.e & (~__u | ~_vy) -> _xe+
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )

                    ~_xe -> x.e+
                    _xe -> x.e-
                }
            }

            export
            template <pint N>
            defproc TAIL (globals g; bool xe; e1of<N> y; c1of<N> d) {
                bool u, _u, __u, vy, _vy, _vd, _xe;
                c1of<N> _y;
                prs<g.Vdd, g.GND> {
                    ~u -> _u+
                    u -> _u-

                    (: n : N :
                        y.e & _u & d.d[n] -> _y.d[n]-
                        g.pReset | ~y.e & ~_u -> _y.d[n]+
                    )

                    (| : n : N : ~_y.d[n]) -> vy+
                    (& : n : N : _y.d[n]) -> vy-

                    (| : n : N : d.d[n]) -> _vd-
                    (& : n : N : ~d.d[n]) -> _vd+

                    ~vy -> _vy+
                    vy -> _vy-

                    ~_vy & ~_vd -> u+
                    ~g._pReset | _vy & _vd -> u-

                    ~_u -> __u+
                    _u -> __u-

                    y.e & __u & _vy -> _xe-
                    ~y.e & ~__u -> _xe+
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )

                    ~_xe -> xe+
                    _xe -> xe-
                }
            }
        } // namespace serial_chain

        export
        template <pint M, N | pint width>
        defproc SERIAL_CHAIN (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with chain
            [ M = 1 ->
                serial_chain::TAIL<N> tail(g,,, x.m[0]);
                tail.y.m = y;
                tail.y.e = yi;
            [] M > 1 ->
                pint MM = M-1;
                serial_chain::NODE<N> node[MM];
                serial_chain::TAIL<N> tail(g,, node[MM-1].x, x.m[M-1]);
                (; m : MM :
                    node[m].g = g;
                    node[m].d = x.m[m];
                )
                (; m : MM-1 :
                    node[m].x = node[m+1].y;
                )
                node[0].y.m = y;
                node[0].y.e = yi;
            ]
            bool s;
            s = yo;
            s = x.e;
            prs<g.Vdd, g.GND> {
                g.pReset | tail.xe & yi -> s-
                ~g.sReset & ~tail.xe & ~yi -> s+
            }
        }

        namespace serial_ring {
            export
            template <pint N>
            defproc NODE (globals g; c1of<N> x; e1of<N> y; bool si, so) {
                bool _u, _ye, __ye;
                c1of<N> _y;
                c1of<N> __y = y.m;
                prs<g.Vdd, g.GND> {
                    ~_ye -> __ye+
                    _ye -> __ye-

                    (: n : N :
                        _u & __ye & si & x.d[n] -> _y.d[n]-
                        g.pReset | ~_u & ~__ye -> _y.d[n]+
                    )

                    (: n : N :
                        ~_y.d[n] -> __y.d[n]+
                        _y.d[n] -> __y.d[n]-
                    )

                    ~y.e -> _ye+
                    y.e -> _ye-

                    (| : n : N : y.d[n]) & _ye -> _u-
                    ~si & (& : n : N : ~x.d[n]) -> _u+

                    ~_u & (& : n : N : ~y.d[n]) -> so+
                    _u | (| : n : N : y.d[n]) -> so-
                }
            }

            export
            template <pint M, N>
            defproc MERGE (globals g; e1of<N> x[M], y) {
                OR<M> or[N];
                (; n : N :
                    or[n].g = g;
                    or[n].o = y.d[n];
                    (; m : M :
                        or[n].i[m] = x[m].d[n];
                    )
                )
                (; m : M :
                    x[m].e = y.e;
                )
            }
        } // namespace serial_ring

        export
        template <pint M, N | pint width>
        defproc SERIAL_RING (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            serial_ring::NODE<N> node[M];
            serial_ring::MERGE<M, N> merge(g,,);
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[m];
                node[m].y = merge.x[m];
            )
            merge.y.m = y;
            merge.y.e = yi;
            (; m : M-1:
                node[m].so = node[m+1].si;
            )
            bool s; 
            x.e = s;
            yo = s;
            node[0].si = s;
            prs<g.Vdd, g.GND> {
                g.pReset | node[M-1].so & yi -> s-
                ~g.sReset & ~node[M-1].so & ~yi -> s+
            }
        }

        namespace serial_ring2 {
            export
            template <pint N>
            defproc NODE (globals g; c1of<N> x; av1of<N> y; bool si, so) {
                bool u;
                bool _yv = y.v;
                c1of<N> _y;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        si & x.d[n] & u -> _y.d[n]-
                        ~si | ~x.d[n] | ~u -> _y.d[n]+
                    ) 

                    si & (| : n : N : x.d[n]) & u -> _yv-
                    ~si | (& : n : N : ~x.d[n]) | ~u -> _yv+

                    ~si & (& : n : N : ~x.d[n]) -> u+
                    y.a -> u-

                    ~u & ~y.a -> so+
                    u | y.a -> so-
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )
                }
            }

            export
            template <pint M, N>
            defproc MERGE (globals g; av1of<N> x[M]; c1of<N> y; bool yi, si, so) {
                prs<g.Vdd, g.GND> {
                    ~g.sReset & ~yi & ~si -> so+
                    g.pReset | yi & si -> so-
                }

                c1of<N> u;
                OR<M> or[N];
                (; n : N :
                    or[n].g = g;
                    (; m : M :
                        or[n].i[m] = x[m].d[n];
                    )
                    or[n].o = u.d[n];
                )
                c1of<N> _y;
                bool _vy, _xv[M];
                (; m : M :
                    _xv[m] = x[m].v;
                )
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        u.d[n] & yi -> _y.d[n]-
                        ~u.d[n] -> _y.d[n]+
                    )

                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) -> _vy-
                    (& : n : N : ~y.d[n]) -> _vy+

                    (: m : M :
                        ~_xv[m] & ~yi & ~_vy -> x[m].a+
                        _xv[m] & _vy -> x[m].a-
                    )
                }
            }
        } // namespace serial_ring2

        export
        template <pint M, N | pint width>
        defproc SERIAL_RING2 (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            serial_ring2::NODE<N> node[M];
            serial_ring2::MERGE<M, N> merge(g,,y, yi, node[M-1].so,);
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[m];
                node[m].y = merge.x[m];
            )
            merge.y = y;
            (; m : M-1:
                node[m].so = node[m+1].si;
            )
            merge.so = x.e;
            merge.so = node[0].si;
            merge.so = yo; 
        }

        namespace test {
            export
            template <pint M, N>
            defproc TEST_DESERIAL_RING(globals g) {
                SOURCE_random_a1ofN<N> src(g,);
                SINK_eMx1ofN<M, N> snk(g,);
                a1of<N> _d;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~src.d.d[n] -> _d.d[n]+
                        src.d.d[n] -> _d.d[n]-
                    )
                    ~_d.a -> src.d.a+
                    _d.a -> src.d.a-
                }
                DESERIAL_RING<M, N> deserial(g, _d, snk.d);
            }

            export
            template <pint M, N>
            defproc TEST_DESERIAL_CHAIN(globals g) {
                SOURCE_random_a1ofN<N> src(g,);
                SINK_eMx1ofN<M, N> snk(g,);
                a1of<N> _d;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~src.d.d[n] -> _d.d[n]+
                        src.d.d[n] -> _d.d[n]-
                    )
                    ~_d.a -> src.d.a+
                    _d.a -> src.d.a-
                }
                DESERIAL_CHAIN<M, N> deserial(g, _d, snk.d);
            }
        } // namespace test
    }

    namespace transmitter {
        template <pint N, root | pint width>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; c1of<N> _c[N], _p) {
            // AEXT tree NODE controller
            /*--------------------------------------------------------------*/
            // /* development
                bool c_[N], _co[N], _po, u, _u;
                c1of<N> _w, p;
                ::arbiter::n_arb_s::N_ARB<N, width> arb(g, ci, c_);

                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u & (| : n : N : c_[n]) -> _po-
                        ~g._pReset | (| : n : N : ~_co[n] & ~c_[n]) -> _po+

                        _po => po-
                    
                        (: n : N :
                            c_[n] & pi & _u -> _w.d[n]-
                            ~g._pReset | ~_u -> _w.d[n]+
                        )

                        (| : n : N : ~_w.d[n]) & ~pi -> u+
                        (& : n : N : _co[n]) & _po -> u-

                        u => _u-
                        
                        c_[0] & u & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                        (: n : 1..N-2:
                            c_[n] & u & pi & 
                                (& : nn : 0..n-1 : _co[nn]) & 
                                (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                        )
                        c_[N-1] & u & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                        (: n : N :
                            ~pi -> _co[n]+

                            _co[n] => co[n]-
                        )

                        (: n : N :
                            (| : nc : N : ~_c[nc].d[n]) | ~_w.d[n] => p.d[n]+
                        )
                    }

                    [ root = 0 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                p.d[n] => _p.d[n]-
                            )
                        }
                    [] root = 1 ->
                        p = _p;
                    ]
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u<2*width> & (| : n : N : c_[n]<2*width>) -> _po-
                        ~g._pReset<width> | (| : n : N : ~_co[n]<3*width> & ~c_[n]<3*width>) -> _po+

                        ~_po<1.5*width> -> po+
                        _po<width> -> po-
                    
                        (: n : N :
                            c_[n]<3*width> & pi<3*width> & _u<3*width> -> _w.d[n]-
                            ~g._pReset<width> | ~_u<1.5*width> -> _w.d[n]+
                        )

                        (| : n : N : ~_w.d[n]<3*width>) & ~pi<3*width> -> u+
                        (& : n : N : _co[n]<5*width>) & _po<5*width> -> u-

                        ~u<1.5*width> -> _u+
                        u<width> -> _u-
                        
                        c_[0]<6*width> & u<6*width> & pi<6*width> & 
                            (& : n : 1..N-1 : _co[n]<6*width>) -> _co[0]-
                        (: n : 1..N-2:
                            c_[n]<6*width> & u<6*width> & pi<6*width> & 
                                (& : nn : 0..n-1 : _co[nn]<6*width>) & 
                                (& : nn : n+1..N-1 : _co[nn]<6*width>) -> _co[n]-
                        )
                        c_[N-1]<6*width> & u<6*width> & pi<6*width> &
                            (& : n : 0..N-2 : _co[n]<6*width>) -> _co[N-1]-
                        (: n : N :
                            ~pi<1.5*width> -> _co[n]+

                            ~_co[n]<1.5*width> -> co[n]+
                            _co[n]<width> -> co[n]-
                        )

                        (: n : N :
                            (| : nc : N : ~_c[nc].d[n]<1.5*width>) | ~_w.d[n]<1.5*width> -> p.d[n]+
                            (& : nc : N : _c[nc].d[n]<5*width>) & _w.d[n]<5*width> -> p.d[n]-
                        )
                    }

                    [ root = 0 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                ~p.d[n]<1.5*width> -> _p.d[n]+
                                p.d[n]<width> -> _p.d[n]-
                            )
                        }
                    [] root = 1 ->
                        p = _p;
                    ]
                ]

            // */
            /*--------------------------------------------------------------*/
            /* reference
                bool c_[N], q[N], u;
                c1of<N> w;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    c_[0] & ~co[1] -> q[0]+
                    g.pReset | ~c_[0] & co[0] -> q[0]-
                    c_[1] & ~co[0] -> q[1]+
                    g.pReset | ~c_[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: nc : N :
                        q[nc] & u & pi -> co[nc]+
                        (~u | (| : n : N : p.d[n])) & ~pi -> co[nc]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            */
            /*--------------------------------------------------------------*/
        }

        template <pint N, root | pint width>
        defproc LEAF (globals g; bool ci[N], co[N], pi, po; c1of<N> _p) {
            // leaf node of aext tree
            /*--------------------------------------------------------------*/
            // /* development
                bool c[N], _co[N], _u, u, _po;
                c1of<N> _p_;
                ::arbiter::n_arb_s::N_ARB<N, width> arb(g, ci, c);

                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u & (| : n : N : c[n]) -> _po-
                        ~g._pReset | (| : n : N : ~_co[n] & ~c[n]) -> _po+

                        _po => po-
                    
                        (: n : N :
                            c[n] & pi & _u -> _p_.d[n]-
                            ~g._pReset | ~_u -> _p_.d[n]+
                        )

                        (| : n : N : ~_p_.d[n]) & ~pi -> u+
                        (& : n : N : _co[n]) & _po -> u-

                        ~u -> _u+
                        u -> _u-
                        
                        c[0] & u & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                        (: n : 1..N-2:
                            c[n] & u & pi & 
                            (& : nn : 0..n-1 : _co[nn]) & 
                            (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                        )
                        c[N-1] & u & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                        (: n : N :
                            ~pi -> _co[n]+

                            ~_co[n] -> co[n]+
                            _co[n] -> co[n]-
                        )
                    }

                    [ root = 0 ->
                        _p_ = _p;
                    [] root = 1 ->
                        // present normal sense interface
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                ~_p_.d[n] -> _p.d[n]+
                                _p_.d[n] -> _p.d[n]-
                            )
                        }
                    ]
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u<5*width> & (| : n : N : c[n]<5*width>) -> _po-
                        ~g._pReset<width> | (| : n : N : ~_co[n]<3*width> &
                            ~c[n]<3*width>) -> _po+

                        ~_po<1.5*width> -> po+
                        _po<width> -> po-
                    
                        (: n : N :
                            c[n]<3*width> & pi<3*width> & _u<3*width> -> _p_.d[n]-
                            ~g._pReset<width> | ~_u<1.5*width> -> _p_.d[n]+
                        )

                        (| : n : N : ~_p_.d[n]<3*width>) & ~pi<3*width> -> u+
                        (& : n : N : _co[n]<5*width>) & _po<5*width> -> u-

                        ~u<1.5*width> -> _u+
                        u<width> -> _u-
                        
                        c[0]<6*width> & u<6*width> & pi<6*width> &
                            (& : n : 1..N-1 : _co[n]<6*width>) -> _co[0]-
                        (: n : 1..N-2:
                            c[n]<6*width> & u<6*width> & pi<6*width> & 
                            (& : nn : 0..n-1 : _co[nn]<6*width>) & 
                            (& : nn : n+1..N-1 : _co[nn]<6*width>) -> _co[n]-
                        )
                        c[N-1]<6*width> & u<6*width> & pi<6*width> &
                            (& : n : 0..N-2 : _co[n]<6*width>) -> _co[N-1]-
                        (: n : N :
                            ~pi<1.5*width> -> _co[n]+

                            ~_co[n]<1.5*width> -> co[n]+
                            _co[n]<width> -> co[n]-
                        )
                    }

                    [ root = 0 ->
                        _p_ = _p;
                    [] root = 1 ->
                        // present normal sense interface
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                ~_p_.d[n]<1.5*width> -> _p.d[n]+
                                _p_.d[n]<width> -> _p.d[n]-
                            )
                        }
                    ]
                ]
            // */
            /*--------------------------------------------------------------*/
            /* reference
                bool c[N], q[N], u;
                ::arbiter::n_arb_s::N_ARB<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    c[0] & ~co[1] -> q[0]+
                    g.pReset | ~c[0] & co[0] -> q[0]-
                    c[1] & ~co[0] -> q[1]+
                    g.pReset | ~c[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-
                
                    (: n : N :
                        q[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    ~po -> u-
                    
                    (: n : N :
                        q[n] & u & pi -> co[n]+
                        ~u & ~pi -> co[n]-
                    )
                }
            */
        }

        template <pint M, N, NN, root, width>
        defproc AEXT_ (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
            // utility for AEXT
            [ M = 0 ->
                0 = 1;
            [] M = 1 ->
                NN = N;
                LEAF<N, root, width> leaf(g, xi, xo, pi, po, p);
            [] M > 1 ->
                pint k = NN/N;
                AEXT_<M-1, N, k, 0, width> _[N];
                (; n : N :
                    _[n].g = g;
                    _[n].xi = xi[n*k..(n+1)*k-1];
                    _[n].xo = xo[n*k..(n+1)*k-1];
                )

                NODE<N, root, width> node(g,,, pi, po,, p);
                (; n : N :
                    node.ci[n] = _[n].po;
                    node.co[n] = _[n].pi;
                    node._c[n] = _[n].p;
                )
            ]
        }

        export
        template <pint M, N, NN, width>
        defproc AEXT (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
            // Transmitter
            AEXT_<M, N, NN, 1, width> _(g, xi, xo, pi, po, p);
        }

        namespace test {
            export
            template <pint M, N, NN>
            defproc TEST_AEXT (globals g) {
                // M layers in the tree
                // N for 1-of-N encoding
                // NN = N^M neurons
                active_handshaker<NN> a(g,,);
                AEXT<M, N, NN, 1> aext(g, a.o, a.i,,,);
                ::aer::interface::OUT_a1ofN<N, 1> out(g, aext.po, aext.pi, aext.p,);
                ::aer::interface::DESERIAL_RING<M, N, 1> deserial(
                    g, out._y,);
                // ::aer::interface::DESERIAL_CHAIN<M, N, 1> deserial(
                //     g, out._y,);
                SINK_eMx1ofN<M, N, 1> snk(g, deserial.y);
            }

            export
            template <pint M, N, NN, nn>
            defproc TEST_AEXT1 (globals g) {
                // M layers in the tree
                // N for 1-of-N encoding
                // NN = N^M neurons
                active_handshaker<1> a(g,,);
                AEXT<M, N, NN, 1> aext(g,,,,,);
                ::aer::interface::OUT_a1ofN<N, 1> out(g, aext.po, aext.pi, aext.p,);
                ::aer::interface::DESERIAL_CHAIN<M, N, 1> deserial(
                    g, out._y,);
                SINK_eMx1ofN<M, N, 1> snk(g, deserial.y);

                a.o[0] = aext.xi[nn];
                a.i[0] = aext.xo[nn];
                [ nn > 0 ->
                    (; idx : 0..nn-1 :
                        aext.xi[idx] = g.GND;
                    )
                ]
                [ nn < NN ->
                    (; idx : nn+1..NN-1 :
                        aext.xi[idx] = g.GND;
                    )
                ]
            }
        } // namespace test
    } // namespace transmitter

    namespace receiver {
        template <pint N | pint width>
        defproc NODE (globals g; bool pi, po, ci[N], co[N]; c1of<N> p, c[N]) {
            // node in AERV tree
            bool _po, u[N], _co[N], cco, _cco, __cco, _cci, __cci, _uu;
            c1of<N> _p;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    _cci => __cci-

                    cco => _cco-

                    (pi & _cco | __cci) & _uu => _po-

                    (: n : N :
                        p.d[n] => _p.d[n]-
                    )

                    _cco => __cco-

                    (: n : N :
                        ~_p.d[n] & ~__cco -> u[n]+
                        g.pReset | __cco -> u[n]-
                    )

                    (| : n : N : u[n]) => _uu-

                    (: n : N :
                        u[n] & _p.d[n] -> _co[n]-
                        ~pi -> _co[n]+
                    )

                    (& : n : N : _co[n]) => cco-

                    (| : n : N : ci[n]) => _cci-

                    (: nc : N :
                        (: n : N :
                            ~_co[nc] & ~_p.d[n] => c[nc].d[n]+
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        _co[n] => co[n]-
                    )

                    _po => po-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~_cci<1.5*width> -> __cci+
                    _cci<width> -> __cci-

                    ~cco<1.5*width> -> _cco+
                    cco<width> -> _cco-

                    (pi<width> & _cco<width> | __cci<width>) & _uu<width> -> _po-
                    (~pi<width> | ~_cco<width>) & ~__cci<width> | ~_uu<width> -> _po+

                    (: n : N :
                        ~p.d[n]<1.5*width> -> _p.d[n]+
                        p.d[n]<width> -> _p.d[n]-
                    )

                    ~_cco<1.5*width> -> __cco+
                    _cco<width> -> __cco-

                    (: n : N :
                        ~_p.d[n]<width> & ~__cco<width> -> u[n]+
                        g.pReset<width> | __cco<width> -> u[n]-
                    )

                    (| : n : N : u[n]<width>) -> _uu-
                    (& : n : N : ~u[n]<1.5*width>) -> _uu+

                    (: n : N :
                        u[n]<2*width> & _p.d[n]<2*width> -> _co[n]-
                        ~pi<width> -> _co[n]+
                    )

                    (| : n : N : ~_co[n]<1.5*width>) -> cco+
                    (& : n : N : _co[n]<4*width>) -> cco-

                    (| : n : N : ci[n]<width>) -> _cci-
                    (& : n : N : ~ci[n]<6*width>) -> _cci+

                    (: nc : N :
                        (: n : N :
                            ~_co[nc]<3*width> & ~_p.d[n]<3*width> -> c[nc].d[n]+
                            _co[nc]<width> | _p.d[n]<width> -> c[nc].d[n]-
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_co[n]<1.5*width> -> co[n]+
                        _co[n]<width> -> co[n]-
                    )

                    ~_po<1.5*width> -> po+
                    _po<width> -> po-
                }
            ]
        }

        template <pint N | pint width>
        defproc LEAF (globals g; bool pi, po, ci[N]; c1of<N> p, c[N]) {
            // leaf of AERV tree
            bool _pi, _u[N], co[N], _cco, _cci, __cci, uu;
            c1of<N> _c[N];
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    pi => _pi-
    
                    _cci => __cci-
    
                    (~_pi | ~_cco) & ~uu & ~__cci => po+
    
                    (: n : N :
                        _cco & p.d[n] -> _u[n]-
                        ~g._pReset | ~_cco -> _u[n]+
                    )
                    (& : n : N : _u[n]) => uu-
    
                    (: n : N :
                        ~_u[n] & ~p.d[n] -> co[n]+
                        ~pi -> co[n]-
                    )
                    (| : n : N : co[n]) => _cco-
    
                    (| : n : N : ci[n]) => _cci-
    
                    (: nc : N :
                        (: n : N :
                            co[nc] & p.d[n] => _c[nc].d[n]-
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: nc : N :
                        (: n : N :
                            _c[nc].d[n] => c[nc].d[n]-
                        )
                    )
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~pi<1.5*width> -> _pi+
                    pi<width> -> _pi-
    
                    ~_cci<1.5*width> -> __cci+
                    _cci<width> -> __cci-
    
                    (~_pi<4.5*width> | ~_cco<4.5*width>) & ~uu<4.5*width> & ~__cci<4.5*width> -> po+
                    _pi<2*width> & _cco<2*width> | uu<width> | __cci<width> -> po-
    
                    (: n : N :
                        _cco<2*width> & p.d[n]<2*width> -> _u[n]-
                        ~g._pReset<width> | ~_cco<1.5*width> -> _u[n]+
                    )
                    (| : n : N : ~_u[n]<1.5*width>) -> uu+
                    (& : n : N : _u[n]<4*width>) -> uu-
    
                    (: n : N :
                        ~_u[n]<3*width> & ~p.d[n]<3*width> -> co[n]+
                        ~pi<width> -> co[n]-
                    )
                    (| : n : N : co[n]<width>) -> _cco-
                    (& : n : N : ~co[n]<1.5*width>) -> _cco+
    
                    (| : n : N : ci[n]<width>) -> _cci-
                    (& : n : N : ~ci[n]<1.5*width>) -> _cci+
    
                    (: nc : N :
                        (: n : N :
                            co[nc]<2*width> & p.d[n]<2*width> -> _c[nc].d[n]-
                            ~co[nc]<1.5*width> | ~p.d[n]<1.5*width> -> _c[nc].d[n]+
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: nc : N :
                        (: n : N :
                            _c[nc].d[n]<width> -> c[nc].d[n]-
                            ~_c[nc].d[n]<1.5*width> -> c[nc].d[n]+
                        )
                    )
                }
            ]
        }

        template <pint N | pint width>
        defproc LEAF_NODATA (globals g; bool pi, po, ci[N], co[N]; c1of<N> p) {
            // leaf of AERV tree that does not transmit data
            bool u, _po, _ci[N], _co[N];
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ci[n] => _ci[n]-
                    )

                    pi & (& : n : N : _ci[n]) | u => _po-

                    (: n : N :
                        p.d[n] -> _co[n]-
                        ~pi -> _co[n]+
                    )

                    (| : n : N : ~_ci[n] & ~p.d[n]) => u+
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        _co[n] => co[n]-
                    )
                    
                    _po => po-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~ci[n]<1.5*width> -> _ci[n]+
                        ci[n]<width> -> _ci[n]-
                    )

                    pi<5*width> & (& : n : N : _ci[n]<5*width>) | u<width> -> _po-
                    (~pi<3*width> | (| : n : N : ~_ci[n]<3*width>)) & ~u<3*width> -> _po+

                    (: n : N :
                        p.d[n]<width> -> _co[n]-
                        ~pi<1.5*width> -> _co[n]+
                    )

                    (| : n : N : ~_ci[n]<3*width> & ~p.d[n]<3*width>) -> u+
                    (& : n : N : _ci[n]<4*width> | p.d[n]<4*width>) -> u-
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_co[n]<1.5*width> -> co[n]+
                        _co[n]<width> -> co[n]-
                    )

                    ~_po<1.5*width> -> po+
                    _po<width> -> po-
                }
            ]
        }

        export
        template <pint M, N, NN, width>
        defproc AERV_NODATA (globals g; bool yi[NN], yo[NN], pi, po; c1of<N> p) {
            // receiver that does not send data to neurons
            [ M = 1 ->
                NN = N;
                LEAF_NODATA<N, width> leaf(g, pi, po, yi, yo, p);
            [] M > 1 ->
                AERV_NODATA<M-1, N, NN/N, width> _[N];
                NODE<N, width> node(g, pi, po,,, p,);
                pint k = NN/N;
                (; n : N :
                    _[n].g = g;
                    _[n].p = node.c[n];
                    _[n].pi = node.co[n];
                    _[n].po = node.ci[n];
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].yo = yo[n*k..(n+1)*k-1];
                )
            ]
        }

        export
        template <pint M, N, NN, width>
        defproc AERV_DATA (globals g; bool yi[NN], pi, po; c1of<N> p, c[NN]) {
            // receiver capable of sending data to neuron
            [ M = 1 ->
                NN = N;
                LEAF<N, width> leaf(g, pi, po, yi, p, c);
            [] M > 1 ->
                AERV_DATA<M-1, N, NN/N, width> _[N];
                NODE<N, width> node(g, pi, po,,, p,);
                pint k = NN/N;
                (; n : N :
                    _[n].g = g;
                    _[n].p = node.c[n];
                    _[n].pi = node.co[n];
                    _[n].po = node.ci[n];
                    _[n].yi = yi[n*k..(n+1)*k-1];
                    _[n].c = c[n*k..(n+1)*k-1];
                )
            ]
        }

        namespace test {
            export
            template <pint M, N, NN>
            defproc TEST_SERIAL_RING (globals g) {
                SOURCE_random_eMx1ofN<M, N> src(g,);
                ::aer::interface::SERIAL_RING<M, N, 1> serial(g, src.d,,,);
                AERV_NODATA<M, N, NN, 1> aerv(g,,, serial.yo, serial.yi, serial.y);
                passive_handshaker<NN> y(aerv.yo, aerv.yi);
            }

            export
            template <pint M, N, NN>
            defproc TEST_SERIAL_RING2 (globals g) {
                SOURCE_random_eMx1ofN<M, N> src(g,);
                ::aer::interface::SERIAL_RING2<M, N> serial(g, src.d,,,);
                AERV_NODATA<M, N, NN, 1> aerv(g,,, serial.yo, serial.yi, serial.y);
                passive_handshaker<NN> y(aerv.yo, aerv.yi);
            }

            export
            template <pint M, N, NN>
            defproc TEST_SERIAL_CHAIN (globals g) {
                SOURCE_random_eMx1ofN<M, N> src(g,);
                ::aer::interface::SERIAL_CHAIN<M, N, 1> serial(g, src.d,,,);
                AERV_NODATA<M, N, NN, 1> aerv(g,,, serial.yo, serial.yi, serial.y);
                passive_handshaker<NN> y(aerv.yo, aerv.yi);
            }
        } // namespace test
    } // namespace receiver

    export
    template <pint M, N, NN, width>
    defproc AER_NODATA (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // no data sent to receiving neuron
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        transmitter::AEXT<M, N, NN, width> aext(g, xi, xo,,,);
        interface::OUT_a1ofN<N, width> out(g, aext.po, aext.pi, aext.p,);
        interface::DESERIAL_RING<M, N, width> deserial(g, out._y,);
        // interface::DESERIAL_CHAIN<M, N, width> deserial(g, out._y,);
        interface::SERIAL_CHAIN<M, N> serial(g, deserial.y,,,);
        receiver::AERV_NODATA<M, N, NN, width> aerv(g, yi, yo, serial.yo, serial.yi, serial.y);
    }

    export
    template <pint M_AEXT, M_AERV, N, NN_AEXT, NN_AERV>
    defproc AER_DATA (globals g; bool xi[NN_AEXT], xo[NN_AEXT], yi[NN_AERV], yo[NN_AERV]; c1of<N> y[NN_AERV]) {
        // address-event representation tranceiver
        // control and data sent to receiving neuron
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        // transmitter::AEXT<M_AEXT, N, NN_AEXT> aext(g, xi, xo,,,);
        // interface::OUT_a1ofN<N> out(g, aext.po, aext.pi, aext.p,);
        // interface::DESERIAL_CHAIN<M_AEXT, N> deserial(g, out._y,);
        // interface::SERIAL_RING2<M_AERV, N> serial(g, deserial.y,,,);
        // receiver::AERV_DATA<M_AERV, N, NN_AERV> aerv(g, yi, yo, serial.yo, serial.yi, serial.y);
    }

    namespace test {
        export
        template <pint M, N, NN>
        defproc TEST_AER1_NODATA (globals g) {
            // Tests AER with 1 neuron
            // M groups
            // N items per group
            // NN neuron ports. NN=N^M
            active_handshaker<1> x(g,,);
            active_handshaker<1> y(g,,);
            AER_NODATA<M, N, NN> aer(g,,,,);
            aer.xi[0] = x.o[0];
            aer.xo[0] = x.i[0];
            aer.yi[0] = y.o[0];
            aer.yo[0] = y.i[0];
            (; nn : 1..NN-1 :
                aer.xi[nn] = g.GND;
                aer.yi[nn] = g.GND;
            )
        }

        export
        template <pint M, N, NN>
        defproc TEST_AER_NODATA (globals g) {
            // M groups
            // N items per group
            // NN neurons. NN=N^M
            active_handshaker<NN> x(g,,);
            passive_handshaker<NN> y(,);
            AER_NODATA<M, N, NN, 1> aer(g, x.o, x.i, y.o, y.i);
        }

        template <pint N, NN>
        defproc AERV_NRN_FULL(bool i[NN], o[NN]; c1of<N> d[NN]) {
            prs {
                (: nn : NN :
                    i[nn] & (& : n : N : ~d[nn].d[n]) => o[nn]+
                )
            }
        }

        export
        template <pint M_AEXT, M_AERV, N, NN_AEXT, NN_AERV>
        defproc TEST_AER_DATA (globals g) {
            // M groups
            // N items per group
            // NN receiver neurons. NN=N^M
            // NN*M transmitter neurons generate data for receiver neurons
            active_handshaker<NN_AEXT> x(g,,);
            AERV_NRN_FULL<N, NN_AERV> y(,,);
            AER_DATA<M_AEXT, M_AERV, N, NN_AEXT, NN_AERV> aer(g, x.o, x.i, y.o, y.i, y.d);
        }
    } // namespace test
} // namespace aer
