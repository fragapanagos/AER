// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "globals.act";
import "channel.act";
import "arbiter.act";
import "logic.act";
import "comm.act";
import "environment.act";

namespace aer {
    namespace interface {
        export
        template <pint N>
        defproc OUT_e1ofN (globals g; bool xi, xo; c1of<N> x; e1of<N> y) {
            // convert AEXT/AERV serial protocol to standard e1ofN channel
            x.d = y.d;
            prs {
                xi & y.e => xo+
            }
        }

        export
        template <pint N | pint M>
        defproc OUT_a1ofN (globals g; bool xi, xo; c1of<N> x; a1of<N> _y) {
            // convert AEXT/AERV serial protocol to standard a1ofN channel
            bool _xo;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    xi & _y.a => _xo-
                    _xo => xo-
                    (: n : N :
                        x.d[n] => _y.d[n]-
                    )
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    xi<10> & _y.a<10> -> _xo-
                    ~xi<12> | ~_y.a<12> -> _xo+

                    ~_xo<18> -> xo+
                    _xo<15> -> xo-

                    (: n : N :
                        ~x.d[n]<9*M> -> _y.d[n]+
                        x.d[n]<6*M> -> _y.d[n]-
                    )
                }
            ]
        }

        namespace deserial_ring {
            export
            template <pint M, N>
            defproc SPLIT (globals g; a1of<N> x, y[M]) {
                // SPLIT with active high input
                (; m : M :
                    y[m].m = x.m;
                )
                OR<M> or(g,, x.a);
                (; m : M :
                    y[m].a = or.i[m];
                )
            }

            export
            template <pint M, N>
            defproc _SPLIT (globals g; a1of<N> _x, y[M]) {
                // SPLIT with active low input
                c1of<N> x;
                (; m : M :
                    y[m].m = x;
                )
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        (: n : N:
                            _x.d[n] => x.d[n]-
                        )
                    }
                    [ M = 1 ->
                        prs<g.Vdd, g.GND> {
                            y[0].a => _x.a-
                        }
                    [] M > 1 ->
                        OR<M> or(g,,);
                        (; m : M :
                            y[m].a = or.i[m];
                        )
                        prs<g.Vdd, g.GND> {
                            or.o => _x.a-
                        }
                    ]
                [] LAYOUT ->
                    [ M = 1 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N:
                                g.sReset | _x.d[n]<8> -> x.d[n]-
                                ~g.sReset<20> & ~_x.d[n]<20> -> x.d[n]+
                            )
                        }
                    [] M = 6 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N:
                                g.sReset | _x.d[n]<18> -> x.d[n]-
                                ~g.sReset<36> & ~_x.d[n]<36> -> x.d[n]+
                            )
                        }
                    [] ((M != 1) | (M != 6)) ->
                        prs<g.Vdd, g.GND> {
                            (: n : N:
                                g.sReset | _x.d[n]<6*M> -> x.d[n]-
                                ~g.sReset<9*M> & ~_x.d[n]<9*M> -> x.d[n]+
                            )
                        }
                    ]

                    OR<M> or(g,,);
                    (; m : M :
                        y[m].a = or.i[m];
                    )
                    prs<g.Vdd, g.GND> {
                        ~or.o<10> -> _x.a+
                        or.o<6> -> _x.a-
                    }
                ]
            }

            export
            template <pint N>
            defproc NODE (globals g; a1of<N> x; c1of<N> y; bool si, so) {
                bool s, _s, _vy;
                c1of<N> _y;
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        s => _s-

                        (: n : N :
                            _s & si & x.d[n] -> _y.d[n]-
                            ~si -> _y.d[n]+
                        )

                        ~so & ~_vy => x.a+

                        ~_vy & (& : n : N : ~x.d[n]) -> s+
                        g.pReset | _vy -> s-

                        ~_s => so+

                        (: n : N :
                            _y.d[n] => y.d[n]-
                        )

                        (| : n : N : y.d[n]) => _vy-
                    }
                [] LAYOUT ->
                    c1of<N> __y = y;
                    prs<g.Vdd, g.GND> {
                        ~s<12> -> _s+
                        s<9> -> _s-

                        (: n : N :
                            _s<15> & si<15> & x.d[n]<15> -> _y.d[n]-
                            ~si<18> -> _y.d[n]+
                        )

                        ~so<18> & ~_vy<18> -> x.a+
                        so<8> | _vy<8> -> x.a-

                        ~_vy<63> & (& : n : N : ~x.d[n]<63>) -> s+
                        g.pReset | _vy<14> -> s-

                        ~_s<12> -> so+
                        _s<6> -> so-

                        (: n : N :
                            ~_y.d[n]<14> -> __y.d[n]+
                            _y.d[n]<8> -> __y.d[n]-
                        )

                        (| : n : N : y.d[n]<12>) -> _vy-
                        (& : n : N : ~y.d[n]<48>) -> _vy+
                    }
                ]
            }
        } // namespace deserial_ring

        export
        template <pint M, N>
        defproc DESERIAL_RING (globals g; a1of<N> x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with ring
            // first word in input is highest order word in output
            deserial_ring::SPLIT<M, N> split(g, x,);
            deserial_ring::NODE<N> node[M];
            (; m : M :
                node[m].g = g;
                node[m].x = split.y[m];
                node[m].y = y.m[M-1-m];
            )

            (; m : M-1 :
                node[m].so = node[m+1].si;
            )
            bool _ye;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    y.e => _ye-
                    g.sReset | node[M-1].so & _ye  -> node[0].si-
                    ~g.sReset & ~node[M-1].so & ~_ye  -> node[0].si+
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~y.e<10> -> _ye+
                    y.e<6> -> _ye-
                    g.sReset | node[M-1].so<14> & _ye<14> -> node[0].si-
                    ~g.sReset<45> & ~_ye<45> & ~node[M-1].so<45> -> node[0].si+
                }
            ]
        }

        export
        template <pint M, N>
        defproc _DESERIAL_RING (globals g; a1of<N> _x; eMx1ofN<M, N> y) {
            // convert AEXT/AERV serial protocol to eMx1ofN with ring
            // first word in input is highest order word in output
            // active low input _x
            deserial_ring::_SPLIT<M, N> split(g, _x,);
            deserial_ring::NODE<N> node[M];
            (; m : M :
                node[m].g = g;
                node[m].x = split.y[m];
                node[m].y = y.m[M-1-m];
            )

            (; m : M-1 :
                node[m].so = node[m+1].si;
            )
            bool _ye;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    y.e => _ye-
                    g.sReset | node[M-1].so & _ye  -> node[0].si-
                    ~g.sReset & ~node[M-1].so & ~_ye  -> node[0].si+
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~y.e<10> -> _ye+
                    y.e<6> -> _ye-
                    g.sReset | node[M-1].so<14> & _ye<14> -> node[0].si-
                    ~g.sReset<45> & ~_ye<45> & ~node[M-1].so<45> -> node[0].si+
                }
            ]
        }

        namespace serial_chain {
            export
            template <pint N>
            defproc NODE (globals g; e1of<N> x, y; c1of<N> d) {
                bool u, _u, __u, _vy, _vd, _xe;
                c1of<N> _y;
                c1of<N> __y = y.m;
                prs<g.Vdd, g.GND> {
                    ~u -> _u+
                    u -> _u-

                    (: n : N :
                        y.e & _u & d.d[n] | x.d[n] -> _y.d[n]-
                        g.pReset | ~y.e & ~_u & ~x.d[n] -> _y.d[n]+
                    )

                    (: n : N :
                        ~_y.d[n] -> __y.d[n]+
                        _y.d[n] -> __y.d[n]-
                    )

                    (| : n : N : __y.d[n]) -> _vy-
                    (& : n : N : ~__y.d[n]) -> _vy+

                    (| : n : N : d.d[n]) -> _vd-
                    (& : n : N : ~d.d[n]) -> _vd+

                    ~_vy & ~_vd -> u+
                    g.pReset | _vy & _vd -> u-

                    ~_u -> __u+
                    _u -> __u-

                    y.e & __u & _vy -> _xe-
                    ~y.e & (~__u | ~_vy) -> _xe+
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )

                    ~_xe -> x.e+
                    _xe -> x.e-
                }
            }

            export
            template <pint N>
            defproc TAIL (globals g; bool xe; e1of<N> y; c1of<N> d) {
                bool u, _u, __u, vy, _vy, _vd, _xe;
                c1of<N> _y;
                prs<g.Vdd, g.GND> {
                    ~u -> _u+
                    u -> _u-

                    (: n : N :
                        y.e & _u & d.d[n] -> _y.d[n]-
                        g.pReset | ~y.e & ~_u -> _y.d[n]+
                    )

                    (| : n : N : ~_y.d[n]) -> vy+
                    (& : n : N : _y.d[n]) -> vy-

                    (| : n : N : d.d[n]) -> _vd-
                    (& : n : N : ~d.d[n]) -> _vd+

                    ~vy -> _vy+
                    vy -> _vy-

                    ~_vy & ~_vd -> u+
                    ~g._pReset | _vy & _vd -> u-

                    ~_u -> __u+
                    _u -> __u-

                    y.e & __u & _vy -> _xe-
                    ~y.e & ~__u -> _xe+
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )

                    ~_xe -> xe+
                    _xe -> xe-
                }
            }
        } // namespace serial_chain

        export
        template <pint M, N>
        defproc SERIAL_CHAIN (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with chain
            [ M = 1 ->
                serial_chain::TAIL<N> tail(g,,, x.m[0]);
                tail.y.m = y;
                tail.y.e = yi;
            [] M > 1 ->
                pint MM = M-1;
                serial_chain::NODE<N> node[MM];
                serial_chain::TAIL<N> tail(g,, node[MM-1].x, x.m[M-1]);
                (; m : MM :
                    node[m].g = g;
                    node[m].d = x.m[m];
                )
                (; m : MM-1 :
                    node[m].x = node[m+1].y;
                )
                node[0].y.m = y;
                node[0].y.e = yi;
            ]
            bool s;
            s = yo;
            s = x.e;
            prs<g.Vdd, g.GND> {
                g.sReset | tail.xe & yi -> s-
                ~g.sReset & ~tail.xe & ~yi -> s+
            }
        }

        namespace serial_ring {
            export
            template <pint N>
            defproc NODE (globals g; bool si, so; c1of<N> x; a1of<N> _y) {
                bool u, _u, __u, _si, _so;
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        u => _u-

                        (: n : N :
                            x.d[n] & _u & si -> _y.d[n]-
                            ~g._pReset | ~_u & ~so -> _y.d[n]+
                        )

                        si => _si-

                        ~_si & ~_y.a -> u+
                        g.pReset | _si -> u-

                        _u => __u-

                        __u & _y.a -> _so-
                        ~__u & (& : n : N : ~x.d[n]) -> _so+

                        _so => so-
                    }
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        ~u<18> -> _u+
                        u<12> -> _u-

                        (: n : N :
                            x.d[n]<18> & _u<18> & si<18> -> _y.d[n]-
                            ~g._pReset | ~_u<18> & ~so<18> -> _y.d[n]+
                        )

                        ~si<9> -> _si+
                        si<6> -> _si-

                        ~_si<18> & ~_y.a<18> -> u+
                        g.pReset | _si<6> -> u-

                        ~_u<12> -> __u+
                        _u<9> -> __u-

                        __u<12> & _y.a<12> -> _so-
                        ~__u<45> & (& : n : N : ~x.d[n]<45>) -> _so+

                        ~_so<9> -> so+
                        _so<6> -> so-
                    }
                ]
            }

            export
            template <pint N>
            defproc MERGE (globals g; bool si, so, yi, yo; a1of<N> x; c1of<N> y) {
                bool _yi, _yo, _si;
                c1of<N> _x;
                bool _xa = x.a; // active low
                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        yi => _yi-

                        (| : n : N : x.d[n]) -> _yo-
                        ~g._pReset | ~si & ~_yi -> _yo+

                        si => _si-

                        ~_si -> so+
                        _si & _yi & _yo -> so-

                        (: n : N :
                            x.d[n] => _x.d[n]-
                        )

                        (: n : N :
                            ~_yi & ~_x.d[n] -> y.d[n]+
                            _x.d[n] -> y.d[n]-
                        )

                        (| : n : N : y.d[n]) & _yi -> _xa-
                        ~g._pReset | ~_yi -> _xa+
                    }
                    prs<g.Vdd, g.GND> {
                        _yo => yo-
                    }
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        ~yi<18> -> _yi+
                        yi<12> -> _yi-

                        (| : n : N : x.d[n]<6>) -> _yo-
                        ~g._pReset | ~si<18> & ~_yi<18> -> _yo+

                        ~si<9> -> _si+
                        si<6> -> _si-

                        ~_si<9> -> so+
                        _si<18> & _yi<18> & _yo<18> -> so-

                        (: n : N :
                            ~x.d[n]<9> -> _x.d[n]+
                            x.d[n]<6> -> _x.d[n]-
                        )

                        (: n : N :
                            ~_yi<18> & ~_x.d[n]<18> -> y.d[n]+
                            _x.d[n]<6> -> y.d[n]-
                        )

                        (| : n : N : y.d[n]<12>) & _yi<12> -> _xa-
                        ~g._pReset | ~_yi<9> -> _xa+
                    }
                    prs<g.Vdd, g.GND> {
                        ~_yo<9> -> yo+
                        _yo<9> -> yo-
                    }
                ]
            }
        } // namespace serial_ring

        export
        template <pint M, N>
        defproc SERIAL_RING (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            // highest order in word in input is first word in output
            bool s = x.e;
            serial_ring::NODE<N> node[M];
            serial_ring::MERGE<N> merge(g, s, node[0].si, yi, yo,, y);
            c1of<N> _d;
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[M-1-m];
                node[m]._y.d = _d.d;
                node[m]._y.a = merge.x.a;
            )
            (; m : M-1 :
                node[m].so = node[m+1].si;
            )
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        _d.d[n] => merge.x.d[n]-
                    )
                    node[M-1].so => s-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_d.d[n]<9> -> merge.x.d[n]+
                        _d.d[n]<6> -> merge.x.d[n]-
                    )
                    ~node[M-1].so<9> -> s+
                    node[M-1].so<6> -> s-
                }
            ]
        }

        namespace serial_ring2 {
            export
            template <pint N>
            defproc NODE (globals g; c1of<N> x; av1of<N> y; bool si, so) {
                bool u;
                bool _yv = y.v;
                c1of<N> _y;
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        si & x.d[n] & u -> _y.d[n]-
                        ~si | ~x.d[n] | ~u -> _y.d[n]+
                    ) 

                    si & (| : n : N : x.d[n]) & u -> _yv-
                    ~si | (& : n : N : ~x.d[n]) | ~u -> _yv+

                    ~si & (& : n : N : ~x.d[n]) -> u+
                    y.a -> u-

                    ~u & ~y.a -> so+
                    u | y.a -> so-
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )
                }
            }

            export
            template <pint M, N>
            defproc MERGE (globals g; av1of<N> x[M]; c1of<N> y; bool yi, si, so) {
                prs<g.Vdd, g.GND> {
                    ~g.sReset & ~yi & ~si -> so+
                    g.sReset | yi & si -> so-
                }

                c1of<N> u;
                OR<M> or[N];
                (; n : N :
                    or[n].g = g;
                    (; m : M :
                        or[n].i[m] = x[m].d[n];
                    )
                    or[n].o = u.d[n];
                )
                c1of<N> _y;
                bool _vy, _xv[M];
                (; m : M :
                    _xv[m] = x[m].v;
                )
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        u.d[n] & yi -> _y.d[n]-
                        ~u.d[n] -> _y.d[n]+
                    )

                    (: n : N :
                        ~_y.d[n] -> y.d[n]+
                        _y.d[n] -> y.d[n]-
                    )

                    (| : n : N : y.d[n]) -> _vy-
                    (& : n : N : ~y.d[n]) -> _vy+

                    (: m : M :
                        ~_xv[m] & ~yi & ~_vy -> x[m].a+
                        _xv[m] & _vy -> x[m].a-
                    )
                }
            }
        } // namespace serial_ring2

        export
        template <pint M, N>
        defproc SERIAL_RING2 (globals g; eMx1ofN<M, N> x; bool yi, yo; c1of<N> y) {
            // convert eMx1ofN protocol to AEXT/AERV serial with ring
            serial_ring2::NODE<N> node[M];
            serial_ring2::MERGE<M, N> merge(g,,y, yi, node[M-1].so,);
            (; m : M :
                node[m].g = g;
                node[m].x = x.m[m];
                node[m].y = merge.x[m];
            )
            merge.y = y;
            (; m : M-1:
                node[m].so = node[m+1].si;
            )
            merge.so = x.e;
            merge.so = node[0].si;
            merge.so = yo; 
        }

        export
        template <pint M, N>
        defproc SERIAL_MERGE (globals g; bool xi[M], xo[M], yi, yo; c1of<N> x[M], y) {
            // merges aext/aerv protocol serial streams
            // M client streams to merge
            // N 1-of-N data
            ::arbiter::N_ARB_S_PREQ<M> arb_req(g, xi, xo, yi, yo);
            c1of<N> b;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        (| : m : M : x[m].d[n]) => b.d[n]-
                        b.d[n] => y.d[n]-
                    )
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        (| : m : M : x[m].d[n]<6>) -> b.d[n]-
                        (& : m : M : ~x[m].d[n]<12>) -> b.d[n]+
                        b.d[n]<6> -> y.d[n]-
                        ~b.d[n]<12> -> y.d[n]+
                    )
                }
            ]
        }
    }

    namespace transmitter {
        template <pint N, root>
        defproc NODE (globals g; bool ci[N], co[N], pi, po; c1of<N> _c[N], _p) {
            // AEXT tree NODE controller
            /*--------------------------------------------------------------*/
            // /* development
                bool c_[N], _co[N], _po, u, _u;
                c1of<N> _w, p;
                ::arbiter::N_ARB_S<N> arb(g, ci, c_);

                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u & (| : n : N : c_[n]) -> _po-
                        ~g._pReset | (| : n : N : ~_co[n] & ~c_[n]) -> _po+

                        _po => po-

                        (: n : N :
                            c_[n] & pi & _u -> _w.d[n]-
                            ~g._pReset | ~_u -> _w.d[n]+
                        )

                        ~pi & (| : n : N : ~_w.d[n]) -> u+
                        _po & (& : n : N : _co[n]) -> u-

                        u => _u-

                        c_[0] & u & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                        (: n : 1..N-2:
                            c_[n] & u & pi & 
                                (& : nn : 0..n-1 : _co[nn]) & 
                                (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                        )
                        c_[N-1] & u & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                        (: n : N :
                            ~pi -> _co[n]+

                            _co[n] => co[n]-
                        )

                        (: n : N :
                            (| : nc : N : ~_c[nc].d[n]) | ~_w.d[n] => p.d[n]+
                        )
                    }

                    [ root = 0 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                p.d[n] => _p.d[n]-
                            )
                        }
                    [] root = 1 ->
                        p = _p;
                    ]
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u<26> & (| : n : N : c_[n]<26>) -> _po-
                        ~g._pReset | (| : n : N : ~_co[n]<40> & ~c_[n]<40>) -> _po+

                        ~_po<12> -> po+
                        _po<8> -> po-

                        (: n : N :
                            c_[n]<20> & pi<20> & _u<20> -> _w.d[n]-
                            ~g._pReset | ~_u<16> -> _w.d[n]+
                        )

                        ~pi<40> & (| : n : N : ~_w.d[n]<40>) -> u+
                        _po<40> & (& : n : N : _co[n]<40>) -> u-

                        ~u<15> -> _u+
                        u<9> -> _u-

                        c_[0]<48> & u<48> & pi<48> & 
                            (& : n : 1..N-1 : _co[n]<48>) -> _co[0]-
                        (: n : 1..N-2:
                            c_[n]<48> & u<48> & pi<48> & 
                                (& : nn : 0..n-1 : _co[nn]<48>) & 
                                (& : nn : n+1..N-1 : _co[nn]<48>) -> _co[n]-
                        )
                        c_[N-1]<48> & u<48> & pi<48> &
                            (& : n : 0..N-2 : _co[n]<48>) -> _co[N-1]-
                        (: n : N :
                            ~pi<27> -> _co[n]+

                            ~_co[n]<20> -> co[n]+
                            _co[n]<12> -> co[n]-
                        )

                        (: n : N :
                            (| : nc : N : ~_c[nc].d[n]<18>) | ~_w.d[n]<18> -> p.d[n]+
                            (& : nc : N : _c[nc].d[n]<30>) & _w.d[n]<30> -> p.d[n]-
                        )
                    }

                    [ root = 0 ->
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                ~p.d[n]<12> -> _p.d[n]+
                                p.d[n]<6> -> _p.d[n]-
                            )
                        }
                    [] root = 1 ->
                        p = _p;
                    ]
                ]
            // */
            /*--------------------------------------------------------------*/
            /* reference
                bool c_[N], q[N], u;
                c1of<N> w;
                ::arbiter::N_ARB_S<N> arb(g, ci, c_);

                prs<g.Vdd, g.GND> {
                    c_[0] & ~co[1] -> q[0]+
                    g.pReset | ~c_[0] & co[0] -> q[0]-
                    c_[1] & ~co[0] -> q[1]+
                    g.pReset | ~c_[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-

                    (: n : N :
                        q[n] & pi & ~u -> w.d[n]+
                        g.pReset | u -> w.d[n]-
                    )

                    (| : n : N : w.d[n]) & ~pi -> u+
                    ~po -> u-

                    (: nc : N :
                        q[nc] & u & pi -> co[nc]+
                        (~u | (| : n : N : p.d[n])) & ~pi -> co[nc]-
                    )

                    (: n : N :
                        (| : nc : N : c[nc].d[n]) | w.d[n] => p.d[n]+
                    )
                }
            */
            /*--------------------------------------------------------------*/
        }

        export
        template <pint N, root>
        defproc LEAF (globals g; bool ci[N], co[N], pi, po; c1of<N> _p) {
            // leaf node of aext tree
            /*--------------------------------------------------------------*/
            // /* development
                bool c[N], _co[N], _u, u, _po;
                c1of<N> _p_;
                ::arbiter::N_ARB_S<N> arb(g, ci, c);

                [ ~LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u & (| : n : N : c[n]) -> _po-
                        ~g._pReset | (| : n : N : ~_co[n] & ~c[n]) -> _po+

                        _po => po-

                        (: n : N :
                            c[n] & pi & _u -> _p_.d[n]-
                            ~g._pReset | ~_u -> _p_.d[n]+
                        )

                        ~pi & (| : n : N : ~_p_.d[n]) -> u+
                        _po & (& : n : N : _co[n]) -> u-

                        ~u -> _u+
                        u -> _u-

                        c[0] & u & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                        (: n : 1..N-2:
                            c[n] & u & pi & 
                            (& : nn : 0..n-1 : _co[nn]) & 
                            (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                        )
                        c[N-1] & u & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                        (: n : N :
                            ~pi -> _co[n]+

                            ~_co[n] -> co[n]+
                            _co[n] -> co[n]-
                        )
                    }

                    [ root = 0 ->
                        _p_ = _p;
                    [] root = 1 ->
                        // present normal sense interface
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                ~_p_.d[n] -> _p.d[n]+
                                _p_.d[n] -> _p.d[n]-
                            )
                        }
                    ]
                [] LAYOUT ->
                    prs<g.Vdd, g.GND> {
                        _u<26> & (| : n : N : c[n]<26>) -> _po-
                        ~g._pReset | (| : n : N : ~_co[n]<40> &
                            ~c[n]<40>) -> _po+

                        ~_po<12> -> po+
                        _po<8> -> po-

                        (: n : N :
                            c[n]<18> & pi<18> & _u<18> -> _p_.d[n]-
                            ~g._pReset | ~_u<16> -> _p_.d[n]+
                        )

                        ~pi<36> & (| : n : N : ~_p_.d[n]<36>) -> u+
                        _po<36> & (& : n : N : _co[n]<36>) -> u-

                        ~u<15> -> _u+
                        u<9> -> _u-

                        c[0]<40> & u<40> & pi<40> &
                            (& : n : 1..N-1 : _co[n]<40>) -> _co[0]-
                        (: n : 1..N-2:
                            c[n]<40> & u<40> & pi<40> & 
                            (& : nn : 0..n-1 : _co[nn]<40>) & 
                            (& : nn : n+1..N-1 : _co[nn]<40>) -> _co[n]-
                        )
                        c[N-1]<40> & u<40> & pi<40> &
                            (& : n : 0..N-2 : _co[n]<40>) -> _co[N-1]-
                        (: n : N :
                            ~pi<27> -> _co[n]+

                            ~_co[n]<12> -> co[n]+
                            _co[n]<6> -> co[n]-
                        )
                    }

                    [ root = 0 ->
                        _p_ = _p;
                    [] root = 1 ->
                        // present normal sense interface
                        c1of<N> p = _p;
                        prs<g.Vdd, g.GND> {
                            (: n : N :
                                ~_p_.d[n]<12> -> p.d[n]+
                                _p_.d[n]<6> -> p.d[n]-
                            )
                        }
                    ]
                ]
            // */
            /*--------------------------------------------------------------*/
            /* reference
                bool c[N], q[N], u;
                ::arbiter::N_ARB_S<N> arb(g, ci, c);

                prs<g.Vdd, g.GND> {
                    c[0] & ~co[1] -> q[0]+
                    g.pReset | ~c[0] & co[0] -> q[0]-
                    c[1] & ~co[0] -> q[1]+
                    g.pReset | ~c[1] & co[1] -> q[1]-

                    (| : n : N : q[n]) -> po+
                    (& : n : N : ~q[n]) -> po-

                    (: n : N :
                        q[n] & pi & ~u -> p.d[n]+
                        g.pReset | u -> p.d[n]-
                    )

                    (| : n : N : p.d[n]) & ~pi -> u+
                    ~po -> u-

                    (: n : N :
                        q[n] & u & pi -> co[n]+
                        ~u & ~pi -> co[n]-
                    )
                }
            */
        }

        export
        template <pint M, N, NN, root>
        defproc AEXT_ (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
            // utility for AEXT
            [ M = 1 ->
                NN = N;
                LEAF<N, root> leaf(g, xi, xo, pi, po, p);
            [] M > 1 ->
                pint k = NN/N;
                AEXT_<M-1, N, k, 0> _[N];
                (; n : N :
                    _[n].g = g;
                    _[n].xi = xi[n*k..(n+1)*k-1];
                    _[n].xo = xo[n*k..(n+1)*k-1];
                )

                NODE<N, root> node(g,,, pi, po,, p);
                (; n : N :
                    node.ci[n] = _[n].po;
                    node.co[n] = _[n].pi;
                    node._c[n] = _[n].p;
                )
            ]
        }
    } // namespace transmitter

    export
    template <pint M, N, NN>
    defproc AEXT (globals g; bool xi[NN], xo[NN], pi, po; c1of<N> p) {
        // Transmitter
        transmitter::AEXT_<M, N, NN, 1> _(g, xi, xo, pi, po, p);
    }

    namespace receiver {
        export
        template <pint F, D>
        defproc NODE (globals g; bool pi, po, ci[F], co[F]; c1of<D> p, c[F]) {
            // node in AERV tree
            // F fanout (radix)
            // D 1-of-D data
            bool _po, u[F], _co[F], cco, _cco, __cco, _cci, __cci, _uu;
            c1of<D> _p;
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    _cci => __cci-

                    cco => _cco-

                    (pi & _cco | __cci) & _uu => _po-

                    (: d : D :
                        p.d[d] => _p.d[d]-
                    )

                    _cco => __cco-

                    (: f : F :
                        ~_p.d[f] & ~__cco -> u[f]+
                        g.pReset | __cco -> u[f]-
                    )

                    (| : f : F : u[f]) => _uu-

                    (: f : F :
                        u[f] & _p.d[f] -> _co[f]-
                        ~pi -> _co[f]+
                    )

                    (& : f : F : _co[f]) => cco-

                    (| : f : F : ci[f]) => _cci-

                    (: f : F :
                        (: d : D :
                            ~_co[f] & ~_p.d[d] => c[f].d[d]+
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: f : F :
                        _co[f] => co[f]-
                    )

                    _po => po-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~_cci<9> -> __cci+
                    _cci<6> -> __cci-

                    ~cco<9> -> _cco+
                    cco<6> -> _cco-

                    (pi<6> & _cco<6> | __cci<6>) & _uu<6> -> _po-
                    (~pi<6> | ~_cco<6>) & ~__cci<6> | ~_uu<6> -> _po+

                    (: d : D :
                        ~p.d[d]<9> -> _p.d[d]+
                        p.d[d]<6> -> _p.d[d]-
                    )

                    ~_cco<9> -> __cco+
                    _cco<6> -> __cco-

                    (: f : F :
                        ~_p.d[f]<6> & ~__cco<6> -> u[f]+
                        g.pReset<6> | __cco<6> -> u[f]-
                    )

                    (| : f : F : u[f]<6>) -> _uu-
                    (& : f : F : ~u[f]<9>) -> _uu+

                    (: f : F :
                        u[f]<18> & _p.d[f]<18> -> _co[f]-
                        ~pi<6> -> _co[f]+
                    )

                    (| : f : F : ~_co[f]<9>) -> cco+
                    (& : f : F : _co[f]<24>) -> cco-

                    (| : f : F : ci[f]<6>) -> _cci-
                    (& : f : F : ~ci[f]<36>) -> _cci+

                    (: f : F :
                        (: d : D :
                            ~_co[f]<24> & ~_p.d[d]<24> -> c[f].d[d]+
                            _co[f]<6> | _p.d[d]<6> -> c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: d : D :
                        ~_co[d]<9> -> co[d]+
                        _co[d]<6> -> co[d]-
                    )

                    ~_po<9> -> po+
                    _po<6> -> po-
                }
            ]
        }

        export
        template <pint F, D>
        defproc LEAF (globals g; bool pi, po, ci[F]; c1of<D> p, c[F]) {
            // leaf of AERV tree
            // F fanout (number of clients)
            // D 1-of-D data
            bool _pi, _u[F], cc[F], _ccc, _cci, __cci, uu;
            c1of<D> _c[F];
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    pi => _pi-

                    _cci => __cci-

                    (~_pi | ~_ccc) & ~uu & ~__cci => po+

                    (: f : F :
                        _ccc & p.d[f] -> _u[f]-
                        ~g._pReset | ~_ccc -> _u[f]+
                    )
                    (& : f : F : _u[f]) => uu-

                    (: f : F :
                        ~_u[f] & ~p.d[f] -> cc[f]+
                        ~pi -> cc[f]-
                    )
                    (| : f : F : cc[f]) => _ccc-

                    (| : f : F : ci[f]) => _cci-

                    (: f : F :
                        (: d : D :
                            cc[f] & p.d[d] => _c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: f : F :
                        (: d : D :
                            _c[f].d[d] => c[f].d[d]-
                        )
                    )
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    ~pi<9> -> _pi+
                    pi<6> -> _pi-

                    ~_cci<9> -> __cci+
                    _cci<6> -> __cci-

                    (~_pi<4.30> | ~_ccc<4.30>) & ~uu<4.30> & ~__cci<4.30> -> po+
                    _pi<18> & _ccc<18> | uu<6> | __cci<6> -> po-

                    (: f : F :
                        _ccc<18> & p.d[f]<18> -> _u[f]-
                        ~g._pReset<6> | ~_ccc<9> -> _u[f]+
                    )
                    (| : f : F : ~_u[f]<9>) -> uu+
                    (& : f : F : _u[f]<24>) -> uu-

                    (: f : F :
                        ~_u[f]<24> & ~p.d[f]<24> -> cc[f]+
                        ~pi<6> -> cc[f]-
                    )
                    (| : f : F : cc[f]<6>) -> _ccc-
                    (& : f : F : ~cc[f]<9>) -> _ccc+

                    (| : f : F : ci[f]<6>) -> _cci-
                    (& : f : F : ~ci[f]<9>) -> _cci+

                    (: f : F :
                        (: d : D :
                            cc[f]<18> & p.d[d]<18> -> _c[f].d[d]-
                            ~cc[f]<9> | ~p.d[d]<9> -> _c[f].d[d]+
                        )
                    )
                }
                prs<g.Vdd, g.GND> {
                    (: f : F :
                        (: d : D :
                            ~_c[f].d[d]<12> -> c[f].d[d]+
                            _c[f].d[d]<6> -> c[f].d[d]-
                        )
                    )
                }
            ]
        }

        export
        template <pint N>
        defproc LEAF_NODATA (globals g; bool pi, po, ci[N], co[N]; c1of<N> p) {
            // leaf of AERV tree that does not transmit data
            // N clients
            bool u, _po, _ci[N], _co[N];
            [ ~LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ci[n] => _ci[n]-
                    )

                    pi & (& : n : N : _ci[n]) | u => _po-

                    (: n : N :
                        p.d[n] -> _co[n]-
                        ~pi -> _co[n]+
                    )

                    (| : n : N : ~_ci[n] & ~p.d[n]) => u+
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        _co[n] => co[n]-
                    )

                    _po => po-
                }
            [] LAYOUT ->
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~ci[n]<9> -> _ci[n]+
                        ci[n]<6> -> _ci[n]-
                    )

                    pi<30> & (& : n : N : _ci[n]<30>) | u<6> -> _po-
                    (~pi<24> | (| : n : N : ~_ci[n]<24>)) & ~u<24> -> _po+

                    (: n : N :
                        p.d[n]<6> -> _co[n]-
                        ~pi<9> -> _co[n]+
                    )

                    (| : n : N : ~_ci[n]<24> & ~p.d[n]<24>) -> u+
                    (& : n : N : _ci[n]<24> | p.d[n]<24>) -> u-
                }
                prs<g.Vdd, g.GND> {
                    (: n : N :
                        ~_co[n]<9> -> co[n]+
                        _co[n]<6> -> co[n]-
                    )

                    ~_po<9> -> po+
                    _po<6> -> po-
                }
            ]
        }
    } // namespace receiver

    export
    template <pint M, F_INT, F_LEAF, T, D>
    defproc AERV (globals g; bool yi[T], pi, po; c1of<D> y[T], p) {
        // receiver capable of sending data to neuron
        // M tree levels
        // F_INT intermediate node fanout (radix)
        // F_LEAF leaf node fanout (radix)
        // T targets. T = F_LEAF * F_INT^(M-1)
        // D 1-of-D data
        [ M = 1 ->
            T = F_LEAF;
            receiver::LEAF<F_LEAF, D> leaf(g, pi, po, yi, p, y);
        [] M > 1 ->
            AERV<M-1, F_INT, F_LEAF, T/F_INT, D> _[F_INT];
            receiver::NODE<F_INT, D> node(g, pi, po,,, p,);
            pint k = T/F_INT;
            (; f : F_INT :
                _[f].g = g;
                _[f].p = node.c[f];
                _[f].pi = node.co[f];
                _[f].po = node.ci[f];
                _[f].yi = yi[f*k..(f+1)*k-1];
                _[f].y = y[f*k..(f+1)*k-1];
            )
        ]
    }

    export
    template <pint M, N, NN>
    defproc AERV_NODATA (globals g; bool yi[NN], yo[NN], pi, po; c1of<N> p) {
        // basic receiver that only sends spikes to neurons
        // single spike type, no excitatory/inhibitory spike types 
        [ M = 1 ->
            NN = N;
            receiver::LEAF_NODATA<N> leaf(g, pi, po, yi, yo, p);
        [] M > 1 ->
            AERV_NODATA<M-1, N, NN/N> _[N];
            receiver::NODE<N, N> node(g, pi, po,,, p,);
            pint k = NN/N;
            (; n : N :
                _[n].g = g;
                _[n].p = node.c[n];
                _[n].pi = node.co[n];
                _[n].po = node.ci[n];
                _[n].yi = yi[n*k..(n+1)*k-1];
                _[n].yo = yo[n*k..(n+1)*k-1];
            )
        ]
    }

    export
    template <pint M, M_SPK, M_MEM, N_SYN, N_MEM>
    defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                        eMx1of4<M_MEM> x_mem;
                        a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> y_mem[N_MEM]) {
        // braindrop / brainstorm receiver system
        // M tree depth
        //     M = 5 (in production)
        // M_SPK packet length of spike to deliver to synapse.
        //     M_SPK = M + 1
        //     M_SPK = 6 (in production)
        // M_MEM packet length to write config memory
        //     M_MEM = M + memory packet length
        //     M_MEM = 9 (in production)
        // N_SYN synapses
        //     N_SYN = 4^M
        //     N_SYN = 1024 (in production)
        // N_MEM configuration memories
        //     N_MEM = 4^(M-1)
        //     N_MEM = 256 (in production)
        pint F_INT = 4;
        pint F_LEAF = 3;
        pint D = 4;
        pint AERV_TGTS = N_SYN/2 + N_MEM;

        interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
        interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
        serial_spk.x.m = x_spk.m;
        serial_mem.x.m = x_mem.m;
        serial_spk.x.e = x_spk.e;
        serial_mem.x.e = x_mem.e;

        bool merge_xi[2];
        bool merge_xo[2];
        c1of<D> merge_x[2];
        merge_xi[0] = serial_spk.yo;
        merge_xi[1] = serial_mem.yo;
        merge_xo[0] = serial_spk.yi;
        merge_xo[1] = serial_mem.yi;
        merge_x[0] = serial_spk.y;
        merge_x[1] = serial_mem.y;

        interface::SERIAL_MERGE<2, D> merge(g, merge_xi, merge_xo,,, merge_x,);

        interface::DESERIAL_RING<M_MEM-M, D> mem_deserial[N_MEM];
        (; n : N_MEM :
            mem_deserial[n].g = g;
            mem_deserial[n].y.m = y_mem[n].m;
            mem_deserial[n].y.e = y_mem[n].e;
        )

        OR<2> or_a[N_SYN/2];
        bool aerv_yi[AERV_TGTS];
        (; n : N_SYN/2 :
            or_a[n].g = g;
            or_a[n].i[0] = y_syn[2*n].a;
            or_a[n].i[1] = y_syn[2*n+1].a;
        )
        (; n : N_SYN/4 :
            or_a[2*n].o = aerv_yi[3*n];
            or_a[2*n+1].o = aerv_yi[3*n+1];
            mem_deserial[n].x.a = aerv_yi[3*n+2];
        )

        c1of<D> aerv_y[AERV_TGTS];
        (; n : AERV_TGTS/3 :
            aerv_y[3*n].d[0..1] = y_syn[4*n].d;
            aerv_y[3*n].d[2..3] = y_syn[4*n+1].d;
            aerv_y[3*n+1].d[0..1] = y_syn[4*n+2].d;
            aerv_y[3*n+1].d[2..3] = y_syn[4*n+3].d;
            aerv_y[3*n+2].d = mem_deserial[n].x.d;
        )

        AERV<M, F_INT, F_LEAF, AERV_TGTS, D> aerv(
            g, aerv_yi, merge.yo, merge.yi, aerv_y, merge.y);
    }

    export
    template <pint M, N, NN>
    defproc AER_NODATA (globals g; bool xi[NN], xo[NN], yi[NN], yo[NN]) {
        // address-event representation tranceiver
        // no data sent to receiving neuron
        // packets are serialized 
        // Uses M 1-of-N encoding
        // M groups
        // N items per group
        // NN=N^M
        AEXT<M, N, NN> aext(g, xi, xo,,,);
        interface::OUT_a1ofN<N, M> out(g, aext.po, aext.pi, aext.p,);
        interface::_DESERIAL_RING<M, N> deserial(g, out._y,);
        interface::SERIAL_RING<M, N> serial(g, deserial.y,,,);
        AERV_NODATA<M, N, NN> aerv(g, yi, yo, serial.yo, serial.yi, serial.y);
    }
} // namespace aer
