// This file defines an address-event representation system
import "aer/aext/aext.act";
import "aer/aerv/aerv.act";
import "aer/interface/interface.act";
import "aer/lib/test.act";

namespace aer {

export
template <pint M, N, NN>
defproc AER_NODATA (globals g; bool _xp[NN], xa[NN], ye[NN], yp[NN]) {
    // address-event representation tranceiver
    // no data sent to receiving neuron
    // packets are serialized 
    // Uses M 1-of-N encoding
    // M groups
    // N items per group
    // NN=N^M
    AEXT<M, N, NN> aext(g, _xp, xa,,,);
    interface::OUT_a1ofN<N> out(g, aext.pp, aext.pe, aext.p,);
    interface::DESERIAL_RING<M, N, false, true> deserial(g, out.y,);
    interface::SERIAL_RING<M, N> serial(g, deserial.y,,,);
    AERV_NODATA<M, N, NN> aerv(g, ye, yp, serial.yp, serial.ye, serial.y);
}

namespace brain_aer {
    // blackbox for neurons and memory in tile
    defproc TILE_NRN_MEM (
        bool? RST;
        bool! SPK_So[16]; bool? ACK_So[16];
        bool? INH_Syn[4], EXC_Syn[4]; bool! ACK_Syn[4];
        bool! ADC_OUT[2];
        bool ? V_REF, V_R, V_G, V_PE_PD, V_PE_PU, V_WINH, V_WDC, V_WEXC, V_IK_B, V_LK_A, V_IOFFSET,
        DIFF_CM_0_R, DIFF_SYN_0_R,
        DIFF_CM_0_D, DIFF_SYN_0_D,
        DIFF_CM_1_R, DIFF_SYN_1_R,
        DIFF_CM_2_R, DIFF_SYN_2_R,
        DIFF_CM_3_R, DIFF_SYN_3_R,
        DIFF_CM_3_U, DIFF_SYN_3_U,
        DIFF_CM_4_D, DIFF_SYN_4_D,
        DIFF_CM_7_U, DIFF_SYN_7_U,
        DIFF_CM_8_D, DIFF_SYN_8_D,
        DIFF_CM_11_U, DIFF_SYN_11_U,
        DIFF_CM_12_D, DIFF_SYN_12_D,
        DIFF_CM_12_L, DIFF_SYN_12_L,
        DIFF_CM_13_L, DIFF_SYN_13_L,
        DIFF_CM_14_L, DIFF_SYN_14_L,
        DIFF_CM_15_L, DIFF_SYN_15_L,
        DIFF_CM_15_U, DIFF_SYN_15_U
        ) {}

    export
    template <pbool unit_aext>
    defproc TILE (globals g;
                  bool aext_pe, aext__pp; c1of<4> aext__p;
                  bool aerv__pp, aerv__pe; c1of<4> aerv_p;
                  bool nrn_req[16], nrn_ack[16];
                  a1of2 syn_spk[4]; eMx1of4<4> _mem) {
        // braindrop / brainstorm neuron array tile
        // transmitter services 16 neurons
        // recevier services 4 synapses, 1 memory
        pint N = 4; // aer tree radix, 1-in-N data
        pint NN = 16;
        pint N_SYN = 4;
        pint N_MEM = 1;
        pint N_AEXT_LEAF = 4;
        pint M_MEM = 4;

        // transmitter components
        ::aer::transmitter::NODE<N> aext_node(g,,, aext_pe, aext__pp,, aext__p);
        ::aer::transmitter::LEAF<N> aext_leaf[N_AEXT_LEAF];
        ::aer::brain_transmitter::NRN_BUF<NN> buf_nrn(g, nrn_req, nrn_ack,,);
        pint M = 1; // repeaters from lowest level of tree
        pint N_LINK = 4;
        pint Mmax_idx = 5; // use last of hardcoded repeater parameters
        ::aer::transmitter::AMP_WIRES<M, N, N_LINK, Mmax_idx, N_LINK>
            repeater_wires(g,,,,,,);
        (; n : N_AEXT_LEAF :
            aext_leaf[n].g = g;

            aext_node.ce[n] = repeater_wires.p_ce[n];
            aext_node._cp[n] = repeater_wires.p_cp[n];
            aext_node._c[n] = repeater_wires.p_c[n];

            repeater_wires.c_pe[n] = aext_leaf[n].pe;
            repeater_wires.c_pp[n] = aext_leaf[n]._pp;
            repeater_wires.c_p[n] = aext_leaf[n]._p;
        )
        (; nn : NN :
            buf_nrn._yp[nn] = aext_leaf[nn/N]._cp[nn%N];
            buf_nrn.ya[nn] = aext_leaf[nn/N].ca[nn%N];
        )

        // receiver components
        ::aer::receiver::LEAF<N, N_SYN, N_MEM> aerv_leaf(
            g, aerv__pp, aerv__pe, aerv_p,,,,,);
        ::aer::brain_receiver::HALF_BUFFER<N_SYN> buf_syn(g,, syn_spk);
        ::aer::brain_receiver::DESERIALIZER<M_MEM, N> mem_deserial(g,,,,);

        (; n : N_SYN :
            buf_syn.x[n].m = aerv_leaf.c_syn[n];
            buf_syn.x[n].e = aerv_leaf.ce_syn[n];
        )
        mem_deserial.xp = aerv_leaf.cp_mem[0];
        mem_deserial.xe = aerv_leaf.ce_mem[0];
        mem_deserial.x = aerv_leaf.c_mem[0];
        mem_deserial._y.e = _mem.e;
        (; m : M_MEM :
            mem_deserial._y.m[m].d = _mem.m[m].d;
        )

        // neuron, synapse, memory
        [ ~LAYOUT ->
            [ ~unit_aext ->
                ::aer::test::NRN_ARR<NN> nrn(g, nrn_req, nrn_ack);
            ]
            ::aer::test::SYNAPSE_ARR<NN/N> syn(g, syn_spk);
        [] LAYOUT ->
            TILE_NRN_MEM tile_nrn_mem;
            tile_nrn_mem.RST = g.sReset;
            tile_nrn_mem.SPK_So = nrn_req;
            tile_nrn_mem.ACK_So = nrn_ack;
            (; n : N :
                tile_nrn_mem.INH_Syn[n] = syn_spk[n].d[0];
                tile_nrn_mem.EXC_Syn[n] = syn_spk[n].d[1];
                tile_nrn_mem.ACK_Syn[n] = syn_spk[n].a;
            )
        ]
    }
}

export
template <pint M, p4M; pbool unit_aext>
defproc BRAIN_AER (globals g;
                   bool aext_nrn_req[p4M], aext_nrn_ack[p4M];
                   eMx1of4<M> aext_out;
                   eMx1of4<M> aerv_spk_in; eMx1of4<M+3> aerv_mem_in;
                   a1of2 aerv_syn[p4M/4]; eMx1of4<4> aerv__mem[p4M/4/4]) {
    // aer system for braindrop / brainstorm
    // M depth of AEXT tree (require M > 2)
    //     M-1 depth of AERV tree
    // p4M = 4^M neurons
    //     4^(M-1) synapses
    //     4^(M-2) neuron/synapse configuration memories
    [M<2 -> 0=1;] // assert false
    pint N = 4; // radix of AEXT/AERV tree
    pint NRN_PTILE = 16; // neurons per tile
    pint SYN_PTILE = 4; // synapses per tile
    pint N_TILE = p4M / NRN_PTILE;
    [N_TILE=0 -> 1=0;] // assert false
    N_TILE * NRN_PTILE = p4M; // assert neurons evenly divide into tiles
    pint M_SPK = M;
    pint M_MEM = M+3;

    // TILEs
    brain_aer::TILE<unit_aext> tile[N_TILE];
    (; n : N_TILE :
        tile[n].g = g;
    )

    // transmitter components
    interface::OUT_a1ofN<N> out(g,,,,);
    interface::DESERIAL_RING<M, N, false, true> deserial(g, out.y,);
    (; m : M_SPK :
        deserial.y.m[m].d = aext_out.m[m].d;
    )
    deserial.y.e = aext_out.e;
    AEXT_TO_TILE<M, p4M> aext(g,,,, out.xe, out.xp, out.x);
    (; n : N_TILE :
        tile[n].aext_pe = aext.ce[n];
        tile[n].aext__pp = aext._cp[n];
        tile[n].aext__p = aext._c[n];

        tile[n].nrn_req = aext_nrn_req[NRN_PTILE*n..NRN_PTILE*(n+1)-1];
        tile[n].nrn_ack = aext_nrn_ack[NRN_PTILE*n..NRN_PTILE*(n+1)-1];
    )

    // receiver components
    brain_receiver::AERV_INT<M_SPK, M_MEM> aerv_int(
        g, aerv_spk_in, aerv_mem_in,,,);
    AERV_TO_TILE<M-1, p4M/N> aerv(
        g, aerv_int.aerv_pp, aerv_int.aerv_pe, aerv_int.aerv_p,,,);

    (; n : N_TILE :
        tile[n].aerv__pe = aerv._ce[n];
        tile[n].aerv__pp = aerv._cp[n];
        tile[n].aerv_p = aerv.c[n];

        tile[n].syn_spk = aerv_syn[SYN_PTILE*n..SYN_PTILE*(n+1)-1];
        tile[n]._mem = aerv__mem[n];
    )
}

} // namespace aer
