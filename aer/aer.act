// This file defines an address-event representation system
import "aer/aext/aext.act";
import "aer/aerv/aerv.act";
import "aer/interface/interface.act";
import "aer/lib/test.act";

namespace aer {

export
template <pint M, N, NN>
defproc AER_NODATA (globals g; bool _xp[NN], xa[NN], ye[NN], yp[NN]) {
    // address-event representation tranceiver
    // no data sent to receiving neuron
    // packets are serialized 
    // Uses M 1-of-N encoding
    // M groups
    // N items per group
    // NN=N^M
    AEXT<M, N, NN> aext(g, _xp, xa,,,);
    interface::OUT_a1ofN<N> out(g, aext.pp, aext.pe, aext.p,);
    interface::DESERIAL_RING<M, N, false, true> deserial(g, out.y,);
    interface::SERIAL_RING<M, N> serial(g, deserial.y,,,);
    AERV_NODATA<M, N, NN> aerv(g, ye, yp, serial.yp, serial.ye, serial.y);
}

namespace brain_aer {
    template <pint N>
    defproc NRN (globals g; bool req[N], ack[N]) {
        // models N neurons producing spikes
        prs<g.Vdd, g.GND> {
            (: n : N :
                ~g.sReset & ~ack[n] => req[n]+
            )
        }
    }

    template <pint N>
    defproc SYN (globals g; a1of2 spk[N]) {
        // models N synapses consuming excitatory/inhibitory spikes
        SYNAPSE syn[N];
        (; n : N :
            syn[n].g = g;
            syn[n].spk = spk[n];
        )
    }

    template <pint M>
    defproc MEM (globals g; eMx1ofN<M, 4> _x) {
        // models a neuron/synapse configuration memory
        pint D = 4; // 1-of-D data
        SINK_eMx1ofN<M, 4> snk(g,);
        _x.e = snk.d.e;
        prs<g.Vdd, g.GND> {
            (: m : M :
                (: d : D :
                    _x.m[m].d[d] => snk.d.m[m].d[d]-
                )
            )
        }
    }

    export
    defproc TILE (globals g;
                  bool aext_pe, aext__pp; c1of<4> aext__p;
                  bool aerv__pp, aerv__pe; c1of<4> aerv_p) {
        // braindrop / brainstorm neuron array tile
        // transmitter services 16 neurons
        // recevier services 4 synapses, 1 memory
        pint N = 4; // aer tree radix, 1-in-N data
        pint NN = 16;
        pint N_SYN = 4;
        pint N_MEM = 1;
        pint N_AEXT_LEAF = 4;
        pint M_MEM = 4;

        // neuron, synapse, memory
        NRN<NN> nrn(g,,);
        SYN<N_SYN> syn(g,);
        MEM<M_MEM> mem(g,);

        // transmitter components
        ::aer::brain_transmitter::NRN_BUF<NN> buf_nrn(g, nrn.req, nrn.ack,,);
        ::aer::transmitter::LEAF<N> aext_leaf[N_AEXT_LEAF];
        ::aer::transmitter::NODE<N> aext_node(g,,, aext_pe, aext__pp,, aext__p);
        (; nn : NN :
            buf_nrn._yp[nn] = aext_leaf[nn/N]._cp[nn%N];
            buf_nrn.ya[nn] = aext_leaf[nn/N].ca[nn%N];
        )
        (; n : N_AEXT_LEAF :
            aext_leaf[n].g = g;
            aext_leaf[n]._pp = aext_node._cp[n];
            aext_leaf[n].pe = aext_node.ce[n];
            aext_leaf[n]._p = aext_node._c[n];
        )

        // receiver components
        ::aer::receiver::LEAF<N, N_SYN, N_MEM> aerv_leaf(
            g, aerv__pp, aerv__pe, aerv_p,,,,,);
        ::aer::brain_receiver::HALF_BUFFER<N_SYN> buf_syn(g,, syn.spk);
        ::aer::brain_receiver::DESERIALIZER<M_MEM, N> mem_deserial(
            g,,,, mem._x);

        (; n : N_SYN :
            buf_syn.x[n].m = aerv_leaf.c_syn[n];
            buf_syn.x[n].e = aerv_leaf.ce_syn[n];
        )
        mem_deserial.xp = aerv_leaf.cp_mem[0];
        mem_deserial.xe = aerv_leaf.ce_mem[0];
        mem_deserial.x = aerv_leaf.c_mem[0];
    }
}

export
template <pint M, p4M>
defproc BRAIN_AER (globals g; eMx1of4<M> aext_out,
                   aerv_spk_in; eMx1of4<M+3> aerv_mem_in) {
    // aer system for braindrop / brainstorm
    // M depth of AEXT tree (require M > 2)
    //     M-1 depth of AERV tree
    // p4M = 4^M neurons
    //     4^(M-1) synapses
    //     4^(M-2) neuron/synapse configuration memories
    pint N = 4; // radix of AEXT/AERV tree
    pint NRN_PTILE = 16; // neurons per tile
    pint N_TILE = p4M / NRN_PTILE;
    [ N_TILE = 0 ->
        1=0; // assert false
    ]
    N_TILE * NRN_PTILE = p4M; // assert neurons evenly divide into tiles
    pint M_SPK = M;
    pint M_MEM = M+3;

    // TILEs
    brain_aer::TILE tile[N_TILE];
    (; n : N_TILE :
        tile[n].g = g;
    )

    // transmitter components
    interface::OUT_a1ofN<N> out(g,,,,);
    interface::DESERIAL_RING<M, N, false, true> deserial(g, out.y,);
    (; m : M_SPK :
        deserial.y.m[m].d = aext_out.m[m].d;
    )
    deserial.y.e = aext_out.e;
    AEXT_TO_TILE<M, p4M> aext(g,,,, out.xe, out.xp, out.x);
    (; n : N_TILE :
        tile[n].aext_pe = aext.ce[n];
        tile[n].aext__pp = aext._cp[n];
        tile[n].aext__p = aext._c[n];
    )

    // receiver components
    brain_receiver::AERV_INT<M_SPK, M_MEM> aerv_int(
        g, aerv_spk_in, aerv_mem_in,,,);
    AERV_TO_TILE<M-1, p4M/N> aerv(
        g, aerv_int.aerv_pp, aerv_int.aerv_pe, aerv_int.aerv_p,,,);

    (; n : N_TILE :
        tile[n].aerv__pe = aerv._ce[n];
        tile[n].aerv__pp = aerv._cp[n];
        tile[n].aerv_p = aerv.c[n];
    )
}

} // namespace aer
