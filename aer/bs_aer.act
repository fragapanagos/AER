// This file defines a modified brainstorm aer system that
// uses the serializer defined in the brainstorm repository
// This code only compiles when this aer repository is located
// as a subdirectory of the brainstorm repository, namely in
// brainstorm/act
import "aer/aer/aer.act";
import "aer/aerv/bs_aerv.act";
import "aer/aext/bs_aext.act";
import "core/serializer/AERSerializer.act";
import "lib/channel.act";

export
template <pint M_1of2, M_1of4, p4M, p2M; pint tile_i[p4M/16], tile_j[p4M/16];
          pbool unit_aext>
defproc BS_AER (globals g_bs;
                bool aext_nrn_req[p4M], aext_nrn_ack[p4M];
                bool aext__pp, aext_pe; aer::c1of<4> aext__p;
                bool aerv__pp, aerv__pe; aer::c1of<4> aerv_p;
                aer::a1of2 aerv_syn[p4M/4];
                aer::aMx1of4<4> aerv__mem[p4M/4/4]) {
    // modified braindrop / brainstorm aer system that uses the 
    // the serializer defined in the brainstorm repository at the top of the
    // receiver tree
    // and outputs eMx1of2 data from the transmitter to the datapath
    // M depth of AEXT tree (require M > 2)
    //     M_1of4 = 6 in production
    //     M_1of4-1 depth of AERV tree
    // p4M = 4^M neurons
    //     4^(M-1) synapses
    //     4^(M-2) neuron/synapse configuration memories
    // p2M = 2^M = sqrt(p4M) 
    //     L = p2M / 4 tiles per side of the array
    // tile_i maps flat tile indexing to i of 2d ij tile indexing
    // tile_j maps flat tile indexing to j of 2d ij tile indexing
    M_1of4*2 = M_1of2; // assert
    [M_1of4<2 -> 0=1;] // assert false
    pint N = 4; // radix of AEXT/AERV tree
    pint NRN_PTILE = 16; // neurons per tile
    pint SYN_PTILE = 4; // synapses per tile
    pint N_TILE = p4M / NRN_PTILE;
    [N_TILE=0 -> 1=0;] // assert false
    N_TILE * NRN_PTILE = p4M; // assert neurons evenly divide into tiles
    pint L = p2M / 4;
    L * L = N_TILE; // assert tiles form a square
    pint M_SPK_1of4 = M_1of4;
    pint M_MEM_1of4 = M_1of4+3;
    pint M_SPK_1of2 = M_SPK_1of4*2;
    pint M_MEM_1of2 = M_MEM_1of4*2;

    aer::globals g;
    compat_bs::globals g_to_gbs(g, g_bs);

    // TILEs
    aer::brain_aer::TILE_AER<unit_aext> tile_aer[N_TILE];
    (; n : N_TILE : tile_aer[n].g = g;)
    // neuron, synapse, memory
    [ ~LAYOUT ->
        [ ~unit_aext ->
            aer::test::NRN_ARR<NRN_PTILE> nrn[N_TILE];
            (; n : N_TILE :
                nrn[n].g = g;
                nrn[n].req = tile_aer[n].nrn_req;
                nrn[n].ack = tile_aer[n].nrn_ack;
            )
        ]
        aer::test::SYNAPSE_ARR<NRN_PTILE/N> syn[N_TILE];
        aer::test::MEM<4> mem[N_TILE];
        (; n : N_TILE :
            syn[n].g = g;
            syn[n].spk = tile_aer[n].syn_spk;

            mem[n].g = g;
            mem[n]._x = tile_aer[n]._mem;
        )
    [] LAYOUT ->
        aer::brain_aer::TILE_NRN_MEM tile_nrn_mem[N_TILE];
        (; n : N_TILE :
            tile_nrn_mem[n]._RST = g_bs._sReset;
            tile_nrn_mem[n].SPK_So = tile_aer[n].nrn_req;
            tile_nrn_mem[n].ACK_So = tile_aer[n].nrn_ack;
            (; ns : SYN_PTILE :
                tile_nrn_mem[n].INH_Syn[ns] = tile_aer[n].syn_spk[ns].d[0];
                tile_nrn_mem[n].EXC_Syn[ns] = tile_aer[n].syn_spk[ns].d[1];
                tile_nrn_mem[n].ACK_Syn[ns] = tile_aer[n].syn_spk[ns].a;
            )
            tile_nrn_mem[n].ADC_OUT = g_bs.ADC_OUT;
            tile_nrn_mem[n].V_REF = g_bs.V_REF;
            tile_nrn_mem[n].V_R = g_bs.V_R;
            tile_nrn_mem[n].V_G = g_bs.V_G;
            tile_nrn_mem[n].V_PE_PD = g_bs.V_PE_PD;
            tile_nrn_mem[n].V_PE_PU = g_bs.V_PE_PU;
            tile_nrn_mem[n].V_WINH = g_bs.V_WINH;
            tile_nrn_mem[n].V_WDC = g_bs.V_WDC;
            tile_nrn_mem[n].V_WEXC = g_bs.V_WEXC;
            tile_nrn_mem[n].V_IK_B = g_bs.V_IK_B;
            tile_nrn_mem[n].V_LK_A = g_bs.V_LK_A;
            tile_nrn_mem[n].V_IOFFSET = g_bs.V_IOFFSET;

            tile_nrn_mem[n].GND = g_bs.GND;
            tile_nrn_mem[n].Vdd = g_bs.Vdd;
            tile_nrn_mem[n].vpsub = g_bs.vpsub;
            tile_nrn_mem[n].vnsub = g_bs.vnsub;
            tile_nrn_mem[n]._d =
                {tile_aer[n]._mem.m[3].d[0], tile_aer[n]._mem.m[3].d[2]};
            tile_nrn_mem[n]._d_ =
                {tile_aer[n]._mem.m[3].d[1], tile_aer[n]._mem.m[3].d[3]};
            tile_nrn_mem[n]._x2 = tile_aer[n]._mem.m[2].d;
            tile_nrn_mem[n]._x1 = tile_aer[n]._mem.m[1].d;
            tile_nrn_mem[n]._x0 = tile_aer[n]._mem.m[0].d;
            tile_nrn_mem[n].xa = tile_aer[n]._mem.a;
        )

        aer::brain_aer::TILE_DIFF tile_diff[p2M][p2M];
        (; n : N_TILE :
            tile_nrn_mem[n].DIFF_CM_U = 
                tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_U;
            tile_nrn_mem[n].DIFF_CM_L =
                tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_L;
            tile_nrn_mem[n].DIFF_CM_R =
                tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_R;
            tile_nrn_mem[n].DIFF_CM_D =
                tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_D;
            tile_nrn_mem[n].DIFF_SYN_U =
                tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_U;
            tile_nrn_mem[n].DIFF_SYN_L =
                tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_L;
            tile_nrn_mem[n].DIFF_SYN_R =
                tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_R;
            tile_nrn_mem[n].DIFF_SYN_D =
                tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_D;
        )
        [ L > 1 ->
            (; l0: L-2 :
                (; l1 : L :
                    tile_diff[l0][l1].DIFF_CM_D =
                        tile_diff[l0+1][l1].DIFF_CM_U;
                    tile_diff[l0][l1].DIFF_SYN_D =
                        tile_diff[l0+1][l1].DIFF_SYN_U;

                    tile_diff[l1][l0].DIFF_CM_R =
                        tile_diff[l1][l0+1].DIFF_CM_L;
                    tile_diff[l1][l0].DIFF_SYN_R =
                        tile_diff[l1][l0+1].DIFF_SYN_L;
                )
            )
        ]
    ]

    aer::AEXT_TO_TILE<M_1of4, p4M> aext(
        g,,,, aext_pe, aext__pp, aext__p);
    (; n : N_TILE :
        tile_aer[n].aext_pe = aext.ce[n];
        tile_aer[n].aext__pp = aext._cp[n];
        tile_aer[n].aext__p = aext._c[n];

        tile_aer[n].nrn_req = aext_nrn_req[NRN_PTILE*n..NRN_PTILE*(n+1)-1];
        tile_aer[n].nrn_ack = aext_nrn_ack[NRN_PTILE*n..NRN_PTILE*(n+1)-1];
    )

    // receiver components
    aer::AERV_TO_TILE<M_1of4-1, p4M/N> aerv(
        g, aerv__pp, aerv__pe, aerv_p,,,);

    (; n : N_TILE :
        tile_aer[n].aerv__pe = aerv._ce[n];
        tile_aer[n].aerv__pp = aerv._cp[n];
        tile_aer[n].aerv_p = aerv.c[n];

        tile_aer[n].syn_spk = aerv_syn[SYN_PTILE*n..SYN_PTILE*(n+1)-1];
        tile_aer[n]._mem = aerv__mem[n];
    )
}

export
template <pint M_1of2, M_1of4, p4M, p2M; pint tile_i[p4M/16], tile_j[p4M/16];
          pbool unit_aext>
defproc BS_AER_wrapper (globals g;
                        bool PP_TX, PE_TX; d1of<4> P_TX;
                        bool PP_RX, PE_RX; d1of<4> P_RX;
                        a1of1 AERSOMA[p4M]; // exposed for testing
                        e1of2 AERSYN[p4M/4];
                        eMx1of4<4> AERMEM[p4M/4/4]) {
    // converts to the data types used by the rest of the BS repo

    bool aext__pp = PP_TX;
    bool aext_pe = PE_TX;

    aer::c1of<4> aext__p;
    aext__p.d = P_TX.d;

    bool aerv__pp = PP_RX;
    bool aerv__pe = PE_RX;

    aer::c1of<4> aerv_p;
    aerv_p.d = P_RX.d;

    bool aext_nrn_req[p4M], aext_nrn_ack[p4M];
    (;m:p4M: aext_nrn_req[m] = AERSOMA[m].d; ) // neuron controls req
    (;m:p4M: aext_nrn_ack[m] = AERSOMA[m].a; ) // aer controls ack

    aer::a1of2 aerv_syn[p4M/4];
    (;m:p4M/4: aerv_syn[m].a = AERSYN[m].e; )
    (;m:p4M/4: aerv_syn[m].d = AERSYN[m].d; )

    aer::aMx1of4<4> aerv__mem[p4M/4/4];
    (;m:p4M/4/4:        aerv__mem[m].a = AERMEM[m].e; )
    (;m:p4M/4/4: (;i:4: aerv__mem[m].b[i].d = AERMEM[m].b[i].d; ) )

    BS_AER<M_1of2, M_1of4, p4M, p2M, tile_i, tile_j, unit_aext> _(g,
        aext_nrn_req, aext_nrn_ack, aext__pp, aext_pe, aext__p,
        aerv__pp, aerv__pe, aerv_p, aerv_syn, aerv__mem);
}


export
template <pint M_1of2, M_1of4>
defproc BS_AER_INT (globals g_bs;
                    bool aext__pp, aext_pe; aer::c1of<4> aext__p;
                    aer::eMx1of2<M_1of2> aext_out;
                    bool aerv__pp, aerv__pe; aer::c1of<4> aerv_p;
                    aer::eMx1of2<M_1of2> aerv_spk_in;
                    aer::eMx1of2<M_1of2+6> aerv_mem_in) {
    // Brinstorm AER interface with the datapath
    // contains the AEXT deserializer and the AERV serializer
    M_1of4*2 = M_1of2; // assert
    [M_1of4<2 -> 0=1;] // assert false
    pint N = 4; // radix of AEXT/AERV tree
    pint M_SPK_1of4 = M_1of4;
    pint M_MEM_1of4 = M_1of4+3;
    pint M_SPK_1of2 = M_SPK_1of4*2;
    pint M_MEM_1of2 = M_MEM_1of4*2;

    aer::globals g;
    compat_bs::globals g_to_gbs(g, g_bs);

    BS_AEXT_INT<M_SPK_1of2> aext_int(
        g_bs, aext__pp, aext_pe, aext__p, aext_out);

    BS_AERV_INT<M_SPK_1of2, M_MEM_1of2> aerv_int(g_bs,
        aerv_spk_in, aerv_mem_in,
        aerv__pp, aerv__pe, aerv_p);
}

export
template <pint M_1of2, M_1of4>
defproc BS_AER_INT_wrapper (globals g;
                            bool PP_TX, PE_TX; d1of<4> P_TX;
                            eMx1of2<M_1of2> SPK_TX;
                            bool PP_RX, PE_RX; d1of<4> P_RX;
                            eMx1of2<M_1of2> SPK_RX; eMx1of2<M_1of2+6> MEM_RX) {
    // converts to data types used by the rest of the BS repo

    bool aext__pp = PP_TX;
    bool aext_pe = PE_TX;

    aer::c1of<4> aext__p;
    aext__p.d = P_TX.d;

    aer::eMx1of2<M_1of2> aext_out;
    (;m:M_1of2: aext_out.m[m].d = SPK_TX.b[m].d;)
    aext_out.e = SPK_TX.e;

    bool aerv__pp = PP_RX;
    bool aerv__pe = PE_RX;

    aer::c1of<4> aerv_p;
    aerv_p.d = P_RX.d;

    aer::eMx1of2<M_1of2> aerv_spk_in;
    (;m:M_1of2: aerv_spk_in.m[m].d = SPK_RX.b[m].d;)
    aerv_spk_in.e = SPK_RX.e;

    aer::eMx1of2<M_1of2+6> aerv_mem_in;
    (;m:M_1of2+6: aerv_mem_in.m[m].d = MEM_RX.b[m].d;)
    aerv_mem_in.e = MEM_RX.e;

    BS_AER_INT<M_1of2, M_1of4> _(g,
        aext__pp, aext_pe, aext__p, aext_out,
        aerv__pp, aerv__pe, aerv_p, aerv_spk_in, aerv_mem_in);
}
