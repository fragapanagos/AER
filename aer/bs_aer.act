// This file defines a modified brainstorm aer system that
// uses the serializer defined in the brainstorm repository
// This code only compiles when this aer repository is located
// as a subdirectory of the brainstorm repository, namely in
// brainstorm/act
import "aer/aer/aer.act";
import "aer/aerv/bs_aerv.act";
import "core/serializer/AERSerializer.act";
import "lib/channel.act";

export
template <pint M_1of2, M_1of4, p4M, p2M; pint tile_i[p4M/16], tile_j[p4M/16];
          pbool unit_aext>
defproc BS_AER (aer::globals_w_analog ga;
                bool aext_nrn_req[p4M], aext_nrn_ack[p4M];
                aer::eMx1of2<M_1of2> aext_out;
                aer::eMx1of2<M_1of2> aerv_spk_in;
                aer::eMx1of2<M_1of2+6> aerv_mem_in;
                aer::a1of2 aerv_syn[p4M/4];
                aer::aMx1of4<4> aerv__mem[p4M/4/4]) {
    // modified braindrop / brainstorm aer system that uses the 
    // the serializer defined in the brainstorm repository at the top of the
    // receiver tree
    // and outputs eMx1of2 data from the transmitter to the datapath
    // M depth of AEXT tree (require M > 2)
    //     M_1of4 = 6 in production
    //     M_1of4-1 depth of AERV tree
    // p4M = 4^M neurons
    //     4^(M-1) synapses
    //     4^(M-2) neuron/synapse configuration memories
    // p2M = 2^M = sqrt(p4M) 
    //     L = p2M / 4 tiles per side of the array
    // tile_i maps flat tile indexing to i of 2d ij tile indexing
    // tile_j maps flat tile indexing to j of 2d ij tile indexing
    M_1of4*2 = M_1of2; // assert
    [M_1of4<2 -> 0=1;] // assert false
    pint N = 4; // radix of AEXT/AERV tree
    pint NRN_PTILE = 16; // neurons per tile
    pint SYN_PTILE = 4; // synapses per tile
    pint N_TILE = p4M / NRN_PTILE;
    [N_TILE=0 -> 1=0;] // assert false
    N_TILE * NRN_PTILE = p4M; // assert neurons evenly divide into tiles
    pint L = p2M / 4;
    L * L = N_TILE; // assert tiles form a square
    pint M_SPK_1of4 = M_1of4;
    pint M_MEM_1of4 = M_1of4+3;
    pint M_SPK_1of2 = M_SPK_1of4*2;
    pint M_MEM_1of2 = M_MEM_1of4*2;

    aer::globals g;
    aer::globals_to_globals_w_analog g_to_ga(g, ga);

    // TILEs
    aer::brain_aer::TILE<unit_aext> tile[N_TILE];
    aer::brain_aer::TILE_DIFF tile_diff[p2M][p2M];
    (; n : N_TILE :
        tile[n].ga = ga;
        tile[n].DIFF_CM_U = tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_U;
        tile[n].DIFF_CM_L = tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_L;
        tile[n].DIFF_CM_R = tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_R;
        tile[n].DIFF_CM_D = tile_diff[tile_i[n]][tile_j[n]].DIFF_CM_D;
        tile[n].DIFF_SYN_U = tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_U;
        tile[n].DIFF_SYN_L = tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_L;
        tile[n].DIFF_SYN_R = tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_R;
        tile[n].DIFF_SYN_D = tile_diff[tile_i[n]][tile_j[n]].DIFF_SYN_D;
    )
    [ L > 1 ->
        (; l0: L-2 :
            (; l1 : L :
                tile_diff[l0][l1].DIFF_CM_D = tile_diff[l0+1][l1].DIFF_CM_U;
                tile_diff[l0][l1].DIFF_SYN_D = tile_diff[l0+1][l1].DIFF_SYN_U;

                tile_diff[l1][l0].DIFF_CM_R = tile_diff[l1][l0+1].DIFF_CM_L;
                tile_diff[l1][l0].DIFF_SYN_R = tile_diff[l1][l0+1].DIFF_SYN_L;
            )
        )
    ]

    // transmitter components
    aer::interface::OUT_a1ofN<N> out(g,,,,);
    aer::interface::DESERIAL_RING<M_1of4, N, false, true> deserial(g, out.y,);
    aer::eMx1of4_to_eMx1of2<M_SPK_1of4, M_SPK_1of2> aext_converter(g,, aext_out);
    (; m : M_SPK_1of4 :
        deserial.y.m[m].d = aext_converter.x.m[m].d;
    )
    deserial.y.e = aext_converter.x.e;
    aer::AEXT_TO_TILE<M_1of4, p4M> aext(g,,,, out.xe, out.xp, out.x);
    (; n : N_TILE :
        tile[n].aext_pe = aext.ce[n];
        tile[n].aext__pp = aext._cp[n];
        tile[n].aext__p = aext._c[n];

        tile[n].nrn_req = aext_nrn_req[NRN_PTILE*n..NRN_PTILE*(n+1)-1];
        tile[n].nrn_ack = aext_nrn_ack[NRN_PTILE*n..NRN_PTILE*(n+1)-1];
    )

    // receiver components
    BS_AERV_INT<M_SPK_1of2, M_MEM_1of2> aerv_int(
        g, aerv_spk_in, aerv_mem_in,,,);
    aer::AERV_TO_TILE<M_1of4-1, p4M/N> aerv(
        g, aerv_int.aerv_pp, aerv_int.aerv_pe, aerv_int.aerv_p,,,);

    (; n : N_TILE :
        tile[n].aerv__pe = aerv._ce[n];
        tile[n].aerv__pp = aerv._cp[n];
        tile[n].aerv_p = aerv.c[n];

        tile[n].syn_spk = aerv_syn[SYN_PTILE*n..SYN_PTILE*(n+1)-1];
        tile[n]._mem = aerv__mem[n];
    )
}

export
template <pint M_1of2, M_1of4, p4M, p2M; pint tile_i[p4M/16], tile_j[p4M/16];
          pbool unit_aext>
defproc BS_AER_wrapper (globals g;
                        eMx1of2<M_1of2> SPK_TX;
                        eMx1of2<M_1of2> SPK_RX;
                        eMx1of2<M_1of2+6> MEM_RX;
                        e1of1 AERSOMA[p4M]; // exposed for testing
                        e1of2 AERSYN[p4M/4];
                        eMx1of4<4> AERMEM[p4M/4/4])
// converts to the data types used by the rest of the BS repo
{
  aer::globals_w_analog ga;

  ga.Vdd = g.Vdd;
  ga.GND = g.GND;
  ga.pReset = g.pReset;
  ga._pReset = g._pReset;
  ga.sReset = g.sReset;
  ga._sReset = g._sReset;
  ga.vpsub = g.vpsub;
  ga.vnsub = g.vnsub;
  ga.RST = g.RST;
  ga.ADC_OUT = g.ADC_OUT;
  ga.V_REF = g.V_REF;
  ga.V_R = g.V_R;
  ga.V_G = g.V_G;
  ga.V_PE_PD = g.V_PE_PD;
  ga.V_PE_PU = g.V_PE_PU;
  ga.V_WINH = g.V_WINH;
  ga.V_WDC = g.V_WDC;
  ga.V_WEXC = g.V_WEXC;
  ga.V_IK_B = g.V_IK_B;
  ga.V_LK_A = g.V_LK_A;
  ga.V_IOFFSET = g.V_IOFFSET;

  aer::eMx1of2<M_1of2> aext_out;
  (;m:M_1of2: aext_out.b[m].t = SPK_TX.b[m].t; )
  (;m:M_1of2: aext_out.b[m].f = SPK_TX.b[m].f; )
  aext_out.e = SPK_TX.e;

  aer::eMx1of2<M_1of2> aerv_spk_in;
  (;m:M_1of2: aerv_spk_in.b[m].t = SPK_RX.b[m].t; )
  (;m:M_1of2: aerv_spk_in.b[m].f = SPK_RX.b[m].f; )

  aer::eMx1of2<M_1of2+6> aerv_mem_in;
  (;m:M_1of2: aerv_mem_in.b[m].t = MEM_RX.b[m].t; )
  (;m:M_1of2: aerv_mem_in.b[m].f = MEM_RX.b[m].f; )
  aerv_mem_in.e = MEM_RX.e;

  bool aext_nrn_req[p4M], aext_nrn_ack[p4M];
  (;m:p4M: aext_nrn_req[m] = AERSOMA[m].d; )
  (;m:p4M: aext_nrn_ack[m] = AERSOMA[m].e; )

  aer::a1of2 aerv_syn[p4M/4];
  (;m:p4M/4: aerv_syn[m].a = AERSYN[m].e; )
  (;m:p4M/4: aerv_syn[m].d = AERSYN[m].d; )

  aer::aMx1of4<4> aerv__mem[p4M/4/4];
  (;m:p4M/4/4:        aerv__mem[m].a = AERMEM[m].e; )
  (;m:p4M/4/4: (;i:4: aerv__mem[m].b[i].d = AERMEM[m].b[i].d; ) )

  BS_AER<M_1of2, M_1of4, p4M, p2M, tile_i, tile_j, unit_aext>
    base(ga, aext_nrn_req, aext_nrn_ack, aext_out, aerv_spk_in, aerv_mem_in, aerv_syn, aerv__mem);
}
