// defines a tile 16 neurons and 4 synapses
// also includes a intermediate receiver block
import "aer/aext/aext.act";
import "aer/aerv/aerv.act";
import "aer/interface/interface.act";

defproc Wrap_AEXT(aer::globals g) {
    // portion of AEXT tree servicing 16 neurons
    pint M = 2;
    pint N = 4;
    pint NN = 16;

    // AEXT_ 4 leafs 1 node
    pint AEXT_Mmax = 2; // max AEXT tree depth
    pint AEXT_Rmax = 4; // max repeaters between AEXT nodes
    pint AEXT_R[AEXT_Mmax];
    pint AEXT_Se[AEXT_Mmax][AEXT_Rmax], AEXT_Spd[AEXT_Mmax][AEXT_Rmax];
    pint AEXT_CAPe[AEXT_Mmax][AEXT_Rmax], AEXT_CAPpd[AEXT_Mmax][AEXT_Rmax];
    // repeaters per stage
    AEXT_R = {2, 2};
    // sizing per repeater per stage
    AEXT_Se = {{3, 10, 0, 0 },
               {3, 10, 0, 0 }};
    AEXT_Spd = {{5, 1, 0, 0 },
                {5, 1, 0, 0 }};
    // cap per repeater per stage
    AEXT_CAPe = {{4, 32, 0, 0  },
                 {4, 16, 0, 0  }};
    AEXT_CAPpd = {{32, 4, 0, 0  },
                  {16, 4, 0, 0  }};
    aer::transmitter::AEXT_<M, N, NN, false, AEXT_Mmax, AEXT_Rmax, 0, 
                            AEXT_R, AEXT_Se, AEXT_CAPe, AEXT_Spd, AEXT_CAPpd>
        aext(g,,,,,);
}

defproc Wrap_AERV(aer::globals g) {
    // portion of AERV tree servicing 4 synapses (16 neurons)
    pint N = 4;

    pint Mmax = 2; // max AERV tree depth
    pint Rmax = 4; // max repeaters between AERV nodes
    pint R[Mmax];
    pint S[Mmax][Rmax];
    pint CAP[Mmax][Rmax];
    // repeaters per stage
    R = {2, 2};
    // sizing per repeater per stage
    S = {{3, 10, 0, 0},
         {3, 10, 0, 0}};
    // cap per repeater per stage
    CAP = {{4, 64, 0, 0},
           {4, 32, 0, 0}};

    aer::receiver::AMP_WIRES<N, R[0], S[0][0..R[0]-1], CAP[0][0..R[0]-1]>
        w(g,,,,,,);
    aer::receiver::NODE<N, N> node(g, w._cpp, w._cpo,,, w.cp,);
    aer::receiver::AERV_<1, 4, 4, 1, Mmax, Rmax, 1, R, S, CAP>
        aerv_leaf(g, node._cp[0], node._ci[0],,,node.c[0],,);
    // might have to include a bit more of the memory periphery
    // 1of4 to 1of2 converter
    // valid/neutral check on last row word
}

export defproc Wrapper(aer::globals_np g_np)
{
    bool Vdd;
    bool GND;
    bool vpsub;
    bool vnsub;
    aer::globals g;

    // rails and reset
    g.Vdd = Vdd;
    g.GND = GND;
    g.vpsub = vpsub;
    g.vnsub = vnsub;
    g_np.sReset = g.sReset;
    g_np.pReset = g.pReset;
    g._pReset = g_np._pReset;
    g._sReset = g_np._sReset;

    Wrap_AEXT aext(g);
    Wrap_AERV aerv(g);
}

Wrapper dut;
