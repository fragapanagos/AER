// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/interface/interface.act";

namespace aer {

namespace receiver {
    export
    template <pint N>
    defproc NODE (globals g; bool _pp, _pe, _ce[N], _cp[N]; c1of<N> p, c[N]) {
        // node in AERV tree
        // N fanout (radix)
        bool u[N], _u[N], uu, _v, __v, pe;
        c1of<N> _p;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    u[n] => _u[n]-
                )

                (| : n : N : ~_u[n]) => uu+

                ~_pp & ~uu | (| : n : N : ~_ce[n]) => pe+

                _v => __v-

                (: n : N :
                    p.n[n] => _p.n[n]-
                )

                (: n : N :
                    ~_p.n[n] & ~__v -> u[n]+
                    _pp -> u[n]-
                )

                uu & (& : n : N : _p.n[n]) -> _v-
                ~uu -> _v+

                (: n : N :
                    __v & u[n] => _cp[n]-
                )

                (: np : N :
                    (: nc : N :
                        ~_p.n[np] & ~_cp[nc] => c[nc].n[np]+
                    )
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                pe => _pe-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    ~u[n]<9> -> _u[n]+
                    u[n]<6> -> _u[n]-
                )

                (| : n : N : ~_u[n]<12>) -> uu+
                (& : n : N : _u[n]<15>) -> uu-

                ~_pp<27> & ~uu<27> | (| : n : N : ~_ce[n]<27>) -> pe+
                (_pp<18> | uu<18>) & (& : n : N : _ce[n]<18>) -> pe-

                ~_v<15> -> __v+
                _v<9> -> __v-

                (: n : N :
                    ~p.n[n]<12> -> _p.n[n]+
                    p.n[n]<9> -> _p.n[n]-
                )

                (: n : N :
                    ~_p.n[n]<18> & ~__v<18> -> u[n]+
                    _pp<6> -> u[n]-
                )

                uu<18> & (& : n : N : _p.n[n]<18>) -> _v-
                ~uu<18> -> _v+

                (: n : N :
                    ~__v<12> | ~u[n]<12> -> _cp[n]+
                    __v<15> & u[n]<15> -> _cp[n]-
                )

                (: np : N :
                    (: nc : N :
                        ~_p.n[np]<18> & ~_cp[nc]<18> -> c[nc].n[np]+
                        _p.n[np]<6> | _cp[nc]<6> -> c[nc].n[np]-
                    )
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~pe<12> -> _pe+
                pe<9> -> _pe-
            }
        ]
    }

    export
    template <pint D, N_SYN, N_MEM>
    defproc LEAF (globals g; bool _pp, _pe; c1of<D> p;
                  bool cp_mem[N_MEM],
                  ce_syn[N_SYN], ce_mem[N_MEM];
                  c1of2 c_syn[N_SYN]; c1of<D> c_mem[N_MEM]) {
        // AERV tree LEAF supports {synapse, memory} port types
        // D 1-of-D data
        // N_SYN synapses
        // N_MEM memory ports
        pint SYN_PPORT = D / 2; // synapses per port
        // synapses receive 1-of-2 data, so multiple synapses can be packed on
        // a single port
        pint N_SYN_PORT = N_SYN / SYN_PPORT; // synapse ports
        pint F = N_SYN_PORT + N_MEM; // fanout
        [ F > D ->
            1=0; // assert false
        ]

        bool __pp, _u_syn[N_SYN_PORT], _u_mem[N_MEM], uu, _uu, v, _v;
        bool cp_syn[N_SYN_PORT];
        c1of2 _c_syn[N_SYN];
        c1of<D> _c_mem[N_MEM];
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (|:n:N_SYN_PORT: ~_u_syn[n]) | (|:n:N_MEM: ~_u_mem[n]) => uu+

                uu => _uu-

                __pp & _uu |
                    (|:n:N_SYN_PORT: cp_syn[n] &
                        (&:s:SYN_PPORT: (&:d:2: _c_syn[n*SYN_PPORT+s].d[d]))) |
                    (|:n:N_MEM: ce_mem[n]) => _pe-

                v => _v-
                
                (: n : N_SYN_PORT :
                    p.d[n] & _v -> _u_syn[n]-
                    ~__pp -> _u_syn[n]+
                    ~_v & ~_u_syn[n] => cp_syn[n]+
                )
                (: n : N_MEM :
                    p.d[n+N_SYN_PORT] & _v -> _u_mem[n]-
                    ~__pp -> _u_mem[n]+
                    ~_v & ~_u_mem[n] => cp_mem[n]+
                )

                ~_uu & (& : f : F : ~p.d[f]) -> v+
                _uu -> v-

                (: n : N_SYN_PORT :
                    (: nn : SYN_PPORT :
                        (: d : 2 :
                            p.d[nn*SYN_PPORT+d] & 
                                cp_syn[n] &
                                ce_syn[n*SYN_PPORT+nn] -> 
                                _c_syn[n*SYN_PPORT+nn].d[d]-
                            ~g._pReset | ~p.d[nn*SYN_PPORT+d] &
                                ~ce_syn[n*SYN_PPORT+nn] -> 
                                _c_syn[n*SYN_PPORT+nn].d[d]+
                        )
                    )
                )

                (: n : N_MEM :
                    (: d : D :
                        p.d[d] & cp_mem[n] => _c_mem[n].d[d]-
                    )
                )
            }
            // inverters for interfaces
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _pp => __pp-

                (: n : N_SYN :
                    (: d : 2 :
                        _c_syn[n].d[d] => c_syn[n].d[d]-
                    )
                )

                (: n : N_MEM :
                    (: d : D :
                        _c_mem[n].d[d] => c_mem[n].d[d]-
                    )
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (|:n:N_SYN_PORT: ~_u_syn[n]<9>) | (|:n:N_MEM: ~_u_mem[n]<9>) ->
                    uu+
                (&:n:N_SYN_PORT: _u_syn[n]<18>) & (&:n:N_MEM: _u_mem[n]<18>) ->
                    uu-

                ~uu<9> -> _uu+
                uu<6> -> _uu-

                __pp<12> & _uu<12> |
                    (|:n:N_SYN_PORT: cp_syn[n]<18> & (&:s:SYN_PPORT:
                        (&:d:2: _c_syn[n*SYN_PPORT+s].d[d]<18>))) |
                    (|:n:N_MEM: ce_mem[n]<6>) -> _pe-
                (~__pp<27> | ~_uu<27>) &
                    (&:n:N_SYN_PORT: ~cp_syn[n]<27> | (|:s:SYN_PPORT:
                        (|:d:2: ~_c_syn[n*SYN_PPORT+s].d[d]<27>))) &
                    (&:n:N_MEM: ~ce_mem[n]<27>) -> _pe+

                ~v<9> -> _v+
                v<6> -> _v-
                
                (: n : N_SYN_PORT :
                    p.d[n]<12> & _v<12> -> _u_syn[n]-
                    ~__pp<9> -> _u_syn[n]+

                    ~_v<18> & ~_u_syn[n]<18> -> cp_syn[n]+
                    _v<6> | _u_syn[n]<6> -> cp_syn[n]-
                )
                (: n : N_MEM :
                    p.d[n+N_SYN_PORT]<12> & _v<12> -> _u_mem[n]-
                    ~__pp<9> -> _u_mem[n]+

                    ~_v<18> & ~_u_mem[n]<18> -> cp_mem[n]+
                    _v<6> | _u_mem[n]<6> -> cp_mem[n]-
                )

                ~_uu<18> & (& : f : F : ~p.d[f]<18>) -> v+
                _uu<6> -> v-

                (: n : N_SYN_PORT :
                    (: nn : SYN_PPORT :
                        (: d : 2 :
                            p.d[nn*SYN_PPORT+d]<18> &
                                cp_syn[n]<18> &
                                ce_syn[n*SYN_PPORT+nn]<18> ->
                                _c_syn[n*SYN_PPORT+nn].d[d]-
                            ~g._pReset<9> | ~p.d[nn*SYN_PPORT+d]<18> &
                                ~ce_syn[n*SYN_PPORT+nn]<18> ->
                                _c_syn[n*SYN_PPORT+nn].d[d]+
                        )
                    )
                )

                (: n : N_MEM :
                    (: d : D :
                        p.d[d]<6> & cp_mem[n]<6> -> _c_mem[n].d[d]-
                        ~p.d[d]<9> | ~cp_mem[n]<9> -> _c_mem[n].d[d]+
                    )
                )
            }
            // inverters for interfaces
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _pp<6> -> __pp-
                ~_pp<9> -> __pp+

                (: n : N_SYN :
                    (: d : 2 :
                        _c_syn[n].d[d]<6> -> c_syn[n].d[d]-
                        ~_c_syn[n].d[d]<9> -> c_syn[n].d[d]+
                    )
                )

                (: n : N_MEM :
                    (: d : D :
                        _c_mem[n].d[d]<6> -> c_mem[n].d[d]-
                        ~_c_mem[n].d[d]<9> -> c_mem[n].d[d]+
                    )
                )
            }
        ]
    }

    export
    template <pint N>
    defproc LEAF_NODATA (globals g; bool pp, pe, ce[N], cp[N]; c1of<N> p) {
        // AERV tree LEAF that does not transmit data
        // N clients
        bool u, _pe, _ce[N], _cp[N];
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                ce[n] => _ce[n]-
            )

            pp & (& : n : N : _ce[n]) | u => _pe-

            (: n : N :
                p.d[n] -> _cp[n]-
                ~pp -> _cp[n]+
            )

            (| : n : N : ~_ce[n] & ~p.d[n]) => u+
        }
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                _cp[n] => cp[n]-
            )

            _pe => pe-
        }
    }

    template <pint M, N, L, BASE_IDX, IDXs, Rmax;
              pint R[M], S[M][Rmax], CAP[M][Rmax]>
    defproc AMP_WIRES_ (globals g; bool p__cp[L], p__ce[L], c__pp[L], c__pe[L];
                       c1of<N> p_c[L], c_p[L]) {
        // model the amplifier and wire capacitances internal to the aerv tree
        // D 1-of-D data
        // R repeater inverters
        // S[R] scales size of repeater inverters
        // CAP[R] capacitive load along repeaters (units of min size inverter cap)
        // in production: D=4
        // .--------------------------------------------------------------.
        // |                 link  | R | S              | CAP             |
        // |-----------------------|---|----------------|-----------------|
        // | array edge -> root    | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} |
        // | root       -> node[0] | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} |
        // | node[0]    -> node[1] | 4 | {3, 10, 6, 36} | {4, 64, 4, 64}  |
        // | node[1]    -> node[2] | 2 | {3, 10}        | {4, 64}         |
        // | node[2]    -> leaf    | 2 | {3, 10}        | {4, 32}         |
        // ----------------------------------------------------------------
        preal min_inv_cap = 0.25; // assume min_inv_cap=0.25
        
        preal C[R[0]];
        (; r : R[0] :
            C[r] = min_inv_cap * CAP[0][r];
        )
        REPEATER_BOOL<R[0], S[0][0..R[0]-1], C, 2> p__cp__c__pp[IDXs];
        REPEATER_BOOL<R[0], S[0][0..R[0]-1], C, 2> c__pe__p__ce[IDXs];
        REPEATER_c1of<N, R[0], S[0][0..R[0]-1], C, 2> p_c__c_p[IDXs];
        (; i : IDXs :
            p__cp__c__pp[i].g = g;
            p__cp__c__pp[i].i = p__cp[BASE_IDX+i];
            p__cp__c__pp[i].o = c__pp[BASE_IDX+i];

            c__pe__p__ce[i].g = g;
            c__pe__p__ce[i].i = c__pe[BASE_IDX+i];
            c__pe__p__ce[i].o = p__ce[BASE_IDX+i];

            p_c__c_p[i].g = g;
            p_c__c_p[i].i = p_c[BASE_IDX+i];
            p_c__c_p[i].o = c_p[BASE_IDX+i];
        )

        [ M > 1 ->
            AMP_WIRES_<M-1, N, L, BASE_IDX+IDXs, IDXs*N, Rmax, R[1..M-1],
                       S[1..M-1], CAP[1..M-1]> 
                _(g, p__cp, p__ce, c__pp, c__pe, p_c, c_p);
        ]
    }

    export
    template <pint M, N, L>
    defproc AMP_WIRES (globals g; bool p__cp[L], p__ce[L], c__pp[L], c__pe[L];
                       c1of<N> p_c[L], c_p[L]) {
        // model the amplifier and wire capacitances internal to the aerv tree
        // M depth of AERV tree (max 5)
        // N radix of AERV tree (N=4 in production)
        // L links in AERV tree = (N^M-1) / (N-1) = number of LEAFs and NODEs
        pint Mmax = 5; // max AERV tree depth
        [M > Mmax -> 0=1;] // assert false
        pint Rmax = 4; // max repeaters between AERV nodes
        pint R_ref[Mmax];
        pint S_ref[Mmax][Rmax], CAP_ref[Mmax][Rmax];
        // repeaters per stage
        R_ref = {4, 4, 4, 2, 2};
        // sizing per repeater per stage
        S_ref = {{3, 10, 6, 36},
                 {3, 10, 6, 36},
                 {3, 10, 6, 36},
                 {3, 10, 0, 0 },
                 {3, 10, 0, 0 }};
        // cap per repeater per stage
        CAP_ref = {{4, 64, 4, 192},
                   {4, 64, 4, 192},
                   {4, 64, 4, 64 },
                   {4, 64, 0, 0  },
                   {4, 32, 0, 0  }};

        pint R[M];
        pint S[M][Rmax], CAP[M][Rmax];
        pint Mbase = Mmax-M;
        R = R_ref[Mbase..Mmax-1];
        S = S_ref[Mbase..Mmax-1];
        CAP = CAP_ref[Mbase..Mmax-1];

        AMP_WIRES_<M, N, L, 0, 1, Rmax, R, S, CAP> 
            _(g, p__cp, p__ce, c__pp, c__pe, p_c, c_p);
    }
} // namespace receiver

export
template <pint M, N, pNM, N_SYN, N_MEM>
defproc AERV (globals g; bool pp, pe; c1of<N> p;
              e1of2 syn[N_SYN]; 
              bool yp_mem[N_MEM], ye_mem[N_MEM]; c1of<N> mem[N_MEM]) {
    // receiver capable of sending data to neuron
    // M tree levels
    // N 1-of-N data and fanout for intermediate nodes
    // pNM = N^M potential LEAF output ports
    // N_SYN synapses
    // N_MEM memories
    pint SYN_PPORT = N/2;
    pint N_SYN_PORT = N_SYN/SYN_PPORT;
    [ (N_SYN_PORT + N_MEM) > pNM ->
        0=1; // assert false
    ]

    pint N_LEAF = pNM/N; // = N^(M-1)
    pint N_NODE = (pNM-N) / (N*(N-1)); // = (N^(M-1)-1) / (N-1)
    pint N_LINK = N_LEAF + N_NODE; // = (N^M-1) / (N-1)

    pint SYN_PER_LEAF = N_SYN/N_LEAF;
    pint MEM_PER_LEAF = N_MEM/N_LEAF;
    receiver::LEAF<N, N_SYN/N_LEAF, N_MEM/N_LEAF> leaf[N_LEAF];
    (; n : N_LEAF :
        leaf[n].g = g;
        (; ns : SYN_PER_LEAF :
            leaf[n].ce_syn[ns] = syn[n*SYN_PER_LEAF+ns].e;
            leaf[n].c_syn[ns] = syn[n*SYN_PER_LEAF+ns].m;
        )
        (; nm : MEM_PER_LEAF :
            leaf[n].cp_mem[nm] = yp_mem[n*MEM_PER_LEAF+nm];
            leaf[n].ce_mem[nm] = ye_mem[n*MEM_PER_LEAF+nm];
            leaf[n].c_mem[nm] = mem[n*MEM_PER_LEAF+nm];
        )
    )

    receiver::AMP_WIRES<M, N, N_LINK> repeater_wires(g,,,,,,);
    repeater_wires.p_c[0] = p;
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        // convert between active low/high inside/outside of array
        ~pp<9> -> repeater_wires.p__cp[0]+
        pp<6> -> repeater_wires.p__cp[0]-

        ~repeater_wires.p__ce[0]<9> -> pe+
        repeater_wires.p__ce[0]<6> -> pe-
    }

    [ M = 1 ->
        pNM = N; // assert
        leaf[0]._pp = repeater_wires.c__pp[0];
        leaf[0]._pe = repeater_wires.c__pe[0];
        leaf[0].p = repeater_wires.c_p[0];
    [] M > 1 ->
        receiver::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        node[0]._pp = repeater_wires.c__pp[0];
        node[0]._pe = repeater_wires.c__pe[0];
        node[0].p = repeater_wires.c_p[0];

        // connect NODEs to LEAFs
        pint N_LOW_NODE = N_LEAF/N; // NODEs connecting to LEAFs
        pint NODE_BASE_IDX = N_NODE-N_LOW_NODE;
        (; node_idx : NODE_BASE_IDX..N_NODE-1 :
            (; n : N :
                node[node_idx]._ce[n] = repeater_wires.p__ce[node_idx*N+n+1];
                node[node_idx]._cp[n] = repeater_wires.p__cp[node_idx*N+n+1];
                node[node_idx].c[n] = repeater_wires.p_c[node_idx*N+n+1];

                repeater_wires.c__pe[node_idx*N+n+1] =
                    leaf[(node_idx-NODE_BASE_IDX)*N+n]._pe;
                repeater_wires.c__pp[node_idx*N+n+1] =
                    leaf[(node_idx-NODE_BASE_IDX)*N+n]._pp;
                repeater_wires.c_p[node_idx*N+n+1] =
                    leaf[(node_idx-NODE_BASE_IDX)*N+n].p;
            )
        )

        // connect NODEs to NODEs
        [ M > 2 ->
            (; np : NODE_BASE_IDX :
                (; nc : N :
                    node[np]._ce[nc] = repeater_wires.p__ce[np*N+nc+1];
                    node[np]._cp[nc] = repeater_wires.p__cp[np*N+nc+1];
                    node[np].c[nc] =  repeater_wires.p_c[np*N+nc+1];

                    repeater_wires.c__pe[np*N+nc+1] =
                        node[np*N+nc+1]._pe;
                    repeater_wires.c__pp[np*N+nc+1] =
                        node[np*N+nc+1]._pp;
                    repeater_wires.c_p[np*N+nc+1] =
                        node[np*N+nc+1].p;
                )
            )
        ]
    ]
}

export
template <pint M, N, NN>
defproc AERV_NODATA (globals g; bool ye[NN], yp[NN], pp, pe; c1of<N> p) {
    // receiver that does not send data to targets
    //     (targets could be synapses or neurons)
    // M depth of AERV tree
    // N radix of AERV tree
    // NN targets = N^M
    pint N_LEAF = NN/N; // = N^(M-1)
    pint N_NODE = (NN-N) / (N*(N-1)); // = (N^(M-1)-1) / (N-1)
    // N_LEAF + N_NODE = (N^M-1) / (N-1)

    receiver::LEAF_NODATA<N> leaf[N_LEAF];

    (; n : N_LEAF :
        leaf[n].g = g;
        leaf[n].cp = yp[n*N..(n+1)*N-1];
        leaf[n].ce = ye[n*N..(n+1)*N-1];
    )

    [ M = 1 ->
        NN = N; // assert
        leaf[0].pe = pe;
        leaf[0].pp = pp;
        leaf[0].p = p;
    [] M > 1 ->
        receiver::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            pp => node[0]._pp-
            node[0]._pe => pe-
        }
        node[0].p = p;

        // connect NODEs to LEAFs
        pint N_LOW_NODE = N_LEAF/N; // NODEs connecting to LEAFs
        pint NODE_BASE_IDX = N_NODE-N_LOW_NODE;
        (; node_idx : NODE_BASE_IDX..N_NODE-1 :
            (; n : N :
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    leaf[(node_idx-NODE_BASE_IDX)*N+n].pe => node[node_idx]._ce[n]-
                    node[node_idx]._cp[n] => leaf[(node_idx-NODE_BASE_IDX)*N+n].pp-
                }
                node[node_idx].c[n] = leaf[(node_idx-NODE_BASE_IDX)*N+n].p;
            )
        )

        [ M > 2 ->
            (; np : NODE_BASE_IDX :
                (; nc : N :
                    node[np]._cp[nc] = node[np*N+nc+1]._pp;
                    node[np]._ce[nc] = node[np*N+nc+1]._pe;
                    node[np].c[nc] =  node[np*N+nc+1].p;
                )
            )
        ]
    ]
}

export
template <pint M, p4M>
defproc AERV_TO_TILE (globals g; bool pp, pe; c1of<4> p;
                      bool _cp[p4M/4], _ce[p4M/4]; c1of<4> c[p4M/4]) {
    // AERV tree above the TILE (in logic space)
    // contains all of the intermediate NODEs
    // M tree levels
    // p4M = 4^M potential LEAF output ports
    pint N = 4; // required for TILE
    pint N_NODE = (p4M-N) / (N*(N-1)); // = (N^(M-1)-1) / (N-1)
    pint N_LEAF = p4M/N; // = N^(M-1)

    [ M = 1 ->
        p4M = 4; // assert
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            pp => _cp[0]-
            _ce[0] => pe-
        }
        c[0] = p;
    [] M > 1 ->
        receiver::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            pp => node[0]._pp-
            node[0]._pe => pe-
        }
        node[0].p = p;

        // connect NODEs to LEAF ports 
        pint N_LOW_NODE = N_LEAF/N; // NODEs connecting to LEAF ports
        pint NODE_BASE_IDX = N_NODE-N_LOW_NODE;
        (; node_idx : NODE_BASE_IDX..N_NODE-1 :
            (; n : N :
                node[node_idx]._ce[n] = _ce[(node_idx-NODE_BASE_IDX)*N+n];
                node[node_idx]._cp[n] = _cp[(node_idx-NODE_BASE_IDX)*N+n];
                node[node_idx].c[n] = c[(node_idx-NODE_BASE_IDX)*N+n];
            )
        )

        // connect NODEs to NODEs
        [ M > 2 ->
            (; np : NODE_BASE_IDX :
                (; nc : N :
                    node[np]._cp[nc] = node[np*N+nc+1]._pp;
                    node[np]._ce[nc] = node[np*N+nc+1]._pe;
                    node[np].c[nc] =  node[np*N+nc+1].p;
                )
            )
        ]
    ]
}

namespace brain_receiver {
    export
    template <pint M_SPK, M_MEM>
    defproc AERV_INT (globals g; eMx1of4<M_SPK> x_spk; eMx1of4<M_MEM> x_mem;
                      bool aerv_pp, aerv_pe; c1of<4> aerv_p) {
        // interface between datapath and receiver
        // merges input spike and input memory packet streams
        pint D = 4; // 1-of-D data
        ::aer::interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
        ::aer::interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
        (; m : M_SPK :
            serial_spk.x.m[m].d = x_spk.m[m].d;
        )
        (; m : M_MEM :
            serial_mem.x.m[m].d = x_mem.m[m].d;
        )
        serial_spk.x.e = x_spk.e;
        serial_mem.x.e = x_mem.e;

        bool merge_xp[2];
        bool merge_xe[2];
        c1of<D> merge_x[2];
        merge_xp[0] = serial_spk.yp;
        merge_xp[1] = serial_mem.yp;
        merge_xe[0] = serial_spk.ye;
        merge_xe[1] = serial_mem.ye;
        merge_x[0] = serial_spk.y;
        merge_x[1] = serial_mem.y;

        ::aer::interface::SERIAL_MERGE<2, D> merge(
            g, merge_xp, merge_xe, aerv_pe, aerv_pp, merge_x, aerv_p);
    }

    export
    template <pint C>
    defproc MERGE_ACK (globals g; bool pp, pe, ce[C]) {
        // merges acknowledges from children with pphi acknowledge
        // C clients
        bool _pp;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                pp => _pp-

                ~_pp & (& : c : C : ~ce[c]) => pe+
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~pp<9> -> _pp+
                pp<6> -> _pp-

                ~_pp<12> & (& : c : C : ~ce[c]<12>) -> pe+
                _pp<6> | (| : c : C : ce[c]<6>) -> pe-
            }
        ]
    }

    export
    template <pint M, D>
    defproc DESERIALIZER (globals g; bool xp, xe; c1of<D> x; eMx1ofN<M, D> _y) {
        // wrapper for the deserializer
        pbool invert_y = true;
        pbool flip = true;

        MERGE_ACK<1> merge_ack(g, xp, xe,);
        ::aer::interface::DESERIAL_RING<M, D, invert_y, flip> deserial(g,,);
        deserial.x.d = x.d;
        deserial.x.a = merge_ack.ce[0];
        (; m : M :
            deserial.y.m[m].d = _y.m[m].d;
        )
        deserial.y.e = _y.e;
    }

    export
    template <pint N>
    defproc HALF_BUFFER (globals g; e1of2 x[N]; a1of2 y[N]) {
        // prevents the synapse from holding up the receiver tree
        // wchb providing a half cycle of buffering
        pint D = 2; // for 1of2
        bool ye[N];
        c1of2 _y[N];
        c1of2 __y[N];
        (; n : N :
            __y[n] = y[n].m;
        )
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    y[n].a => ye[n]-

                    (& : d : D : ~y[n].d[d]) => x[n].e+

                    (: d : D :
                        x[n].d[d] & ye[n] -> _y[n].d[d]-
                        ~g._pReset | ~x[n].d[d] & ~ye[n] -> _y[n].d[d]+
                    )

                    (: d : D :
                        _y[n].d[d] => __y[n].d[d]-
                    )
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    ~y[n].a<9> -> ye[n]+
                    y[n].a<6> -> ye[n]-

                    (& : d : D : ~y[n].d[d]<18>) -> x[n].e+
                    (| : d : D : y[n].d[d]<6>) -> x[n].e-

                    (: d : D :
                        x[n].d[d]<18> & ye[n]<18> -> _y[n].d[d]-
                        ~g._pReset<9> |
                            ~x[n].d[d]<12> & ~ye[n]<12> -> _y[n].d[d]+
                    )

                    (: d : D :
                        ~_y[n].d[d]<9> -> __y[n].d[d]+
                        _y[n].d[d]<6> -> __y[n].d[d]-
                    )
                )
            }
        ]
    }
} // namespace brain_receiver

export
template <pint M, p4M, M_SPK, M_MEM, N_SYN, N_MEM>
defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                    eMx1of4<M_MEM> x_mem;
                    a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> _y_mem[N_MEM]) {
    // braindrop / brainstorm receiver system
    // M tree depth
    //     M = 5 in production
    // p4M potential ports
    //     p4M = 4^M
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK = M + 1 = 6 in production
    // M_MEM packet length to write config memory
    //     M_MEM = M + memory packet length = 9 in production
    // N_SYN synapses
    //     N_SYN = 4^M = 1024 in production
    // N_MEM configuration memories
    //     N_MEM = 4^(M-1) = 256 in production
    pint D = 4; // 1-of-D data
    N_MEM*4 = N_SYN; // assert

    brain_receiver::AERV_INT<M_SPK, M_MEM> aerv_int(g, x_spk, x_mem,,,);
    brain_receiver::DESERIALIZER<M_MEM-M, D> mem_deserial[N_MEM];
    bool aerv_yp_mem[N_MEM];
    bool aerv_ye_mem[N_MEM];
    c1of<D> aerv_mem[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        // connect deserial to aerv
        mem_deserial[n].xp = aerv_yp_mem[n];
        mem_deserial[n].xe = aerv_ye_mem[n];
        mem_deserial[n].x = aerv_mem[n];
        // connect deserial to memory
        (; m : M_MEM-M :
            mem_deserial[n]._y.m[m].d = _y_mem[n].m[m].d;
        )
        mem_deserial[n]._y.e = _y_mem[n].e;
    )
    
    // buffer synapse spikes
    e1of2 aerv_syn[N_SYN];
    brain_receiver::HALF_BUFFER<N_SYN> buf_syn(g, aerv_syn, y_syn);

    AERV<M, D, p4M, N_SYN, N_MEM> aerv(
        g, aerv_int.aerv_pp, aerv_int.aerv_pe, aerv_int.aerv_p,
        aerv_syn, aerv_yp_mem, aerv_ye_mem, aerv_mem);
}

} // namespace aer
