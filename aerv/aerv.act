// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/interface/interface.act";

namespace aer {

namespace receiver {
    export
    template <pint F, D>
    defproc NODE (globals g; bool _pp, _po, _ci[F], _cp[F]; c1of<D> p, c[F]) {
        // AERV tree NODE
        // F fanout (radix)
        // D 1-of-D data
        bool u[F], _u[F], uu, _v, __v, po;
        c1of<D> _p;
        [ (~LAYOUT | F < 3 | F > 4) ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: f : F :
                    u[f] => _u[f]-
                )

                (| : f : F : ~_u[f]) => uu+

                ~_pp & ~uu | (| : f : F : ~_ci[f]) => po+

                _v => __v-

                (: d : D :
                    p.d[d] => _p.d[d]-
                )

                (: f : F :
                    ~_p.d[f] & ~__v -> u[f]+
                    _pp -> u[f]-
                )

                uu & (& : f : F : _p.d[f]) -> _v-
                ~uu -> _v+

                (: f : F :
                    __v & u[f] => _cp[f]-
                )

                (: f : F :
                    (: d : D :
                        ~_p.d[d] & ~_cp[f] => c[f].d[d]+
                    )
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                po => _po-
            }
        [] LAYOUT ->
            [ F = 3 ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: f : F :
                        ~u[f]<9> -> _u[f]+
                        u[f]<6> -> _u[f]-
                    )

                    (| : f : F : ~_u[f]<12>) -> uu+
                    (& : f : F : _u[f]<12>) -> uu-

                    ~_pp<27> & ~uu<27> | (| : f : F : ~_ci[f]<27>) -> po+
                    (_pp<18> | uu<18>) & (& : f : F : _ci[f]<18>) -> po-

                    ~_v<12> -> __v+
                    _v<9> -> __v-

                    (: d : D :
                        ~p.d[d]<12> -> _p.d[d]+
                        p.d[d]<9> -> _p.d[d]-
                    )

                    (: f : F :
                        ~_p.d[f]<18> & ~__v<18> -> u[f]+
                        _pp<6> -> u[f]-
                    )

                    uu<18> & (& : f : F : _p.d[f]<18>) -> _v-
                    ~uu<15> -> _v+

                    (: f : F :
                        ~__v<12> | ~u[f]<12> -> _cp[f]+
                        __v<15> & u[f]<15> -> _cp[f]-
                    )

                    (: f : F :
                        (: d : D :
                            ~_p.d[d]<18> & ~_cp[f]<18> -> c[f].d[d]+
                            _p.d[d]<6> | _cp[f]<6> -> c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    ~po<12> -> _po+
                    po<9> -> _po-
                }
            [] F = 4 ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: f : F :
                        ~u[f]<9> -> _u[f]+
                        u[f]<6> -> _u[f]-
                    )

                    (| : f : F : ~_u[f]<12>) -> uu+
                    (& : f : F : _u[f]<15>) -> uu-

                    ~_pp<27> & ~uu<27> | (| : f : F : ~_ci[f]<27>) -> po+
                    (_pp<18> | uu<18>) & (& : f : F : _ci[f]<18>) -> po-

                    ~_v<15> -> __v+
                    _v<9> -> __v-

                    (: d : D :
                        ~p.d[d]<12> -> _p.d[d]+
                        p.d[d]<9> -> _p.d[d]-
                    )

                    (: f : F :
                        ~_p.d[f]<18> & ~__v<18> -> u[f]+
                        _pp<6> -> u[f]-
                    )

                    uu<18> & (& : f : F : _p.d[f]<18>) -> _v-
                    ~uu<18> -> _v+

                    (: f : F :
                        ~__v<12> | ~u[f]<12> -> _cp[f]+
                        __v<15> & u[f]<15> -> _cp[f]-
                    )

                    (: f : F :
                        (: d : D :
                            ~_p.d[d]<18> & ~_cp[f]<18> -> c[f].d[d]+
                            _p.d[d]<6> | _cp[f]<6> -> c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    ~po<12> -> _po+
                    po<9> -> _po-
                }
            ]
        ]
    }

    export
    defproc LEAF (globals g; bool _pp, _po, cp[4], ci[4]; c1of<4> p; e1of2 syn[4]; c1of4 mem) {
        // node in AERV tree
        pint D = 4; // 1-of-D data
        pint F = 3; // fanout ports
        bool pp, _u[F], uu, _uu, v, _v;
        e1of2 syn_[2][2];
        (; c : 2 : (; s : 2 : syn_[c][s] = syn[2*c+s];))
        c1of2 _syn_d[2][2];
        c1of4 _mem;
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (| : f : F : ~_u[f]) => uu+

            uu => _uu-

            pp & _uu |
            (|:c:2: cp[c] & (&:s:2: (&:d:2: _syn_d[c][s].d[d]))) | ci[2] => _po-

            v => _v-
            
            (: f : F :
                p.d[f] & _v -> _u[f]-
                ~pp -> _u[f]+
            )

            uu & (& : f : F : ~p.d[f]) -> v+
            ~uu -> v-

            (: f : F :
                ~_v & ~_u[f] => cp[f]+
            )

            (: c : 2 :
                (: s : 2 :
                    (: d : 2 :
                        p.d[2*s+d] & cp[c] & syn_[c][s].e -> _syn_d[c][s].d[d]-
                        g.pReset | ~p.d[2*s+d] & ~syn_[c][s].e -> _syn_d[c][s].d[d]+
                    )
                )
            )

            (: d : D :
                p.d[d] & cp[2] => _mem.d[d]-
            )
        }
        // inverters for interfaces
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            _pp => pp-

            (: c : 2 :
                (: s : 2 :
                    (: d : 2 :
                        _syn_d[c][s].d[d] => syn_[c][s].d[d]-
                    )
                )
            )

            (: d : D :
                _mem.d[d] => mem.d[d]-
            )

        }

        // ground dummy nodes
        ci[0] = g.GND;
        ci[1] = g.GND;
        ci[3] = g.GND;
        cp[3] = g.GND;
    }

    export
    template <pint N>
    defproc LEAF_NODATA (globals g; bool pp, po, ci[N], cp[N]; c1of<N> p) {
        // AERV tree LEAF that does not transmit data
        // N clients
        bool u, _po, _ci[N], _cp[N];
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                ci[n] => _ci[n]-
            )

            pp & (& : n : N : _ci[n]) | u => _po-

            (: n : N :
                p.d[n] -> _cp[n]-
                ~pp -> _cp[n]+
            )

            (| : n : N : ~_ci[n] & ~p.d[n]) => u+
        }
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                _cp[n] => cp[n]-
            )

            _po => po-
        }
    }

    export
    template <pint M, Mp4, N_SYN, N_MEM>
    defproc AERV_ (globals g; bool _pp, _po, cp[Mp4], ci[Mp4]; c1of<4> p; e1of2 syn[N_SYN]; c1of4 mem[N_MEM]) {
        // utility for AERV
        pint D = 4; // 1-of-D data
        pint F = 4; // fanout for intermediate nodes
        [ M = 1 ->
            N_SYN = 4; // assert
            N_MEM = 1; // assert
            Mp4 = 4; // assert
            LEAF leaf(g, _pp, _po, cp, ci, p, syn, mem[0]);
        [] M > 1 ->
            N_MEM*4 = N_SYN; // assert
            pint k = Mp4/4;
            pint k_syn = N_SYN/4;
            pint k_mem = N_MEM/4;
            AERV_<M-1, k, k_syn, k_mem> _[F];
            NODE<F, D> node(g, _pp, _po,,, p,);
            (; f : F:
                _[f].g = g;
                _[f].p = node.c[f];
                _[f]._pp = node._cp[f];
                _[f]._po = node._ci[f];
                _[f].cp = cp[f*k..(f+1)*k-1];
                _[f].ci = ci[f*k..(f+1)*k-1];
                _[f].syn = syn[f*k_syn..(f+1)*k_syn-1];
                _[f].mem = mem[f*k_mem..(f+1)*k_mem-1];
            )
        ]
    }

    export
    template <pint M, N, NN>
    defproc AERV_NODATA_ (globals g; bool yi[NN], yp[NN], _pp, _po; c1of<N> p) {
        // utility for AERV_NODATA
        [ M = 1 ->
            NN = N;
            LEAF_NODATA<N> leaf(g,,, yi, yp, p);
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _pp => leaf.pp-
                leaf.po => _po-
            }
        [] M > 1 ->
            AERV_NODATA_<M-1, N, NN/N> _[N];
            NODE<N, N> node(g, _pp, _po,,, p,);
            pint k = NN/N;
            (; n : N :
                _[n].g = g;
                _[n].p = node.c[n];
                _[n]._pp = node._cp[n];
                _[n]._po = node._ci[n];
                _[n].yi = yi[n*k..(n+1)*k-1];
                _[n].yp = yp[n*k..(n+1)*k-1];
            )
        ]
    }
} // namespace receiver

export
template <pint M, Mp4, N_SYN, N_MEM>
defproc AERV (globals g; bool pp, po, cp[Mp4], ci[Mp4]; c1of<4> p; e1of2 syn[N_SYN]; c1of4 mem[N_MEM]) {
    // receiver capable of sending data to neuron
    // M tree levels
    // Mp4 = M^4 potential output ports
    // N_SYN synapses
    // N_MEM memories
    bool aerv__pp;
    bool aerv__po;
    receiver::AERV_<M, Mp4, N_SYN, N_MEM> _(g, aerv__pp, aerv__po, cp, ci, p, syn, mem);
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        ~pp<9> -> aerv__pp+
        pp<6> -> aerv__pp-
        ~aerv__po<9> -> po+
        aerv__po<6> -> po-
    }
}

export
template <pint M, N, NN>
defproc AERV_NODATA (globals g; bool yi[NN], yp[NN], pp, po; c1of<N> p) {
    // basic receiver that only sends sppkes to neurons
    // single sppke type, no excitatory/inhibitory sppke types 
    [ M = 1 ->
        NN = N;
        receiver::LEAF_NODATA<N> leaf(g, pp, po, yi, yp, p);
    [] M > 1 ->
        receiver::AERV_NODATA_<M, N, NN> _(g, yi, yp,,, p);
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            pp => _._pp-
            _._po => po-
        }
    ]
}

namespace brain_receiver {
    export
    template <pint C>
    defproc MERGE_ACK (globals g; bool pp, po, ci[C]) {
        // merges acknowledges from children with pphi acknowledge
        // C clients
        bool _pp;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                pp => _pp-

                ~_pp & (& : c : C : ~ci[c]) => po+
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~pp<9> -> _pp+
                pp<6> -> _pp-

                ~_pp & (& : c : C : ~ci[c]) -> po+
                _pp | (| : c : C : ci[c]) -> po-
            }
        ]
    }

    export
    template <pint M>
    defproc DESERIALIZER (globals g; bool xp, xo; c1of4 x; eMx1of4<M> y) {
        // wrapper for the deserializer
        pint D = 4; // 1-of-D data

        MERGE_ACK<1> merge_ack(g, xp, xo,);
        ::aer::interface::DESERIAL_RING<M, D> deserial(g,,);
        deserial.x.d = x.d;
        deserial.x.a = merge_ack.ci[0];
        (; m : M :
            deserial.y.m[m].d = y.m[m].d;
        )
        deserial.y.e = y.e;
    }

    export
    defproc HALF_BUFFER (globals g; e1of2 x; a1of2 y) {
        // prevents the synapse from holding up the receiver tree
        // wchb providing a half cycle of buffering
        pint D = 2; // for 1of2
        bool ye;
        c1of2 _y;
        c1of2 __y = y.m;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                y.a => ye-

                (& : d : D : ~y.d[d]) => x.e+

                (: d : D :
                    x.d[d] & ye -> _y.d[d]-
                    ~g._pReset | ~x.d[d] & ~ye -> _y.d[d]+
                )

                (: d : D :
                    _y.d[d] => __y.d[d]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~y.a<9> -> ye+
                y.a<6> -> ye-

                (& : d : D : ~y.d[d]<18>) -> x.e+
                (| : d : D : y.d[d]<6>) -> x.e-

                (: d : D :
                    x.d[d]<18> & ye<18> -> _y.d[d]-
                    ~g._pReset | ~x.d[d]<12> & ~ye<12> -> _y.d[d]+
                )

                (: d : D :
                    ~_y.d[d]<9> -> __y.d[d]+
                    _y.d[d]<6> -> __y.d[d]-
                )
            }
        ]
    }
} // namespace brain_receiver

export
template <pint M, Mp4, M_SPK, M_MEM, N_SYN, N_MEM>
defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                    eMx1of4<M_MEM> x_mem;
                    a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> y_mem[N_MEM]) {
    // braindrop / brainstorm receiver system
    // M tree depth
    //     M = 5 (in production)
    // Mp4 potential ports
    //     Mp4 = M^4
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK = M + 1
    //     M_SPK = 6 (in production)
    // M_MEM packet length to write config memory
    //     M_MEM = M + memory packet length
    //     M_MEM = 9 (in production)
    // N_SYN synapses
    //     N_SYN = 4^M
    //     N_SYN = 1024 (in production)
    // N_MEM configuration memories
    //     N_MEM = 4^(M-1)
    //     N_MEM = 256 (in production)
    pint D = 4;
    N_MEM*4 = N_SYN; // assert

    interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
    interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
    (; m : M_SPK :
        serial_spk.x.m[m].d = x_spk.m[m].d;
    )
    (; m : M_MEM :
        serial_mem.x.m[m].d = x_mem.m[m].d;
    )
    serial_spk.x.e = x_spk.e;
    serial_mem.x.e = x_mem.e;

    bool merge_xp[2];
    bool merge_xo[2];
    c1of<D> merge_x[2];
    merge_xp[0] = serial_spk.yp;
    merge_xp[1] = serial_mem.yp;
    merge_xo[0] = serial_spk.yi;
    merge_xo[1] = serial_mem.yi;
    merge_x[0] = serial_spk.y;
    merge_x[1] = serial_mem.y;

    interface::SERIAL_MERGE<2, D> merge(g, merge_xp, merge_xo,,, merge_x,);
    bool aerv_pp = merge.yp;
    bool aerv_po = merge.yi;
    c1of<D> aerv_p = merge.y;

    brain_receiver::DESERIALIZER<M_MEM-M> mem_deserial[N_MEM];
    bool aerv_cp[Mp4];
    bool aerv_ci[Mp4];
    c1of4 aerv_mem[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        mem_deserial[n].xp = aerv_cp[n*4+2]; // connect deserial to aerv
        mem_deserial[n].xo = aerv_ci[n*4+2];
        mem_deserial[n].x = aerv_mem[n];
        mem_deserial[n].y = y_mem[n]; // connect deserial to memory
    )
    
    brain_receiver::HALF_BUFFER buf_syn[N_SYN]; // buffer synapse spikes
    e1of2 aerv_syn[N_SYN];
    (; n : N_SYN :
        buf_syn[n].g = g;
        buf_syn[n].x = aerv_syn[n]; // connect buf_syn to aerv
        buf_syn[n].y = y_syn[n]; // connect buf_syn to synapse
    )

    AERV<M, Mp4, N_SYN, N_MEM> aerv(
        g, aerv_pp, aerv_po, aerv_cp, aerv_ci, aerv_p, aerv_syn, aerv_mem);
}

} // namespace aer
