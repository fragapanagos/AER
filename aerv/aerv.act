// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/interface/interface.act";

namespace aer {

namespace receiver {
    export
    template <pint F, D>
    defproc NODE (globals g; bool _pp, _po, _ci[F], _cp[F]; c1of<D> p, c[F]) {
        // AERV tree NODE
        // F fanout (radix)
        // D 1-of-D data
        bool u[F], _u[F], uu, _v, __v, po;
        c1of<D> _p;
        [ (~LAYOUT | F < 3 | F > 4) ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: f : F :
                    u[f] => _u[f]-
                )

                (| : f : F : ~_u[f]) => uu+

                ~_pp & ~uu | (| : f : F : ~_ci[f]) => po+

                _v => __v-

                (: d : D :
                    p.d[d] => _p.d[d]-
                )

                (: f : F :
                    ~_p.d[f] & ~__v -> u[f]+
                    _pp -> u[f]-
                )

                uu & (& : f : F : _p.d[f]) -> _v-
                ~uu -> _v+

                (: f : F :
                    __v & u[f] => _cp[f]-
                )

                (: f : F :
                    (: d : D :
                        ~_p.d[d] & ~_cp[f] => c[f].d[d]+
                    )
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                po => _po-
            }
        [] LAYOUT ->
            [ F = 3 ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: f : F :
                        ~u[f]<9> -> _u[f]+
                        u[f]<6> -> _u[f]-
                    )

                    (| : f : F : ~_u[f]<12>) -> uu+
                    (& : f : F : _u[f]<12>) -> uu-

                    ~_pp<27> & ~uu<27> | (| : f : F : ~_ci[f]<27>) -> po+
                    (_pp<18> | uu<18>) & (& : f : F : _ci[f]<18>) -> po-

                    ~_v<12> -> __v+
                    _v<9> -> __v-

                    (: d : D :
                        ~p.d[d]<12> -> _p.d[d]+
                        p.d[d]<9> -> _p.d[d]-
                    )

                    (: f : F :
                        ~_p.d[f]<18> & ~__v<18> -> u[f]+
                        _pp<6> -> u[f]-
                    )

                    uu<18> & (& : f : F : _p.d[f]<18>) -> _v-
                    ~uu<15> -> _v+

                    (: f : F :
                        ~__v<12> | ~u[f]<12> -> _cp[f]+
                        __v<15> & u[f]<15> -> _cp[f]-
                    )

                    (: f : F :
                        (: d : D :
                            ~_p.d[d]<18> & ~_cp[f]<18> -> c[f].d[d]+
                            _p.d[d]<6> | _cp[f]<6> -> c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    ~po<12> -> _po+
                    po<9> -> _po-
                }
            [] F = 4 ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: f : F :
                        ~u[f]<9> -> _u[f]+
                        u[f]<6> -> _u[f]-
                    )

                    (| : f : F : ~_u[f]<12>) -> uu+
                    (& : f : F : _u[f]<15>) -> uu-

                    ~_pp<27> & ~uu<27> | (| : f : F : ~_ci[f]<27>) -> po+
                    (_pp<18> | uu<18>) & (& : f : F : _ci[f]<18>) -> po-

                    ~_v<15> -> __v+
                    _v<9> -> __v-

                    (: d : D :
                        ~p.d[d]<12> -> _p.d[d]+
                        p.d[d]<9> -> _p.d[d]-
                    )

                    (: f : F :
                        ~_p.d[f]<18> & ~__v<18> -> u[f]+
                        _pp<6> -> u[f]-
                    )

                    uu<18> & (& : f : F : _p.d[f]<18>) -> _v-
                    ~uu<18> -> _v+

                    (: f : F :
                        ~__v<12> | ~u[f]<12> -> _cp[f]+
                        __v<15> & u[f]<15> -> _cp[f]-
                    )

                    (: f : F :
                        (: d : D :
                            ~_p.d[d]<18> & ~_cp[f]<18> -> c[f].d[d]+
                            _p.d[d]<6> | _cp[f]<6> -> c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    ~po<12> -> _po+
                    po<9> -> _po-
                }
            ]
        ]
    }

    export
    defproc LEAF (globals g; bool _pp, _po, cp[4], ci[4]; c1of<4> p; e1of2 syn[4]; c1of4 mem) {
        // node in AERV tree
        pint D = 4; // 1-of-D data
        pint F = 3; // fanout ports
        bool __pp, _u[F], uu, _uu, v, _v;
        e1of2 syn_[2][2];
        (; c : 2 : (; s : 2 : syn_[c][s] = syn[2*c+s];))
        c1of2 _syn_d[2][2];
        c1of4 _mem;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (| : f : F : ~_u[f]) => uu+

                uu => _uu-

                __pp & _uu |
                (|:c:2: cp[c] & (&:s:2: (&:d:2: _syn_d[c][s].d[d]))) | ci[2] => _po-

                v => _v-
                
                (: f : F :
                    p.d[f] & _v -> _u[f]-
                    ~__pp -> _u[f]+
                )

                ~_uu & (& : f : F : ~p.d[f]) -> v+
                _uu -> v-

                (: f : F :
                    ~_v & ~_u[f] => cp[f]+
                )

                (: c : 2 :
                    (: s : 2 :
                        (: d : 2 :
                            p.d[2*s+d] & cp[c] & syn_[c][s].e -> _syn_d[c][s].d[d]-
                            ~g._pReset | ~p.d[2*s+d] & ~syn_[c][s].e -> _syn_d[c][s].d[d]+
                        )
                    )
                )

                (: d : D :
                    p.d[d] & cp[2] => _mem.d[d]-
                )
            }
            // inverters for interfaces
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _pp => __pp-

                (: c : 2 :
                    (: s : 2 :
                        (: d : 2 :
                            _syn_d[c][s].d[d] => syn_[c][s].d[d]-
                        )
                    )
                )

                (: d : D :
                    _mem.d[d] => mem.d[d]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (| : f : F : ~_u[f]<9>) -> uu+
                (& : f : F : _u[f]<18>) -> uu-

                ~uu<9> -> _uu+
                uu<6> -> _uu-

                __pp<12> & _uu<12> |
                (|:c:2: cp[c]<18> & (&:s:2: (&:d:2: _syn_d[c][s].d[d]<18>))) | ci[2]<6> -> _po-
                (~__pp<27> | ~_uu<27>) &
                (&:c:2: ~cp[c]<27> | (|:s:2: (|:d:2: ~_syn_d[c][s].d[d]<27>))) & ~ci[2]<27> -> _po+

                ~v<9> -> _v+
                v<6> -> _v-
                
                (: f : F :
                    p.d[f]<12> & _v<12> -> _u[f]-
                    ~__pp<9> -> _u[f]+
                )

                ~_uu<18> & (& : f : F : ~p.d[f]<18>) -> v+
                _uu<6> -> v-

                (: f : F :
                    ~_v<18> & ~_u[f]<18> -> cp[f]+
                    _v<6> | _u[f]<6> -> cp[f]-
                )

                (: c : 2 :
                    (: s : 2 :
                        (: d : 2 :
                            p.d[2*s+d]<18> & cp[c]<18> & syn_[c][s].e<18> -> _syn_d[c][s].d[d]-
                            ~g._pReset | ~p.d[2*s+d]<18> & ~syn_[c][s].e<18> -> _syn_d[c][s].d[d]+
                        )
                    )
                )

                (: d : D :
                    p.d[d] & cp[2] -> _mem.d[d]-
                    ~p.d[d] | ~cp[2] -> _mem.d[d]+
                )
            }
            // inverters for interfaces
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _pp<6> -> __pp-
                ~_pp<9> -> __pp+

                (: c : 2 :
                    (: s : 2 :
                        (: d : 2 :
                            _syn_d[c][s].d[d]<6> -> syn_[c][s].d[d]-
                            ~_syn_d[c][s].d[d]<9> -> syn_[c][s].d[d]+
                        )
                    )
                )

                (: d : D :
                    _mem.d[d]<6> -> mem.d[d]-
                    ~_mem.d[d]<9> -> mem.d[d]+
                )
            }
        ]

        // ground dummy nodes
        ci[0] = g.GND;
        ci[1] = g.GND;
        ci[3] = g.GND;
        cp[3] = g.GND;
    }

    export
    template <pint N>
    defproc LEAF_NODATA (globals g; bool pp, po, ci[N], cp[N]; c1of<N> p) {
        // AERV tree LEAF that does not transmit data
        // N clients
        bool u, _po, _ci[N], _cp[N];
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                ci[n] => _ci[n]-
            )

            pp & (& : n : N : _ci[n]) | u => _po-

            (: n : N :
                p.d[n] -> _cp[n]-
                ~pp -> _cp[n]+
            )

            (| : n : N : ~_ci[n] & ~p.d[n]) => u+
        }
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                _cp[n] => cp[n]-
            )

            _po => po-
        }
    }

    export
    template <pint D, R; pint S[R], CAP[R]>
    defproc AMP_WIRES (globals g; bool _pcp, _pci, _cpp, _cpo; c1of<D> pc, cp) {
        // model the amplifier and wire capacitances internal to the aerv tree
        // D 1-of-D data
        // R repeater inverters
        // S[R] scales size of repeater inverters
        // CAP[R] capacitive load along repeaters (units of min size inverter cap)
        // in production: D=4
        // .--------------------------------------------------------------.
        // |                 link  | R | S              | CAP             |
        // |-----------------------|---|----------------|-----------------|
        // | array edge -> root    | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} |
        // | root       -> node[0] | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} |
        // | node[0]    -> node[1] | 4 | {3, 10, 6, 36} | {4, 64, 4, 64}  |
        // | node[1]    -> node[2] | 2 | {3, 10}        | {4, 64}         |
        // | node[2]    -> leaf    | 2 | {3, 10}        | {4, 32}         |
        // ----------------------------------------------------------------
        // assume min_inv_cap=0.25
        preal min_inv_cap = 0.25;
        
        preal C[R];
        (; r : R :
            C[r] = min_inv_cap * CAP[r];
        )
        REPEATER_BOOL<R, S, C> _pcp_cpp(g, _pcp, _cpp);
        REPEATER_BOOL<R, S, C> _cpo_pci(g, _cpo, _pci);
        REPEATER_c1of<D, R, S, C> pc_cp(g, pc, cp);
    }

    export
    template <pint M, Mp4, N_SYN, N_MEM; pint M0, Rmax, m0; pint R[M0], S[M0][Rmax], CAP[M0][Rmax]>
    defproc AERV_ (globals g; bool _pp, _po, cp[Mp4], ci[Mp4]; c1of<4> p; e1of2 syn[N_SYN]; c1of4 mem[N_MEM]) {
        // utility for AERV
        // M tree levels
        // Mp4 = M^4 potential output ports
        // N_SYN synapses
        // N_MEM memories
        // M0 total depth of tree
        // Rmax max repeaters between levels of the AERV tree
        // m0 indexes into R, S, CAP
        // R[M] repeaters between each AERV tree level
        // S[M][Rmax] repeater sizing between each AERV tree level
        // CAP[M][Rmax] wire cap driven by repeaters between AERV tree levels
        pint D = 4; // 1-of-D data
        pint F = 4; // fanout for intermediate nodes

        // connect parent ports to repeaters and wires
        bool w__pcp = _pp;
        bool w__pci = _po;
        bool w__cpp, w__cpo;
        c1of<D> w_pc = p; 
        c1of<D> w_cp;
        AMP_WIRES<D, R[m0], S[m0][0..R[m0]-1], CAP[m0][0..R[m0]-1]>
            w(g, w__pcp, w__pci, w__cpp, w__cpo, w_pc, w_cp);
        [ M = 1 ->
            N_SYN = 4; // assert
            N_MEM = 1; // assert
            Mp4 = 4; // assert
            m0 = M0-1; //assert
            LEAF leaf(g, w__cpp, w__cpo, cp, ci, w_cp, syn, mem[0]);
        [] M > 1 ->
            N_MEM*4 = N_SYN; // assert
            pint k = Mp4/4;
            pint k_syn = N_SYN/4;
            pint k_mem = N_MEM/4;
            AERV_<M-1, k, k_syn, k_mem, M0, Rmax, m0+1, R, S, CAP> _[F];
            (; f : F :
                _[f].g = g;
                _[f].cp = cp[f*k..(f+1)*k-1];
                _[f].ci = ci[f*k..(f+1)*k-1];
                _[f].syn = syn[f*k_syn..(f+1)*k_syn-1];
                _[f].mem = mem[f*k_mem..(f+1)*k_mem-1];
            )

            NODE<F, D> node(g, w__cpp, w__cpo,,, w_cp,);
            (; f : F :
                node._cp[f] = _[f]._pp;
                _[f]._po = node._ci[f];
                node.c[f] = _[f].p;
            )
        ]
    }

    export
    template <pint M, N, NN>
    defproc AERV_NODATA_ (globals g; bool yi[NN], yp[NN], _pp, _po; c1of<N> p) {
        // utility for AERV_NODATA
        [ M = 1 ->
            NN = N;
            LEAF_NODATA<N> leaf(g,,, yi, yp, p);
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _pp => leaf.pp-
                leaf.po => _po-
            }
        [] M > 1 ->
            AERV_NODATA_<M-1, N, NN/N> _[N];
            NODE<N, N> node(g, _pp, _po,,, p,);
            pint k = NN/N;
            (; n : N :
                _[n].g = g;
                _[n].p = node.c[n];
                _[n]._pp = node._cp[n];
                _[n]._po = node._ci[n];
                _[n].yi = yi[n*k..(n+1)*k-1];
                _[n].yp = yp[n*k..(n+1)*k-1];
            )
        ]
    }
} // namespace receiver

export
template <pint M, Mp4, N_SYN, N_MEM>
defproc AERV (globals g; bool pp, po, cp[Mp4], ci[Mp4]; c1of<4> p; e1of2 syn[N_SYN]; c1of4 mem[N_MEM]) {
    // Receiver receives data from datapath and sends spikes to neuron and data to memory
    // M tree levels (max 5)
    // Mp4 = M^4 potential output ports
    // N_SYN synapses
    // N_MEM memories
    pint Mmax = 5; // max AERV tree depth
    pint Rmax = 4; // max repeaters between AERV nodes
    pint R[Mmax];
    pint S[Mmax][Rmax];
    pint CAP[Mmax][Rmax];
    // repeaters per stage
    R = {4, 4, 4, 2, 2};
    // sizing per repeater per stage
    S = {{3, 10, 6, 36},
         {3, 10, 6, 36},
         {3, 10, 6, 36},
         {3, 10, 0, 0 },
         {3, 10, 0, 0 }};
    // cap per repeater per stage
    CAP = {{4, 64, 4, 192},
           {4, 64, 4, 192},
           {4, 64, 4, 64 },
           {4, 64, 0, 0  },
           {4, 32, 0, 0  }};

    [M > Mmax -> 0=1;] // assert false
    pint ms = Mmax-M; // start idx

    bool aerv__pp;
    bool aerv__po;
    receiver::AERV_<M, Mp4, N_SYN, N_MEM, M, Rmax, 0,
                    R[ms..Mmax-1], S[ms..Mmax-1], CAP[ms..Mmax-1]>
        _(g, aerv__pp, aerv__po, cp, ci, p, syn, mem);
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        ~pp<9> -> aerv__pp+
        pp<6> -> aerv__pp-
        ~aerv__po<9> -> po+
        aerv__po<6> -> po-
    }
}

export
template <pint M, N, NN>
defproc AERV_NODATA (globals g; bool yi[NN], yp[NN], pp, po; c1of<N> p) {
    // basic receiver that only sends sppkes to neurons
    // single sppke type, no excitatory/inhibitory sppke types 
    [ M = 1 ->
        NN = N;
        receiver::LEAF_NODATA<N> leaf(g, pp, po, yi, yp, p);
    [] M > 1 ->
        receiver::AERV_NODATA_<M, N, NN> _(g, yi, yp,,, p);
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            pp => _._pp-
            _._po => po-
        }
    ]
}

namespace brain_receiver {
    export
    template <pint C>
    defproc MERGE_ACK (globals g; bool pp, po, ci[C]) {
        // merges acknowledges from children with pphi acknowledge
        // C clients
        bool _pp;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                pp => _pp-

                ~_pp & (& : c : C : ~ci[c]) => po+
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~pp<9> -> _pp+
                pp<6> -> _pp-

                ~_pp<12> & (& : c : C : ~ci[c]<12>) -> po+
                _pp<6> | (| : c : C : ci[c]<6>) -> po-
            }
        ]
    }

    export
    template <pint M; pbool flip>
    defproc DESERIALIZER (globals g; bool xp, xo; c1of4 x; eMx1of4<M> _y) {
        // wrapper for the deserializer
        pint D = 4; // 1-of-D data
        pbool invert_y = true;

        MERGE_ACK<1> merge_ack(g, xp, xo,);
        ::aer::interface::DESERIAL_RING<M, D, invert_y, flip> deserial(g,,);
        deserial.x.d = x.d;
        deserial.x.a = merge_ack.ci[0];
        (; m : M :
            deserial.y.m[m].d = _y.m[m].d;
        )
        deserial.y.e = _y.e;
    }

    export
    defproc HALF_BUFFER (globals g; e1of2 x; a1of2 y) {
        // prevents the synapse from holding up the receiver tree
        // wchb providing a half cycle of buffering
        pint D = 2; // for 1of2
        bool ye;
        c1of2 _y;
        c1of2 __y = y.m;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                y.a => ye-

                (& : d : D : ~y.d[d]) => x.e+

                (: d : D :
                    x.d[d] & ye -> _y.d[d]-
                    ~g._pReset | ~x.d[d] & ~ye -> _y.d[d]+
                )

                (: d : D :
                    _y.d[d] => __y.d[d]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~y.a<9> -> ye+
                y.a<6> -> ye-

                (& : d : D : ~y.d[d]<18>) -> x.e+
                (| : d : D : y.d[d]<6>) -> x.e-

                (: d : D :
                    x.d[d]<18> & ye<18> -> _y.d[d]-
                    ~g._pReset | ~x.d[d]<12> & ~ye<12> -> _y.d[d]+
                )

                (: d : D :
                    ~_y.d[d]<9> -> __y.d[d]+
                    _y.d[d]<6> -> __y.d[d]-
                )
            }
        ]
    }
} // namespace brain_receiver

export
template <pint M, Mp4, M_SPK, M_MEM, N_SYN, N_MEM; pbool flip_mem_out>
defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                    eMx1of4<M_MEM> x_mem;
                    a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> _y_mem[N_MEM]) {
    // braindrop / brainstorm receiver system
    // M tree depth
    //     M = 5 (in production)
    // Mp4 potential ports
    //     Mp4 = M^4
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK = M + 1
    //     M_SPK = 6 (in production)
    // M_MEM packet length to write config memory
    //     M_MEM = M + memory packet length
    //     M_MEM = 9 (in production)
    // N_SYN synapses
    //     N_SYN = 4^M
    //     N_SYN = 1024 (in production)
    // N_MEM configuration memories
    //     N_MEM = 4^(M-1)
    //     N_MEM = 256 (in production)
    // flip_mem_out flip memory output word order
    pint D = 4;
    N_MEM*4 = N_SYN; // assert

    interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
    interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
    (; m : M_SPK :
        serial_spk.x.m[m].d = x_spk.m[m].d;
    )
    (; m : M_MEM :
        serial_mem.x.m[m].d = x_mem.m[m].d;
    )
    serial_spk.x.e = x_spk.e;
    serial_mem.x.e = x_mem.e;

    bool merge_xp[2];
    bool merge_xo[2];
    c1of<D> merge_x[2];
    merge_xp[0] = serial_spk.yp;
    merge_xp[1] = serial_mem.yp;
    merge_xo[0] = serial_spk.yi;
    merge_xo[1] = serial_mem.yi;
    merge_x[0] = serial_spk.y;
    merge_x[1] = serial_mem.y;

    interface::SERIAL_MERGE<2, D> merge(g, merge_xp, merge_xo,,, merge_x,);
    bool aerv_pp = merge.yp;
    bool aerv_po = merge.yi;
    c1of<D> aerv_p = merge.y;

    brain_receiver::DESERIALIZER<M_MEM-M, flip_mem_out> mem_deserial[N_MEM];
    bool aerv_cp[Mp4];
    bool aerv_ci[Mp4];
    c1of4 aerv_mem[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        mem_deserial[n].xp = aerv_cp[n*4+2]; // connect deserial to aerv
        mem_deserial[n].xo = aerv_ci[n*4+2];
        mem_deserial[n].x = aerv_mem[n];
        mem_deserial[n]._y = _y_mem[n]; // connect deserial to memory
    )
    
    brain_receiver::HALF_BUFFER buf_syn[N_SYN]; // buffer synapse spikes
    e1of2 aerv_syn[N_SYN];
    (; n : N_SYN :
        buf_syn[n].g = g;
        buf_syn[n].x = aerv_syn[n]; // connect buf_syn to aerv
        buf_syn[n].y = y_syn[n]; // connect buf_syn to synapse
    )

    AERV<M, Mp4, N_SYN, N_MEM> 
        aerv(g, aerv_pp, aerv_po, aerv_cp, aerv_ci, aerv_p, aerv_syn, aerv_mem);
}

} // namespace aer
