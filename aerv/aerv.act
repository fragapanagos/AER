// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/interface/interface.act";

namespace aer {

namespace receiver {
    export
    template <pint F, D>
    defproc NODE (globals g; bool _pp, _po, _ci[F], _cp[F]; c1of<D> p, c[F]) {
        // AERV tree NODE
        // F fanout (radix)
        // D 1-of-D data
        bool u[F], _u[F], uu, _v, __v, po;
        c1of<D> _p;
        [ (~LAYOUT | F < 3 | F > 4) ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: f : F :
                    u[f] => _u[f]-
                )

                (| : f : F : ~_u[f]) => uu+

                ~_pp & ~uu | (| : f : F : ~_ci[f]) => po+

                _v => __v-

                (: d : D :
                    p.d[d] => _p.d[d]-
                )

                (: f : F :
                    ~_p.d[f] & ~__v -> u[f]+
                    _pp -> u[f]-
                )

                uu & (& : f : F : _p.d[f]) -> _v-
                ~uu -> _v+

                (: f : F :
                    __v & u[f] => _cp[f]-
                )

                (: f : F :
                    (: d : D :
                        ~_p.d[d] & ~_cp[f] => c[f].d[d]+
                    )
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                po => _po-
            }
        [] LAYOUT ->
            [ F = 3 ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: f : F :
                        ~u[f]<9> -> _u[f]+
                        u[f]<6> -> _u[f]-
                    )

                    (| : f : F : ~_u[f]<12>) -> uu+
                    (& : f : F : _u[f]<12>) -> uu-

                    ~_pp<27> & ~uu<27> | (| : f : F : ~_ci[f]<27>) -> po+
                    (_pp<18> | uu<18>) & (& : f : F : _ci[f]<18>) -> po-

                    ~_v<12> -> __v+
                    _v<9> -> __v-

                    (: d : D :
                        ~p.d[d]<12> -> _p.d[d]+
                        p.d[d]<9> -> _p.d[d]-
                    )

                    (: f : F :
                        ~_p.d[f]<18> & ~__v<18> -> u[f]+
                        _pp<6> -> u[f]-
                    )

                    uu<18> & (& : f : F : _p.d[f]<18>) -> _v-
                    ~uu<15> -> _v+

                    (: f : F :
                        ~__v<12> | ~u[f]<12> -> _cp[f]+
                        __v<15> & u[f]<15> -> _cp[f]-
                    )

                    (: f : F :
                        (: d : D :
                            ~_p.d[d]<18> & ~_cp[f]<18> -> c[f].d[d]+
                            _p.d[d]<6> | _cp[f]<6> -> c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    ~po<12> -> _po+
                    po<9> -> _po-
                }
            [] F = 4 ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: f : F :
                        ~u[f]<9> -> _u[f]+
                        u[f]<6> -> _u[f]-
                    )

                    (| : f : F : ~_u[f]<12>) -> uu+
                    (& : f : F : _u[f]<15>) -> uu-

                    ~_pp<27> & ~uu<27> | (| : f : F : ~_ci[f]<27>) -> po+
                    (_pp<18> | uu<18>) & (& : f : F : _ci[f]<18>) -> po-

                    ~_v<15> -> __v+
                    _v<9> -> __v-

                    (: d : D :
                        ~p.d[d]<12> -> _p.d[d]+
                        p.d[d]<9> -> _p.d[d]-
                    )

                    (: f : F :
                        ~_p.d[f]<18> & ~__v<18> -> u[f]+
                        _pp<6> -> u[f]-
                    )

                    uu<18> & (& : f : F : _p.d[f]<18>) -> _v-
                    ~uu<18> -> _v+

                    (: f : F :
                        ~__v<12> | ~u[f]<12> -> _cp[f]+
                        __v<15> & u[f]<15> -> _cp[f]-
                    )

                    (: f : F :
                        (: d : D :
                            ~_p.d[d]<18> & ~_cp[f]<18> -> c[f].d[d]+
                            _p.d[d]<6> | _cp[f]<6> -> c[f].d[d]-
                        )
                    )
                }
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    ~po<12> -> _po+
                    po<9> -> _po-
                }
            ]
        ]
    }

    export
    template <pint N>
    defproc LEAF_NODATA (globals g; bool pp, po, ci[N], cp[N]; c1of<N> p) {
        // AERV tree LEAF that does not transmit data
        // N clients
        bool u, _po, _ci[N], _cp[N];
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                ci[n] => _ci[n]-
            )

            pp & (& : n : N : _ci[n]) | u => _po-

            (: n : N :
                p.d[n] -> _cp[n]-
                ~pp -> _cp[n]+
            )

            (| : n : N : ~_ci[n] & ~p.d[n]) => u+
        }
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            (: n : N :
                _cp[n] => cp[n]-
            )

            _po => po-
        }
    }

    export
    template <pint M, F_INT, F_LEAF, T, D>
    defproc AERV_ (globals g; bool _yi[T], _yp[T], _pp, _po; c1of<D> y[T], p) {
        // utility for AERV
        [ M = 1 ->
            NODE<F_LEAF, D> leaf(g, _pp, _po, _yi, _yp, p, y);
        [] M > 1 ->
            AERV_<M-1, F_INT, F_LEAF, T/F_INT, D> _[F_INT];
            NODE<F_INT, D> node(g, _pp, _po,,, p,);
            pint k = T/F_INT;
            (; f : F_INT :
                _[f].g = g;
                _[f].p = node.c[f];
                _[f]._pp = node._cp[f];
                _[f]._po = node._ci[f];
                _[f]._yi = _yi[f*k..(f+1)*k-1];
                _[f]._yp = _yp[f*k..(f+1)*k-1];
                _[f].y = y[f*k..(f+1)*k-1];
            )
        ]
    }

    export
    template <pint M, N, NN>
    defproc AERV_NODATA_ (globals g; bool yi[NN], yp[NN], _pp, _po; c1of<N> p) {
        // utility for AERV_NODATA
        [ M = 1 ->
            NN = N;
            LEAF_NODATA<N> leaf(g,,, yi, yp, p);
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _pp => leaf.pp-
                leaf.po => _po-
            }
        [] M > 1 ->
            AERV_NODATA_<M-1, N, NN/N> _[N];
            NODE<N, N> node(g, _pp, _po,,, p,);
            pint k = NN/N;
            (; n : N :
                _[n].g = g;
                _[n].p = node.c[n];
                _[n]._pp = node._cp[n];
                _[n]._po = node._ci[n];
                _[n].yi = yi[n*k..(n+1)*k-1];
                _[n].yp = yp[n*k..(n+1)*k-1];
            )
        ]
    }
} // namespace receiver

export
template <pint M, F_INT, F_LEAF, T, D>
defproc AERV (globals g; bool _yi[T], yp[T], pp, po; c1of<D> y[T], p) {
    // receiver capable of sending data to neuron
    // M tree levels
    // F_INT intermediate node fanout (radix)
    // F_LEAF leaf node fanout (radix)
    // T targets. T = F_LEAF * F_INT^(M-1)
    // D 1-of-D data
    receiver::AERV_<M, F_INT, F_LEAF, T, D> _(g, _yi,,,, y, p);
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        (: t : T :
            ~_._yp[t]<9> -> yp[t]+
            _._yp[t]<6> -> yp[t]-
        )
        ~pp<9> -> _._pp+
        pp<6> -> _._pp-
        ~_._po<9> -> po+
        _._po<6> -> po-
    }
}

export
template <pint M, N, NN>
defproc AERV_NODATA (globals g; bool yi[NN], yp[NN], pp, po; c1of<N> p) {
    // basic receiver that only sends sppkes to neurons
    // single sppke type, no excitatory/inhibitory sppke types 
    [ M = 1 ->
        NN = N;
        receiver::LEAF_NODATA<N> leaf(g, pp, po, yi, yp, p);
    [] M > 1 ->
        receiver::AERV_NODATA_<M, N, NN> _(g, yi, yp,,, p);
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            pp => _._pp-
            _._po => po-
        }
    ]
}

namespace brain_receiver {
    export
    template <pint C>
    defproc MERGE_ACK (globals g; bool pp, _po, ci[C]) {
        // merges acknowledges from children with pphi acknowledge
        // C clients
        bool _cci;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (& : c : C : ~ci[c]) => _cci+
                pp & _cci => _po-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (& : c : C : ~ci[c]<9*C>) -> _cci+
                (| : c : C : ci[c]<6>) -> _cci-

                pp<12> & _cci<12> -> _po-
                ~pp<9> | ~_cci<9> -> _po+
            }
        ]
    }

    export
    defproc HALF_BUFFER (globals g; a1of2 x, y) {
        // prevents the synapse from holding up the receiver tree
        // wchb providing a half cycle of buffering
        pint D = 2; // for a1of2
        bool _xa = x.a; // active low
        bool _ya = y.a; // active low
        c1of2 _y;
        c1of2 __y = y.m;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: d : D :
                    x.d[d] & _ya -> _y.d[d]-
                    ~g._pReset | ~x.d[d] & ~_ya -> _y.d[d]+
                )

                (: d : D :
                    _y.d[d] => __y.d[d]-
                )

                (| : d : D : __y.d[d]) => _xa-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: d : D :
                    x.d[d]<9> & _ya<9> -> _y.d[d]-
                    ~g._pReset | ~x.d[d]<12> & ~_ya<12> -> _y.d[d]+
                )

                (: d : D :
                    ~_y.d[d]<9> -> __y.d[d]+
                    _y.d[d]<6> -> __y.d[d]-
                )

                (| : d : D : __y.d[d]<6>) -> _xa-
                (& : d : D : ~__y.d[d]<12>) -> _xa+
            }
        ]
    }

    export
    defproc FULL_BUFFER (globals g; a1of2 x, y) {
        // provides a full cycle of buffering
        // prevents the synapse from holding up the receiver tree
        HALF_BUFFER half_buf[2];
        half_buf[0].g = g;
        half_buf[1].g = g;
        half_buf[0].x.d = x.d;
        half_buf[0].y = half_buf[1].x;
        half_buf[1].y.d = y.d;

        // active low acks internally
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            half_buf[0].x.a => x.a-
            y.a => half_buf[1].y.a-
        }
    }
} // namespace brain_receiver

export
template <pint M, M_SPK, M_MEM, N_SYN, N_MEM>
defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                    eMx1of4<M_MEM> x_mem;
                    a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> y_mem[N_MEM]) {
    // braindrop / brainstorm receiver system
    // M tree depth
    //     M = 5 (in production)
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK = M + 1
    //     M_SPK = 6 (in production)
    // M_MEM packet length to write config memory
    //     M_MEM = M + memory packet length
    //     M_MEM = 9 (in production)
    // N_SYN synapses
    //     N_SYN = 4^M
    //     N_SYN = 1024 (in production)
    // N_MEM configuration memories
    //     N_MEM = 4^(M-1)
    //     N_MEM = 256 (in production)
    pint F_INT = 4;
    pint F_LEAF = 3;
    pint D = 4;
    pint AERV_TGTS = N_SYN/2 + N_MEM;

    interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
    interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
    (; m : M_SPK :
        serial_spk.x.m[m].d = x_spk.m[m].d;
    )
    (; m : M_MEM :
        serial_mem.x.m[m].d = x_mem.m[m].d;
    )
    serial_spk.x.e = x_spk.e;
    serial_mem.x.e = x_mem.e;

    bool merge_xp[2];
    bool merge_xo[2];
    c1of<D> merge_x[2];
    merge_xp[0] = serial_spk.yp;
    merge_xp[1] = serial_mem.yp;
    merge_xo[0] = serial_spk.yi;
    merge_xo[1] = serial_mem.yi;
    merge_x[0] = serial_spk.y;
    merge_x[1] = serial_mem.y;

    interface::SERIAL_MERGE<2, D> merge(g, merge_xp, merge_xo,,, merge_x,);

    interface::DESERIAL_RING<M_MEM-M, D> mem_deserial[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        (; m : M_MEM - M :
            mem_deserial[n].y.m[m].d = y_mem[n].m[m].d;
        )
        mem_deserial[n].y.e = y_mem[n].e;
    )
    
    brain_receiver::FULL_BUFFER buf_syn[N_SYN]; // buffer synapse spikes
    (; n : N_SYN :
        buf_syn[n].g = g;
        // connect synapse to buf_syn
        buf_syn[n].y = y_syn[n];
    )
    brain_receiver::MERGE_ACK<2> ack_syn[N_SYN/2]; // ack syns
    brain_receiver::MERGE_ACK<1> ack_mem[N_SYN/4]; // ack mems
    bool aerv__yi[AERV_TGTS];
    bool aerv_yp[AERV_TGTS];
    (; n : N_SYN/2 :
        ack_syn[n].g = g;
        // connect buf_syn ack to ack_syn
        ack_syn[n].ci[0] = buf_syn[2*n].x.a;
        ack_syn[n].ci[1] = buf_syn[2*n+1].x.a;
    )
    (; n : N_SYN/4 :
        ack_mem[n].g = g;
        // connect aerv pphi to ack_syn 
        ack_syn[2*n].pp = aerv_yp[3*n];
        ack_syn[2*n+1].pp = aerv_yp[3*n+1];
        // connect ack_syn ack to aerv
        ack_syn[2*n]._po = aerv__yi[3*n];
        ack_syn[2*n+1]._po = aerv__yi[3*n+1];
        // connect mem ack to ack_mem
        ack_mem[n].ci[0] = mem_deserial[n].x.a;
        // connect aerv pphi to ack_mem
        ack_mem[n].pp = aerv_yp[3*n+2];
        // connect ack_mem ack to aerv
        ack_mem[n]._po = aerv__yi[3*n+2];
    )

    c1of<D> aerv_y[AERV_TGTS];
    (; n : AERV_TGTS/3 :
        aerv_y[3*n].d[0..1] = buf_syn[4*n].x.d;
        aerv_y[3*n].d[2..3] = buf_syn[4*n+1].x.d;
        aerv_y[3*n+1].d[0..1] = buf_syn[4*n+2].x.d;
        aerv_y[3*n+1].d[2..3] = buf_syn[4*n+3].x.d;
        aerv_y[3*n+2].d = mem_deserial[n].x.d;
    )

    AERV<M, F_INT, F_LEAF, AERV_TGTS, D> aerv(
        g, aerv__yi, aerv_yp, merge.yp, merge.yi, aerv_y, merge.y);
}

} // namespace aer
