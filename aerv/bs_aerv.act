// This file defines a modified brainstorm receiver that
// uses the serializer defined in the brainstorm repository
// This code only compiles when this aer repository is located
// as a subdirectory of the brainstorm repository, namely in
// brainstorm/act
import "aer/aerv/aerv.act";
import "core/serializer/AERSerializer.act";
import "aer/lib/compat_bs.act";

export
template <pint M_1of2, M_1of4, p4M, M_SPK_1of2, M_SPK_1of4, M_MEM_1of2, M_MEM_1of4, N_SYN, N_MEM>
defproc BS_AERV (aer::globals g; aer::eMx1of2<M_SPK_1of2> x_spk; 
                    aer::eMx1of2<M_MEM_1of2> x_mem;
                    aer::a1of2 y_syn[N_SYN]; aer::eMx1of4<M_MEM_1of4-M_1of4> _y_mem[N_MEM]) {
    // modified braindrop / brainstorm receiver system that uses
    // the serializer defined in the brainstorm repository
    // M tree depth
    //     M_1of4 = 5 in production
    // p4M potential ports
    //     p4M = 4^M
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK_1of4 = M_1of4+1 = 6 in production
    //     M_SPK_1of2 = 12 in production
    // M_MEM packet length to write config memory
    //     M_MEM_1of4 = M_1of4 + memory_pacekt_1of4_length = 9 in production
    //     M_MEM_1of2 = 18 in production
    // N_SYN synapses
    //     N_SYN = 4^M_1of4 = 1024 in production
    // N_MEM configuration memories
    //     N_MEM = 4^(M_1of4-1) = 256 in production
    M_1of4*2 = M_1of2; // assert
    M_SPK_1of4*2 = M_SPK_1of2; //assert
    M_MEM_1of4*2 = M_MEM_1of2; // assert
    N_MEM*4 = N_SYN; // assert
    pint D = 4;

    globals g_bs;
    compat_bs::globals g_compat(g, g_bs);

    serializer::AERSERN<M_SPK_1of2> serial_spk(g_bs,,,,);
    serializer::AERSERN<M_MEM_1of2> serial_mem(g_bs,,,,);

    compat_bs::eMx1of2<M_SPK_1of2> serial_spk_I(x_spk, serial_spk.I);
    compat_bs::eMx1of2<M_MEM_1of2> serial_mem_I(x_mem, serial_mem.I);

    bool merge_xp[2];
    bool merge_xo[2];
    aer::c1of<D> merge_x[2];
    merge_xp[0] = serial_spk.Op;
    merge_xp[1] = serial_mem.Op;
    merge_xo[0] = serial_spk.Oe;
    merge_xo[1] = serial_mem.Oe;
    compat_bs::d1of<D> serial_spk_Od(, serial_spk.Od);
    compat_bs::d1of<D> serial_mem_Od(, serial_mem.Od);
    merge_x[0].d = serial_spk_Od.aer.d;
    merge_x[1].d = serial_mem_Od.aer.d;

    aer::interface::SERIAL_MERGE<2, D> merge(g, merge_xp, merge_xo,,, merge_x,);
    bool aerv_pp = merge.yp;
    bool aerv_pe = merge.yi;
    aer::c1of<D> aerv_p = merge.y;
    
    aer::brain_receiver::DESERIALIZER<M_MEM_1of4-M_1of4, D> mem_deserial[N_MEM];
    bool aerv_yp_mem[N_MEM];
    bool aerv_ye_mem[N_MEM];
    aer::c1of<D> aerv_mem[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        // connect deserial to aerv
        mem_deserial[n].xp = aerv_yp_mem[n];
        mem_deserial[n].xe = aerv_ye_mem[n];
        mem_deserial[n].x = aerv_mem[n];
        // connect deserial to memory
        (; m : M_MEM_1of4-M_1of4 :
            mem_deserial[n]._y.m[m].d = _y_mem[n].m[m].d;
        )
        mem_deserial[n]._y.e = _y_mem[n].e;
    )

    aer::brain_receiver::HALF_BUFFER buf_syn[N_SYN]; // buffer synapse spikes
    aer::e1of2 aerv_syn[N_SYN];
    (; n : N_SYN :
        buf_syn[n].g = g;
        buf_syn[n].x = aerv_syn[n]; // connect buf_syn to aerv
        buf_syn[n].y = y_syn[n]; // connect buf_syn to synapse
    )

    aer::AERV<M_1of4, D, p4M, N_SYN, N_MEM> aerv(
        g, aerv_pp, aerv_pe, aerv_p, aerv_syn, aerv_yp_mem, aerv_ye_mem, aerv_mem);
}
