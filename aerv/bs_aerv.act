// This file defines a modified brainstorm receiver that
// uses the serializer defined in the brainstorm repository
// This code only compiles when this aer repository is located
// as a subdirectory of the brainstorm repository, namely in
// brainstorm/act
import "aer/aerv/aerv.act";
import "core/serializer/AERSerializer.act";
import "aer/lib/compat_bs.act";

export
template <pint M_1of2, M_1of4, Mp4, M_SPK_1of2, M_SPK_1of4, M_MEM_1of2, M_MEM_1of4, N_SYN, N_MEM>
defproc BS_AERV (aer::globals g; aer::eMx1of2<M_SPK_1of2> x_spk; 
                    aer::eMx1of2<M_MEM_1of2> x_mem;
                    aer::a1of2 y_syn[N_SYN]; aer::eMx1of4<M_MEM_1of4-M_1of4> _y_mem[N_MEM]) {
    // modified braindrop / brainstorm receiver system that uses
    // the serializer defined in the brainstorm repository
    // M tree depth
    //     M_1of4 = 5 (in production)
    // Mp4 potential ports
    //     Mp4 = M^4
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK_1of4 = M_1of4+1
    //     M_SPK_1of2 = 2*M_1of4 + 2
    //     M_SPK_1of2 = 12 (in production)
    // M_MEM packet length to write config memory
    //     M_MEM_1of4 = M_1of4 + memory_pacekt_1of4_length
    //     M_MEM_1of2 = 2*M_1of4 + 2 * memory_packet_1of4_length
    //     M_MEM_1of2 = 18 (in production)
    // N_SYN synapses
    //     N_SYN = 4^M_1of4
    //     N_SYN = 1024 (in production)
    // N_MEM configuration memories
    //     N_MEM = 4^(M_1of4-1)
    //     N_MEM = 256 (in production)
    M_1of4*2 = M_1of2; // assert
    M_SPK_1of4*2 = M_SPK_1of2; //assert
    M_MEM_1of4*2 = M_MEM_1of2; // assert
    N_MEM*4 = N_SYN; // assert
    pint D = 4;

    globals g_bs;
    compat_bs::globals g_compat(g, g_bs);

    serializer::AERSERN<M_SPK_1of2> serial_spk(g_bs,,,,);
    serializer::AERSERN<M_MEM_1of2> serial_mem(g_bs,,,,);

    compat_bs::eMx1of2<M_SPK_1of2> serial_spk_I(x_spk, serial_spk.I);
    compat_bs::eMx1of2<M_MEM_1of2> serial_mem_I(x_mem, serial_mem.I);

    bool merge_xp[2];
    bool merge_xo[2];
    aer::c1of<D> merge_x[2];
    merge_xp[0] = serial_spk.Op;
    merge_xp[1] = serial_mem.Op;
    merge_xo[0] = serial_spk.Oe;
    merge_xo[1] = serial_mem.Oe;
    compat_bs::d1of<D> serial_spk_Od(, serial_spk.Od);
    compat_bs::d1of<D> serial_mem_Od(, serial_mem.Od);
    merge_x[0].d = serial_spk_Od.aer.d;
    merge_x[1].d = serial_mem_Od.aer.d;

    aer::interface::SERIAL_MERGE<2, D> merge(g, merge_xp, merge_xo,,, merge_x,);
    bool aerv_pp = merge.yp;
    bool aerv_po = merge.yi;
    aer::c1of<D> aerv_p = merge.y;
    
    aer::brain_receiver::DESERIALIZER<M_MEM_1of4-M_1of4> mem_deserial[N_MEM];
    bool aerv_cp[Mp4];
    bool aerv_ci[Mp4];
    aer::c1of4 aerv_mem[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        mem_deserial[n].xp = aerv_cp[n*4+2]; // connect deserial to aerv
        mem_deserial[n].xo = aerv_ci[n*4+2];
        mem_deserial[n].x = aerv_mem[n];
        mem_deserial[n]._y = _y_mem[n]; // connect deserial to memory
    )

    aer::brain_receiver::HALF_BUFFER buf_syn[N_SYN]; // buffer synapse spikes
    aer::e1of2 aerv_syn[N_SYN];
    (; n : N_SYN :
        buf_syn[n].g = g;
        buf_syn[n].x = aerv_syn[n]; // connect buf_syn to aerv
        buf_syn[n].y = y_syn[n]; // connect buf_syn to synapse
    )

    aer::AERV<M_1of4, Mp4, N_SYN, N_MEM> aerv(
        g, aerv_pp, aerv_po, aerv_cp, aerv_ci, aerv_p, aerv_syn, aerv_mem);
}
