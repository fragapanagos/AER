// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer_brainstorm/interface/ref_interface.act";

namespace receiver {
    export
    template <pint F, D>
    defproc NODE (globals g; bool pp, po, ci[F], cp[F]; c1of<D> p, c[F]) {
        // node in AERV tree
        // F fanout (radix)
        // D 1-of-D data
        bool u[F], uu, v;
        prs<g.Vdd, g.GND> {
            (| : f : F : u[f]) => uu+

            pp & ~uu | (| : f : F : ci[f]) => po+

            (: f : F :
                p.d[f] & ~v -> u[f]+
                ~pp -> u[f]-
            )

            uu & (& : f : F : ~p.d[f]) -> v+
            ~uu -> v-

            (: f : F :
                v & u[f] => cp[f]+
            )

            (: f : F :
                (: d : D :
                    p.d[d] & cp[f] => c[f].d[d]+
                )
            )
        }
    }

    export
    template <pint N>
    defproc LEAF_NODATA (globals g; bool pp, po, ci[N], cp[N]; c1of<N> p) {
        // leaf of AERV tree that does not transmit data
        bool u;
        prs<g.Vdd, g.GND> {
            pp & (& : n : N : ~ci[n]) | u => po+

            (: n : N :
                p.d[n] -> cp[n]+
                ~pp -> cp[n]-
            )

            (| : n : N : ci[n] & ~p.d[n]) => u+
        }
    }
} // namespace receiver

export
template <pint M, F_INT, F_LEAF, T, D>
defproc AERV (globals g; bool yi[T], yp[T], pp, po; c1of<D> y[T], p) {
    // receiver capable of sending data to neuron
    // M tree levels
    // F_INT intermediate node fanout (radix)
    // F_LEAF leaf node fanout (radix)
    // T targets. T = F_LEAF * F_INT^(M-1)
    // D 1-of-D data
    [ M = 1 ->
        T = F_LEAF;
        receiver::NODE<F_LEAF, D> leaf(g, pp, po, yi, yp, p, y);
    [] M > 1 ->
        AERV<M-1, F_INT, F_LEAF, T/F_INT, D> _[F_INT];
        receiver::NODE<F_INT, D> node(g, pp, po,,, p,);
        pint k = T/F_INT;
        (; f : F_INT :
            _[f].g = g;
            _[f].p = node.c[f];
            _[f].pp = node.cp[f];
            _[f].po = node.ci[f];
            _[f].y = y[f*k..(f+1)*k-1];
            _[f].yi = yi[f*k..(f+1)*k-1];
            _[f].yp = yp[f*k..(f+1)*k-1];
        )
    ]
}

export
template <pint M, N, NN>
defproc AERV_NODATA (globals g; bool yi[NN], yp[NN], pp, po; c1of<N> p) {
    // receiver that does not send data to neurons
    [ M = 1 ->
        NN = N;
        receiver::LEAF_NODATA<N> leaf(g, pp, po, yi, yp, p);
    [] M > 1 ->
        AERV_NODATA<M-1, N, NN/N> _[N];
        receiver::NODE<N, N> node(g, pp, po,,, p,);
        pint k = NN/N;
        (; n : N :
            _[n].g = g;
            _[n].p = node.c[n];
            _[n].pp = node.cp[n];
            _[n].po = node.ci[n];
            _[n].yi = yi[n*k..(n+1)*k-1];
            _[n].yp = yp[n*k..(n+1)*k-1];
        )
    ]
}

namespace brain_receiver {
    export
    template <pint C>
    defproc MERGE_ACK (globals g; bool pp, po, ci[C]) {
        // merges acknowledges from children with pphi acknowledge
        // C clients
        prs<g.Vdd, g.GND> {
            pp & (& : c : C : ~ci[c]) => po+
        }
    }
} // namespace brain_receiver

export
template <pint M, M_SPK, M_MEM, N_SYN, N_MEM>
defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                    eMx1of4<M_MEM> x_mem;
                    a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> y_mem[N_MEM]) {
    // braindrop / brainstorm receiver system
    // M tree depth
    //     M = 5 (in production)
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK = M + 1
    //     M_SPK = 6 (in production)
    // M_MEM packet length to write config memory
    //     M_MEM = M + memory packet length
    //     M_MEM = 9 (in production)
    // N_SYN synapses
    //     N_SYN = 4^M
    //     N_SYN = 1024 (in production)
    // N_MEM configuration memories
    //     N_MEM = 4^(M-1)
    //     N_MEM = 256 (in production)
    pint F_INT = 4;
    pint F_LEAF = 3;
    pint D = 4;
    pint AERV_TGTS = N_SYN/2 + N_MEM;

    interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
    interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
    (; m : M_SPK :
        serial_spk.x.m[m].d = x_spk.m[m].d;
    )
    (; m : M_MEM :
        serial_mem.x.m[m].d = x_mem.m[m].d;
    )
    serial_spk.x.e = x_spk.e;
    serial_mem.x.e = x_mem.e;

    bool merge_xp[2];
    bool merge_xo[2];
    c1of<D> merge_x[2];
    merge_xp[0] = serial_spk.yp;
    merge_xp[1] = serial_mem.yp;
    merge_xo[0] = serial_spk.yi;
    merge_xo[1] = serial_mem.yi;
    merge_x[0] = serial_spk.y;
    merge_x[1] = serial_mem.y;

    interface::SERIAL_MERGE<2, D> merge(g, merge_xp, merge_xo,,, merge_x,);

    interface::DESERIAL_RING<M_MEM-M, D> mem_deserial[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        (; m : M_MEM - M :
            mem_deserial[n].y.m[m].d = y_mem[n].m[m].d;
        )
        mem_deserial[n].y.e = y_mem[n].e;
    )
    
    brain_receiver::MERGE_ACK<2> ack_syn[N_SYN/2]; // ack syns
    brain_receiver::MERGE_ACK<1> ack_mem[N_SYN/4]; // ack mems
    bool aerv_yi[AERV_TGTS];
    bool aerv_yp[AERV_TGTS];
    (; n : N_SYN/2 :
        ack_syn[n].g = g;
        // connect synapse ack to ack_syn
        ack_syn[n].ci[0] = y_syn[2*n].a;
        ack_syn[n].ci[1] = y_syn[2*n+1].a;
    )
    (; n : N_SYN/4 :
        // connect aerv pphi to ack_syn 
        ack_syn[2*n].pp = aerv_yp[3*n];
        ack_syn[2*n+1].pp = aerv_yp[3*n+1];
        // connect ack_syn ack to aerv
        ack_syn[2*n].po = aerv_yi[3*n];
        ack_syn[2*n+1].po = aerv_yi[3*n+1];
        // connect mem ack to ack_mem
        ack_mem[n].ci[0] = mem_deserial[n].x.a;
        // connect aerv pphi to ack_mem
        ack_mem[n].pp = aerv_yp[3*n+2];
        // connect ack_mem ack to aerv
        ack_mem[n].po = aerv_yi[3*n+2];
    )

    c1of<D> aerv_y[AERV_TGTS];
    (; n : AERV_TGTS/3 :
        aerv_y[3*n].d[0..1] = y_syn[4*n].d;
        aerv_y[3*n].d[2..3] = y_syn[4*n+1].d;
        aerv_y[3*n+1].d[0..1] = y_syn[4*n+2].d;
        aerv_y[3*n+1].d[2..3] = y_syn[4*n+3].d;
        aerv_y[3*n+2].d = mem_deserial[n].x.d;
    )

    AERV<M, F_INT, F_LEAF, AERV_TGTS, D> aerv(
        g, aerv_yi, aerv_yp, merge.yp, merge.yi, aerv_y, merge.y);
}
