// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/interface/ref_interface.act";

namespace aer {

namespace receiver {
    export
    template <pint F, D>
    defproc NODE (globals g; bool pp, pe, ce[F], cp[F]; c1of<D> p, c[F]) {
        // node in AERV tree
        // F fanout (radix)
        // D 1-of-D data
        bool u[F], uu, v;
        prs<g.Vdd, g.GND> {
            (| : f : F : u[f]) => uu+

            pp & ~uu | (| : f : F : ce[f]) => pe+

            (: f : F :
                p.d[f] & ~v -> u[f]+
                ~pp -> u[f]-
            )

            uu & (& : f : F : ~p.d[f]) -> v+
            ~uu -> v-

            (: f : F :
                v & u[f] => cp[f]+
            )

            (: f : F :
                (: d : D :
                    p.d[d] & cp[f] => c[f].d[d]+
                )
            )
        }
    }

    export
    defproc LEAF (globals g; bool pp, pe, cp[4], ce[4]; c1of<4> p; e1of2 syn[4]; c1of4 mem) {
        // node in AERV tree
        pint D = 4; // 1-of-D data
        pint F = 3; // fanout ports
        bool u[F], uu, v;
        e1of2 syn_[2][2];
        (; c : 2 : (; s : 2 : syn_[c][s] = syn[2*c+s];))
        prs<g.Vdd, g.GND> {
            (| : f : F : u[f]) => uu+

            pp & ~uu | (|:c:2: cp[c] & (&:s:2: (&:d:2: ~syn_[c][s].d[d]))) | ce[2] => pe+
            
            (: f : F :
                p.d[f] & ~v -> u[f]+
                ~pp -> u[f]-
            )

            uu & (& : f : F : ~p.d[f]) -> v+
            ~uu -> v-

            (: f : F :
                v & u[f] => cp[f]+
            )

            (: c : 2 :
                (: s : 2 :
                    (: d : 2 :
                        p.d[2*s+d] & cp[c] & syn_[c][s].e -> syn_[c][s].d[d]+
                        g.pReset | ~p.d[2*s+d] & ~syn_[c][s].e -> syn_[c][s].d[d]-
                    )
                )
            )

            (: d : D :
                p.d[d] & cp[2] => mem.d[d]+
            )
        }
        // ground dummy nodes
        ce[0] = g.GND;
        ce[1] = g.GND;
        ce[3] = g.GND;
        cp[3] = g.GND;
    }

    export
    template <pint N>
    defproc LEAF_NODATA (globals g; bool pp, pe, ce[N], cp[N]; c1of<N> p) {
        // leaf of AERV tree that does not transmit data
        bool u;
        prs<g.Vdd, g.GND> {
            pp & (& : n : N : ~ce[n]) | u => pe+

            (: n : N :
                p.d[n] -> cp[n]+
                ~pp -> cp[n]-
            )

            (| : n : N : ce[n] & ~p.d[n]) => u+
        }
    }
} // namespace receiver

export
template <pint M, Mp4, N_SYN, N_MEM>
defproc AERV (globals g; bool pp, pe, cp[Mp4], ce[Mp4]; c1of<4> p; e1of2 syn[N_SYN]; c1of4 mem[N_MEM]) {
    // receiver capable of sending data to neuron
    // M tree levels
    // Mp4 = M^4 potential output ports
    // N_SYN synapses
    // N_MEM memories
    pint D = 4; // 1-of-D data
    pint F = 4; // fanout for intermediate nodes
    [ M = 1 ->
        N_SYN = 4; // assert
        N_MEM = 1; // assert
        Mp4 = 4; // assert
        receiver::LEAF leaf(g, pp, pe, cp, ce, p, syn, mem[0]);
    [] M > 1 ->
        N_MEM*4 = N_SYN; // assert
        pint k = Mp4/4;
        pint k_syn = N_SYN/4;
        pint k_mem = N_MEM/4;
        AERV<M-1, k, k_syn, k_mem> _[F];
        receiver::NODE<F, D> node(g, pp, pe,,, p,);
        (; f : F :
            _[f].g = g;
            _[f].p = node.c[f];
            _[f].pp = node.cp[f];
            _[f].pe = node.ce[f];
            _[f].cp = cp[f*k..(f+1)*k-1];
            _[f].ce = ce[f*k..(f+1)*k-1];
            _[f].syn = syn[f*k_syn..(f+1)*k_syn-1];
            _[f].mem = mem[f*k_mem..(f+1)*k_mem-1];
        )
    ]
}

export
template <pint M, N, NN>
defproc AERV_NODATA (globals g; bool yi[NN], yp[NN], pp, pe; c1of<N> p) {
    // receiver that does not send data to neurons
    [ M = 1 ->
        NN = N;
        receiver::LEAF_NODATA<N> leaf(g, pp, pe, yi, yp, p);
    [] M > 1 ->
        AERV_NODATA<M-1, N, NN/N> _[N];
        receiver::NODE<N, N> node(g, pp, pe,,, p,);
        pint k = NN/N;
        (; n : N :
            _[n].g = g;
            _[n].p = node.c[n];
            _[n].pp = node.cp[n];
            _[n].pe = node.ce[n];
            _[n].yi = yi[n*k..(n+1)*k-1];
            _[n].yp = yp[n*k..(n+1)*k-1];
        )
    ]
}

namespace brain_receiver {
    template <pint C>
    defproc MERGE_ACK (globals g; bool pp, pe, ce[C]) {
         // merges acknowledges from children with pphi acknowledge
         // C clients
         prs<g.Vdd, g.GND> {
            pp & (& : c : C : ~ce[c]) => pe+
         }
    }

    export
    template <pint M>
    defproc DESERIALIZER (globals g; bool xp, xe; c1of4 x; eMx1of4<M> _y) {
        // wrapper for the deserializer
        pint D = 4; // 1-of-D data

        MERGE_ACK<1> merge_ack(g, xp, xo,);
        ::aer::interface::DESERIAL_RING<M, D, true, true> deserial(g,,);
        deserial.x.d = x.d;
        deserial.x.a = merge_ack.ce[0];
        (; m : M :
            deserial.y.m[m].d = _y.m[m].d;
        )
        deserial.y.e = _y.e;
    }

    export
    defproc HALF_BUFFER (globals g; e1of2 x; a1of2 y) {
        // prevents the synapse from holding up the receiver tree
        // wchb providing a half cycle of buffering
        pint D = 2; // for 1of2
        bool ye;
        prs<g.Vdd, g.GND> {
            y.a => ye-

            (& : d : D : ~y.d[d]) => x.e+

            (: d : D :
                x.d[d] & ye -> y.d[d]+
                g.pReset | ~x.d[d] & ~ye -> y.d[d]-
            )
        }
    }
} // namespace brain_receiver

export
template <pint M, Mp4, M_SPK, M_MEM, N_SYN, N_MEM>
defproc BRAIN_AERV (globals g; eMx1of4<M_SPK> x_spk; 
                    eMx1of4<M_MEM> x_mem;
                    a1of2 y_syn[N_SYN]; eMx1of4<M_MEM-M> _y_mem[N_MEM]) {
    // braindrop / brainstorm receiver system
    // M tree depth
    //     M = 5 (in production)
    // Mp4 potential ports
    //     Mp4 = M^4
    // M_SPK packet length of spike to deliver to synapse.
    //     M_SPK = M + 1
    //     M_SPK = 6 (in production)
    // M_MEM packet length to write config memory
    //     M_MEM = M + memory packet length
    //     M_MEM = 9 (in production)
    // N_SYN synapses
    //     N_SYN = 4^M
    //     N_SYN = 1024 (in production)
    // N_MEM configuration memories
    //     N_MEM = 4^(M-1)
    //     N_MEM = 256 (in production)
    pint D = 4; // 1-of-D data
    N_MEM*4 = N_SYN; // assert

    interface::SERIAL_RING<M_SPK, D> serial_spk(g,,,,);
    interface::SERIAL_RING<M_MEM, D> serial_mem(g,,,,);
    (; m : M_SPK :
        serial_spk.x.m[m].d = x_spk.m[m].d;
    )
    (; m : M_MEM :
        serial_mem.x.m[m].d = x_mem.m[m].d;
    )
    serial_spk.x.e = x_spk.e;
    serial_mem.x.e = x_mem.e;

    bool merge_xp[2];
    bool merge_xo[2];
    c1of<D> merge_x[2];
    merge_xp[0] = serial_spk.yp;
    merge_xp[1] = serial_mem.yp;
    merge_xo[0] = serial_spk.yi;
    merge_xo[1] = serial_mem.yi;
    merge_x[0] = serial_spk.y;
    merge_x[1] = serial_mem.y;

    interface::SERIAL_MERGE<2, D> merge(g, merge_xp, merge_xo,,, merge_x,);
    bool aerv_pp = merge.yp;
    bool aerv_pe = merge.yi;
    c1of<D> aerv_p = merge.y;

    brain_receiver::DESERIALIZER<M_MEM-M> mem_deserial[N_MEM];
    bool aerv_cp[Mp4];
    bool aerv_ce[Mp4];
    c1of4 aerv_mem[N_MEM];
    (; n : N_MEM :
        mem_deserial[n].g = g;
        mem_deserial[n].xp = aerv_cp[n*4+2]; // connect deserial to aerv
        mem_deserial[n].xe = aerv_ce[n*4+2];
        mem_deserial[n].x = aerv_mem[n];
        mem_deserial[n]._y = _y_mem[n]; // connect deserial to memory
    )
    
    brain_receiver::HALF_BUFFER buf_syn[N_SYN]; // buffer synapse spikes
    e1of2 aerv_syn[N_SYN];
    (; n : N_SYN :
        buf_syn[n].g = g;
        buf_syn[n].x = aerv_syn[n]; // connect buf_syn to aerv
        buf_syn[n].y = y_syn[n]; // connect buf_syn to synapse
    )

    AERV<M, Mp4, N_SYN, N_MEM> aerv(
        g, aerv_pp, aerv_pe, aerv_cp, aerv_ce, aerv_p, aerv_syn, aerv_mem);
}

} // namespace aer
