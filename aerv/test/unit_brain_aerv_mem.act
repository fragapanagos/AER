// tests that brain aerv can deliver memory packets
import "aer/aerv/aerv.act";

pint M     = 3;
pint Mp4   = 64; // 4**M
pint M_SPK = M+1;
pint M_MEM = M+4;
pint N_SYN = Mp4;
pint N_MEM = N_SYN/4;
pint D     = 4;
pbool flip_mem_out = true;
pint Rmax = 4;
pint R[M];
pint S[M][Rmax];
pint CAP[M][Rmax];
R = {4, 2, 2};
S = {{3, 10, 6, 36},
     {3, 10, 0, 0},
     {3, 10, 0, 0}};
CAP = {{4, 64, 4, 64},
       {4, 64, 0, 0},
       {4, 32, 0, 0}};

aer::globals g;
bool Reset = g.sReset;
aer::SINK_e1ofN<2> spk_snk[N_SYN];
aer::SINK_eMx1ofN<M_MEM-M, D> mem_snk[N_MEM];

aer::a1of2 y_syn[N_SYN];
(; n : N_SYN :
    spk_snk[n].g = g;
    spk_snk[n].d.d = y_syn[n].d;
    prs<g.Vdd, g.GND> {
        spk_snk[n].d.e => y_syn[n].a-
    }
)

aer::eMx1of4<M_MEM-M> _y_mem[N_MEM];
(; n : N_MEM :
    mem_snk[n].g = g;
    mem_snk[n].d.e = _y_mem[n].e;
)
prs<g.Vdd, g.GND> {
    (: n : N_MEM :
        (: m : M_MEM - M :
            (: d : D :
                _y_mem[n].m[m].d[d] => mem_snk[n].d.m[m].d[d]-
            )
        )
    )
}

aer::eMx1of4<M_SPK> spk_src;
aer::eMx1of2<2*M_MEM> mem_src;
(; m : M_SPK:
    (; n : D :
        spk_src.m[m].n[n] = g.GND;
    )
)
aer::eMx1of2_to_eMx1of4<2*M_MEM, M_MEM> mem_src_(g, mem_src,);

aer::BRAIN_AERV<M, Mp4, M_SPK, M_MEM, N_SYN, N_MEM, flip_mem_out, Rmax, R, S, CAP>
    aerv(g, spk_src, mem_src_.y, y_syn, _y_mem);
