// tests that bs_aerv works without deadlock, instability, or interference
// while both spikes and memory packets are being delivered randomly
import "aer/aerv/bs_aerv.act";
import "aer/lib/test.act";

/*---------- M=3 ------------*/
pint M_1of4     = 3;
pint M_1of2     = 2*M_1of4;
pint Mp4        = 64; // 4**M_1of4
pint Rmax = 4;
pint R[M_1of4];
pint S[M_1of4][Rmax];
pint CAP[M_1of4][Rmax];
R = {4, 2, 2};
S = {{3, 10, 6, 36},
     {3, 10, 0, 0},
     {3, 10, 0, 0}};
CAP = {{4, 64, 4, 64},
       {4, 64, 0, 0},
       {4, 32, 0, 0}};
/*---------- M=1 ------------*/
// pint M_1of4     = 1;
// pint M_1of2     = 2*M_1of4;
// pint Mp4        = 4; // 4**M_1of4
// pint Rmax = 2;
// pint R[M_1of4];
// pint S[M_1of4][Rmax];
// pint CAP[M_1of4][Rmax];
// R = {2};
// S = {{3, 10}};
// CAP = {{4, 32}};
/*---------------------------*/

pint M_SPK_1of4 = M_1of4+1;
pint M_SPK_1of2 = 2*M_SPK_1of4;
pint M_MEM_1of4 = M_1of4+4;
pint M_MEM_1of2 = 2*M_MEM_1of4;
pint N_SYN = Mp4;
pint N_MEM = N_SYN/4;
pint D     = 4;
pbool flip_mem_out = true;

aer::globals g;
aer::SOURCE_BRAIN_AERV<M_SPK_1of4, M_SPK_1of4-M_1of4, 0, 2> spk_src(g,);
aer::SOURCE_BRAIN_AERV<M_MEM_1of4, M_MEM_1of4-M_1of4, 2, 1> mem_src(g,);
aer::eMx1of4_to_eMx1of2<M_SPK_1of4, M_SPK_1of2> spk_src_4to2(g, spk_src.d,);
aer::eMx1of4_to_eMx1of2<M_MEM_1of4, M_MEM_1of2> mem_src_4to2(g, mem_src.d,);
aer::SYNAPSE spk_snk[N_SYN];
aer::SINK_eMx1ofN<M_MEM_1of4 - M_1of4, D> mem_snk[N_MEM];

aer::a1of2 y_syn[N_SYN];
(; n : N_SYN :
    spk_snk[n].g = g;
    spk_snk[n].spk.d = y_syn[n].d;
    spk_snk[n].spk.a = y_syn[n].a;
)
aer::eMx1of4<M_MEM_1of4-M_1of4> y_mem[N_MEM];
(; n : N_MEM :
    mem_snk[n].g = g;
    (; m : M_MEM_1of4 - M_1of4 :
        mem_snk[n].d.m[m].d = y_mem[n].m[m].d;
    )
    mem_snk[n].d.e = y_mem[n].e;
)

BS_AERV<M_1of2, M_1of4, Mp4, M_SPK_1of2, M_SPK_1of4, M_MEM_1of2, M_MEM_1of4, N_SYN, N_MEM, flip_mem_out, Rmax, R, S, CAP> aerv(
    g, spk_src_4to2.y, mem_src_4to2.y, y_syn, y_mem);
