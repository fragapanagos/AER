// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/lib/arbiter.act";

namespace aer {

namespace transmitter {
    export
    template <pint N; pbool root>
    defproc NODE (globals g; bool _cp[N], co[N], pi, _pp; c1of<N> _c[N], _p) {
        // AEXT tree NODE
        bool c_[N], _co[N], v, _v, _u[N];
        c1of<N> p;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c_);

        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v & (| : n : N : c_[n]) -> _pp-
                ~g._pReset | (| : n : N : ~_co[n] & ~c_[n]) -> _pp+

                (: n : N :
                    c_[n] & pi & _v -> _u[n]-
                    ~g._pReset | ~_v -> _u[n]+
                )

                ~pi & (| : n : N : ~_u[n]) -> v+
                _pp & (& : n : N : _co[n]) -> v-

                v => _v-

                c_[0] & v & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                (: n : 1..N-2:
                    c_[n] & v & pi & 
                        (& : nn : 0..n-1 : _co[nn]) & 
                        (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                )
                c_[N-1] & v & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                (: n : N :
                    ~pi -> _co[n]+

                    _co[n] => co[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]) | ~_u[n] => p.d[n]+
                )
            }

            [ ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        p.d[n] => _p.d[n]-
                    )
                }
            [] root ->
                p = _p;
            ]
        [] LAYOUT ->
            bool __pp, _pp_;
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v<15> & (| : n : N : c_[n]<15>) -> _pp_-
                ~g._pReset | (| : n : N : ~_co[n]<24> & ~c_[n]<24>) -> _pp_+

                ~_pp_<12> -> __pp+
                _pp_<8> -> __pp-

                ~__pp<12> -> _pp+
                __pp<8> -> _pp-

                (: n : N :
                    c_[n]<20> & pi<20> & _v<20> -> _u[n]-
                    ~g._pReset | ~_v<16> -> _u[n]+
                )

                ~pi<20> & (| : n : N : ~_u[n]<20>) -> v+
                _pp_<20> & (& : n : N : _co[n]<20>) -> v-

                ~v<15> -> _v+
                v<9> -> _v-

                (& : n : 1..N-1 : _co[n]<24>) &
                    v<24> & c_[0]<24> & pi<24> -> _co[0]-
                (: n : 1..N-2:
                    (& : nn : 0..n-1 : _co[nn]<24>) & 
                        (& : nn : n+1..N-1 : _co[nn]<24>) &
                        v<24> & c_[n]<24> & pi<24> -> _co[n]-
                )
                (& : n : 0..N-2 : _co[n]<24>) &
                    v<24> & c_[N-1]<24> & pi<24> -> _co[N-1]-
                (: n : N :
                    ~pi<18> -> _co[n]+

                    ~_co[n]<24> -> co[n]+
                    _co[n]<15> -> co[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]<12>) | ~_u[n]<12> -> p.d[n]+
                    (& : nc : N : _c[nc].d[n]<30>) & _u[n]<30> -> p.d[n]-
                )
            }

            [ ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        ~p.d[n]<12> -> _p.d[n]+
                        p.d[n]<9> -> _p.d[n]-
                    )
                }
            [] root ->
                p = _p;
            ]
        ]
    }

    export
    template <pint N; pbool root>
    defproc LEAF (globals g; bool _cp[N], co[N], pi, _pp; c1of<N> p) {
        // AEXT tree LEAF
        bool c[N], _c[N], __c[N], _u[N], v, _v, __v, pp;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c);
        c1of<N> p_;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                v => _v-
                _v => __v-

                (: n : N :
                    c[n] => _c[n]-
                )

                (| : n : N : ~_c[n]) & ~__v -> pp+
                g.pReset | pi & __v -> pp-

                (: n : N :
                    _c[n] => __c[n]-
                )

                (: n : N :
                    __c[n] & pi & _v -> _u[n]-
                    ~__c[n] & ~pp & ~pi -> _u[n]+
                )

                (| : n : N : ~_u[n]) & ~pi -> v+
                (& : n : N : _u[n]) -> v-

                (: n : N :
                    ~_u[n] & ~_c[n] => p_.d[n]+
                )

                (: n : N :
                    ~_u[n] & ~_v => co[n]+
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                pp => _pp-
            }
            [ root ->
                p_ = p; // preserve sense
            [] ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        p_.d[n] => p.d[n]- // switch to active low
                    )
                }
            ]
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~v<14> -> _v+
                v<9> -> _v-

                ~_v<9> -> __v+
                _v<6> -> __v-

                (: n : N :
                    ~c[n]<10> -> _c[n]+
                    c[n]<6> -> _c[n]-
                )

                (| : n : N : ~_c[n]<27>) & ~__v<27> -> pp+
                g.pReset | pi<12> & __v<12> -> pp-

                (: n: N :
                    ~_c[n]<9> -> __c[n]+
                    _c[n]<6> -> __c[n]-
                )

                (: n : N :
                    pi<16> & __c[n]<16> & _v<16> -> _u[n]-
                    ~pi<26> & ~__c[n]<26> & ~pp<26> -> _u[n]+
                )

                ~pi<18> & (| : n : N : ~_u[n]<18>) -> v+
                (& : n : N : _u[n]<24>) -> v-

                (: n : N :
                    ~_u[n]<15> & ~_c[n]<15> -> p_.d[n]+
                    _u[n]<6> | _c[n]<6> -> p_.d[n]-
                )

                (: n : N :
                    ~_u[n]<16> & ~_v<16> -> co[n]+
                    _u[n]<6> | _v<6> -> co[n]-
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~pp<9> -> _pp+
                pp<6> -> _pp-
            }
            [ root ->
                p_ = p; // preserve sense
            [] ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        // switch to active low
                        ~p_.d[n]<9> -> p.d[n]+
                        p_.d[n]<6> -> p.d[n]-
                    )
                }
            ]
        ]
    }

    export
    template <pint M, N, NN; pbool root>
    defproc AEXT_ (globals g; bool _xp[NN], xo[NN], pi, _pp; c1of<N> p) {
        // utility for AEXT
        [ M = 1 ->
            NN = N;
            LEAF<N, root> leaf(g, _xp, xo, pi, _pp, p);
        [] M > 1 ->
            pint k = NN/N;
            AEXT_<M-1, N, k, false> _[N];
            (; n : N :
                _[n].g = g;
                _[n]._xp = _xp[n*k..(n+1)*k-1];
                _[n].xo = xo[n*k..(n+1)*k-1];
            )

            NODE<N, root> node(g,,, pi, _pp,, p);
            (; n : N :
                node._cp[n] = _[n]._pp;
                node.co[n] = _[n].pi;
                node._c[n] = _[n].p;
            )
        ]
    }
} // namespace transmitter

export
template <pint M, N, NN>
defproc AEXT (globals g; bool _xp[NN], xo[NN], pi, pp; c1of<N> p) {
    // Transmitter
    transmitter::AEXT_<M, N, NN, true> _(g, _xp, xo, pi,, p);
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        ~_._pp<9> -> pp+
        _._pp<6> -> pp-
    }
}

} // namespace aer
