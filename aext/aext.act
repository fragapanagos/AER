// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/lib/arbiter.act";

namespace aer {

namespace transmitter {
    export
    template <pint N>
    defproc NODE (globals g; bool _cp[N], ce[N], pe, _pp; c1of<N> _c[N], _p) {
        // AEXT tree NODE
        bool c_[N], _ce[N], v, _v, _u[N];
        c1of<N> p;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c_);

        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v & (| : n : N : c_[n]) -> _pp-
                ~g._pReset | (| : n : N : ~_ce[n] & ~c_[n]) -> _pp+

                (: n : N :
                    c_[n] & pe & _v -> _u[n]-
                    ~g._pReset | ~_v -> _u[n]+
                )

                ~pe & (| : n : N : ~_u[n]) -> v+
                _pp & (& : n : N : _ce[n]) -> v-

                v => _v-

                c_[0] & v & pe & (& : n : 1..N-1 : _ce[n]) -> _ce[0]-
                (: n : 1..N-2:
                    c_[n] & v & pe & 
                        (& : nn : 0..n-1 : _ce[nn]) & 
                        (& : nn : n+1..N-1 : _ce[nn]) -> _ce[n]-
                )
                c_[N-1] & v & pe & (& : n : 0..N-2 : _ce[n]) -> _ce[N-1]-
                (: n : N :
                    ~pe -> _ce[n]+

                    _ce[n] => ce[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]) | ~_u[n] => p.d[n]+
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    p.d[n] => _p.d[n]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v<15> & (| : n : N : c_[n]<15>) -> _pp-
                ~g._pReset<9> | (| : n : N : ~_ce[n]<24> & ~c_[n]<24>) -> _pp+

                (: n : N :
                    c_[n]<18> & pe<18> & _v<18> -> _u[n]-
                    ~g._pReset<9> | ~_v<16> -> _u[n]+
                )

                ~pe<20> & (| : n : N : ~_u[n]<20>) -> v+
                _pp<18> & (& : n : N : _ce[n]<18>) -> v-

                ~v<15> -> _v+
                v<9> -> _v-

                (& : n : 1..N-1 : _ce[n]<18>) &
                    v<18> & c_[0]<18> & pe<18> -> _ce[0]-
                (: n : 1..N-2:
                    (& : nn : 0..n-1 : _ce[nn]<18>) & 
                        (& : nn : n+1..N-1 : _ce[nn]<18>) &
                        v<18> & c_[n]<18> & pe<18> -> _ce[n]-
                )
                (& : n : 0..N-2 : _ce[n]<18>) &
                    v<18> & c_[N-1]<18> & pe<18> -> _ce[N-1]-
                (: n : N :
                    ~pe<18> -> _ce[n]+

                    ~_ce[n]<24> -> ce[n]+
                    _ce[n]<18> -> ce[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]<12>) | ~_u[n]<12> -> p.d[n]+
                    (& : nc : N : _c[nc].d[n]<18>) & _u[n]<18> -> p.d[n]-
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    ~p.d[n]<12> -> _p.d[n]+
                    p.d[n]<9> -> _p.d[n]-
                )
            }
        ]
    }

    export
    template <pint N>
    defproc LEAF (globals g; bool _cp[N], ca[N], pe, _pp; c1of<N> _p) {
        // AEXT tree LEAF
        bool c[N], _c[N], __c[N], _u[N], v, _v, __v, pp;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c);
        c1of<N> p;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                v => _v-
                _v => __v-

                (: n : N :
                    c[n] => _c[n]-
                )

                (| : n : N : ~_c[n]) & ~__v -> pp+
                g.pReset | pe & __v -> pp-

                (: n : N :
                    _c[n] => __c[n]-
                )

                (: n : N :
                    __c[n] & pe & _v -> _u[n]-
                    ~__c[n] & ~pp & ~pe -> _u[n]+
                )

                (| : n : N : ~_u[n]) & ~pe -> v+
                (& : n : N : _u[n]) -> v-

                (: n : N :
                    ~_u[n] & ~_c[n] => p.d[n]+
                )

                (: n : N :
                    ~_u[n] & ~_v => ca[n]+
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                // switch to active low
                (: n : N :
                    p.d[n] => _p.d[n]-
                )
                pp => _pp-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~v<14> -> _v+
                v<9> -> _v-

                ~_v<9> -> __v+
                _v<6> -> __v-

                (: n : N :
                    ~c[n]<10> -> _c[n]+
                    c[n]<6> -> _c[n]-
                )

                (| : n : N : ~_c[n]<27>) & ~__v<27> -> pp+
                g.pReset<6> | pe<12> & __v<12> -> pp-

                (: n: N :
                    ~_c[n]<9> -> __c[n]+
                    _c[n]<6> -> __c[n]-
                )

                (: n : N :
                    pe<18> & __c[n]<18> & _v<18> -> _u[n]-
                    ~pe<27> & ~__c[n]<27> & ~pp<27> -> _u[n]+
                )

                ~pe<18> & (| : n : N : ~_u[n]<18>) -> v+
                (& : n : N : _u[n]<18>) -> v-

                (: n : N :
                    ~_u[n]<15> & ~_c[n]<15> -> p.d[n]+
                    _u[n]<6> | _c[n]<6> -> p.d[n]-
                )

                (: n : N :
                    ~_u[n]<16> & ~_v<16> -> ca[n]+
                    _u[n]<6> | _v<6> -> ca[n]-
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                // switch to active low
                (: n : N :
                    ~p.d[n]<9> -> _p.d[n]+
                    p.d[n]<6> -> _p.d[n]-
                )
                ~pp<9> -> _pp+
                pp<6> -> _pp-
            }
        ]
    }

    template <pint M, N, L, BASE_IDX, IDXs, Rmax; pint R[M],
              Se[M][Rmax], CAPe[M][Rmax], Spd[M][Rmax], CAPpd[M][Rmax]>
    defproc AMP_WIRES_ (globals g; bool c_pp[L], c_pe[L], p_cp[L], p_ce[L];
                       c1of<N> c_p[L], p_c[L]) {
        // Utility for AMP_WIRES
        // M AEXT tree current and below
        // N radix of AEXT tree
        // L links in AEXT tree = (N^M-1) / (N-1) = number of LEAFs and NODEs

        // Rarray repeater inverters
        // Se[R] scales size of repeater inverters (for enable pco->cpi)
        // CAPe[R] capacitive load along repeaters (units of min size inverter cap) (for enable pco->cpi)
        // Spd[R] scales size of repeater inverters (for phi _cpp->_pcp and data cp->pc)
        // CAPpd[R] capacitive load along repeaters (units of min size inverter cap) (for phi _cpp->_pcp and data cp->pc)
        // .------------------------------------------------------------------------------------------------.
        // |                link  | R | Se             | CAPe            | Spd            | CAPpd           |
        // |----------------------|---|----------------|-----------------|----------------|-----------------|
        // | root    - array edge | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} | {5, 1, 5, 25}  | {64, 4, 4, 192} |
        // | node[0] - root       | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} | {5, 1, 5, 25}  | {64, 4, 4, 192} |
        // | node[1] - node[0]    | 4 | {3, 10, 6, 36} | {4, 64, 4, 64}  | {5, 1, 5, 25}  | {64, 4, 4, 64}  |
        // | node[2] - node[1]    | 2 | {3, 10}        | {4, 64}         | {5, 1}         | {64, 4}         |
        // | node[3] - node[2]    | 2 | {3, 10}        | {4, 32}         | {5, 1}         | {32, 4}         |
        // | leaf    - node[3]    | 2 | {3, 10}        | {4, 16}         | {5, 1}         | {16, 4}         |
        // --------------------------------------------------------------------------------------------------
        preal min_inv_cap = 0.25; // assume min_inv_cap=0.25
        
        preal Ce[R[0]];
        preal Cpd[R[0]];
        (; r : R[0] :
            Ce[r] = min_inv_cap * CAPe[0][r];
            Cpd[r] = min_inv_cap * CAPpd[0][r];
        )
        REPEATER_BOOL<R[0], Spd[0][0..R[0]-1], Cpd, 1> c_pp__p_cp[IDXs];
        REPEATER_BOOL<R[0], Se[0][0..R[0]-1], Ce, 2> p_ce__c_pe[IDXs];
        REPEATER_c1of<N, R[0], Spd[0][0..R[0]-1], Cpd, 1> c_p__p_c[IDXs];
        (; i : IDXs :
            c_pp__p_cp[i].g = g;
            c_pp__p_cp[i].i = c_pp[BASE_IDX+i];
            c_pp__p_cp[i].o = p_cp[BASE_IDX+i];

            p_ce__c_pe[i].g = g;
            p_ce__c_pe[i].i = p_ce[BASE_IDX+i];
            p_ce__c_pe[i].o = c_pe[BASE_IDX+i];

            c_p__p_c[i].g = g;
            c_p__p_c[i].i = c_p[BASE_IDX+i];
            c_p__p_c[i].o = p_c[BASE_IDX+i];
        )

        [ M > 1 ->
            AMP_WIRES_<M-1, N, L, BASE_IDX+IDXs, IDXs*N, Rmax, R[1..M-1],
                       Se[1..M-1], CAPe[1..M-1], Spd[1..M-1], CAPpd[1..M-1]> 
                _(g, c_pp, c_pe, p_cp, p_ce, c_p, p_c);
        ]
    }

    export
    template <pint M, N, L>
    defproc AMP_WIRES (globals g; bool c_pp[L], c_pe[L], p_cp[L], p_ce[L];
                       c1of<N> c_p[L], p_c[L]) {
        // model the amplifier and wire capacitances internal to the aext tree
        // M depth of AEXT tree (max 6)
        // N radix of AEXT tree (N=4 in production)
        // L links in AEXT tree = (N^M-1) / (N-1) = number of LEAFs and NODEs
        pint Mmax = 6; // max AEXT tree depth
        [M > Mmax -> 0=1;] // assert false
        pint Rmax = 4; // max repeaters between AEXT nodes
        pint R_ref[Mmax];
        pint Se_ref[Mmax][Rmax], Spd_ref[Mmax][Rmax];
        pint CAPe_ref[Mmax][Rmax], CAPpd_ref[Mmax][Rmax];
        // repeaters per stage
        R_ref = {4, 4, 4, 2, 2, 2};
        // sizing per repeater per stage
        Se_ref = {{3, 10, 6, 36},
                  {3, 10, 6, 36},
                  {3, 10, 6, 36},
                  {3, 10, 0, 0 },
                  {3, 10, 0, 0 },
                  {3, 10, 0, 0 }};
        Spd_ref = {{5, 1, 5, 25},
                   {5, 1, 5, 25},
                   {5, 1, 5, 25},
                   {5, 1, 0, 0 },
                   {5, 1, 0, 0 },
                   {5, 1, 0, 0 }};
        // cap per repeater per stage
        CAPe_ref = {{4, 64, 4, 192},
                    {4, 64, 4, 192},
                    {4, 64, 4, 64 },
                    {4, 64, 0, 0  },
                    {4, 32, 0, 0  },
                    {4, 16, 0, 0  }};
        CAPpd_ref = {{64, 4, 4, 192},
                     {64, 4, 4, 192},
                     {64, 4, 4, 64 },
                     {64, 4, 0, 0  },
                     {32, 4, 0, 0  },
                     {16, 4, 0, 0  }};

        pint R[M];
        pint Se[M][Rmax], Spd[M][Rmax];
        pint CAPe[M][Rmax], CAPpd[M][Rmax];
        pint Mbase = Mmax-M;
        R = R_ref[Mbase..Mmax-1];
        Se = Se_ref[Mbase..Mmax-1];
        Spd = Spd_ref[Mbase..Mmax-1];
        CAPe = CAPe_ref[Mbase..Mmax-1];
        CAPpd = CAPpd_ref[Mbase..Mmax-1];

        AMP_WIRES_<M, N, L, 0, 1, Rmax, R, Se, CAPe, Spd, CAPpd> 
            _(g, c_pp, c_pe, p_cp, p_ce, c_p, p_c);
        }
} // namespace transmitter

export
template <pint M, N, NN>
defproc AEXT (globals g; bool _xp[NN], xa[NN], pe, pp; c1of<N> p) {
    // Transmitter transmits spikes from neurons to datapath
    // M depth of AEXT tree (max 6)
    // N radix of AEXT tree
    // NN neurons = N^M

    pint N_LEAF = NN/N; // = N^(M-1)
    pint N_NODE = (NN-N) / (N*(N-1)); // = (N^(M-1)-1) / (N-1)
    pint N_LINK = N_LEAF + N_NODE; // = (N^M-1) / (N-1)

    transmitter::LEAF<N> leaf[N_LEAF];
    (; n : N_LEAF :
        leaf[n].g = g;
        leaf[n]._cp = _xp[n*N..(n+1)*N-1];
        leaf[n].ca = xa[n*N..(n+1)*N-1];
    )

    transmitter::AMP_WIRES<M, N, N_LINK> repeater_wires(g,,,,,,);
    repeater_wires.p_ce[0] = pe;
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        // switch to active high outside of array
        ~repeater_wires.p_cp[0]<9> -> pp+
        repeater_wires.p_cp[0]<6> -> pp-
        (: n : N :
            ~repeater_wires.p_c[0].d[n]<9> -> p.d[n]+
            repeater_wires.p_c[0].d[n]<6> -> p.d[n]-
        )
    }

    [ M = 1 ->
        NN = N; // assert
        leaf[0].pe = repeater_wires.c_pe[0];
        leaf[0]._pp = repeater_wires.c_pp[0];
        leaf[0]._p = repeater_wires.c_p[0];
    [] M > 1 ->
        transmitter::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        node[0].pe = repeater_wires.c_pe[0];
        node[0]._pp = repeater_wires.c_pp[0];
        node[0]._p = repeater_wires.c_p[0];

        // connect NODEs to LEAFs
        pint N_LOW_NODE = N_LEAF/N; // NODEs connecting to LEAFs
        pint NODE_BASE_IDX = N_NODE-N_LOW_NODE;
        (; node_idx : NODE_BASE_IDX..N_NODE-1 :
            (; n : N :
                node[node_idx].ce[n] = repeater_wires.p_ce[node_idx*N+n+1];
                node[node_idx]._cp[n] = repeater_wires.p_cp[node_idx*N+n+1];
                node[node_idx]._c[n] = repeater_wires.p_c[node_idx*N+n+1];

                repeater_wires.c_pe[node_idx*N+n+1] =
                    leaf[(node_idx-NODE_BASE_IDX)*N+n].pe;
                repeater_wires.c_pp[node_idx*N+n+1] =
                    leaf[(node_idx-NODE_BASE_IDX)*N+n]._pp;
                repeater_wires.c_p[node_idx*N+n+1] =
                    leaf[(node_idx-NODE_BASE_IDX)*N+n]._p;
            )
        )

        // connect NODEs to NODEs
        [ M > 2 ->
            (; np : NODE_BASE_IDX :
                (; nc : N :
                    node[np].ce[nc] = repeater_wires.p_ce[np*N+nc+1];
                    node[np]._cp[nc] = repeater_wires.p_cp[np*N+nc+1];
                    node[np]._c[nc] = repeater_wires.p_c[np*N+nc+1];

                    repeater_wires.c_pe[np*N+nc+1] = node[np*N+nc+1].pe;
                    repeater_wires.c_pp[np*N+nc+1] = node[np*N+nc+1]._pp;
                    repeater_wires.c_p[np*N+nc+1] =  node[np*N+nc+1]._p;
                )
            )
        ]
    ]
}

export
template <pint M, p4M>
defproc AEXT_TO_TILE (globals g;
                      bool _cp[p4M/16], ce[p4M/16]; c1of<4> _c[p4M/16];
                      bool pe, pp; c1of<4> p) {
    // AEXT tree above the TILE (in logic space)
    // contains all but the lowest level intermediate NODEs
    // M tree levels (require M>=2)
    // p4M = 4^M neurons
    [ M < 2 ->
        0=1; // assert false
    ]
    pint N = 4; // required for TILE
    pint N_NODE = (p4M/N/N-1) / (N-1); // = (N^(M-2)-1) / (N-1)

    [ M = 2 ->
        p4M = 4*N; // assert
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            _cp[0] => pp-
            (: n : N :
                _c[0].d[n] => p.d[n]-
            )
        }
        ce[0] = pe;
    [] M > 2 ->
        transmitter::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            node[0]._pp => pp-
            (: n : N :
                node[0]._p.d[n] => p.d[n]-
            )
        }
        node[0].pe = pe;

        // connect NODEs to child ports
        pint N_LOW_NODE = p4M/N/N/N; // NODEs connecting to LEAFs
        pint NODE_BASE_IDX = N_NODE-N_LOW_NODE;
        (; node_idx : NODE_BASE_IDX..N_NODE-1 :
            (; n : N :
                node[node_idx].ce[n] = ce[(node_idx-NODE_BASE_IDX)*N+n];
                node[node_idx]._cp[n] = _cp[(node_idx-NODE_BASE_IDX)*N+n];
                node[node_idx]._c[n] = _c[(node_idx-NODE_BASE_IDX)*N+n];
            )
        )

        // connect NODEs to NODEs
        [ M > 2 ->
            (; np : NODE_BASE_IDX :
                (; nc : N :
                    node[np]._cp[nc] = node[np*N+nc+1]._pp;
                    node[np].ce[nc] = node[np*N+nc+1].pe;
                    node[np]._c[nc] =  node[np*N+nc+1]._p;
                )
            )
        ]
    ]
}

namespace brain_transmitter {
    export
    template <pint NN>
    defproc NRN_BUF (globals g; bool xp[NN], xa[NN], ya[NN], _yp[NN]) {
        // buffer the neuron spikes so that the refractory period does not
        // hold up the transmitter
        // NN neurons
        bool _xa[NN];
        bool __xa[NN];
        __xa = xa;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: nn : NN :
                    xp[nn] & _xa[nn] => _yp[nn]-

                    ya[nn] -> _xa[nn]-
                    ~ya[nn] & ~xp[nn] -> _xa[nn]+

                    _xa[nn] => __xa[nn]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: nn : NN :
                    xp[nn]<12> & _xa[nn]<12> -> _yp[nn]-
                    ~xp[nn]<9> | ~_xa[nn]<9> -> _yp[nn]+

                    ya[nn]<6> -> _xa[nn]-
                    ~ya[nn]<18> & ~xp[nn]<18> -> _xa[nn]+

                    ~_xa[nn]<9> -> __xa[nn]+
                    _xa[nn]<6> -> __xa[nn]-
                )
            }
        ]
    }
} // namespace brain_transmitter

export
template <pint M, N, NN>
defproc BRAIN_AEXT (globals g; bool xp[NN], xa[NN], pe, pp; c1of<N> p) {
    // braindrop / brainstorm transmitter system
    // M tree depth
    //     M = 6 in production
    // N node fanout
    //     N = 4 in production
    // NN neurons
    //     NN = 4^M
    //     NN = 4096 in production
    AEXT<M, N, NN> _(g,,, pe, pp, p);
    brain_transmitter::NRN_BUF<NN> buf(g, xp, xa, _.xa, _._xp);
}

} // namespace aer
