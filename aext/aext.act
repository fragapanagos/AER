// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/lib/arbiter.act";
import "aer/interface/interface.act";

namespace aer {

namespace transmitter {
    export
    template <pint N>
    defproc NODE (globals g; bool _cp[N], ce[N], pe, _pp; c1of<N> _c[N], _p) {
        // AEXT tree NODE
        bool c_[N], _ce[N], v, _v, _u[N];
        c1of<N> p;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c_);

        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v & (| : n : N : c_[n]) -> _pp-
                ~g._pReset | (| : n : N : ~_ce[n] & ~c_[n]) -> _pp+

                (: n : N :
                    c_[n] & pe & _v -> _u[n]-
                    ~g._pReset | ~_v -> _u[n]+
                )

                ~pe & (| : n : N : ~_u[n]) -> v+
                _pp & (& : n : N : _ce[n]) -> v-

                v => _v-

                c_[0] & v & pe & (& : n : 1..N-1 : _ce[n]) -> _ce[0]-
                (: n : 1..N-2:
                    c_[n] & v & pe & 
                        (& : nn : 0..n-1 : _ce[nn]) & 
                        (& : nn : n+1..N-1 : _ce[nn]) -> _ce[n]-
                )
                c_[N-1] & v & pe & (& : n : 0..N-2 : _ce[n]) -> _ce[N-1]-
                (: n : N :
                    ~pe -> _ce[n]+

                    _ce[n] => ce[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]) | ~_u[n] => p.d[n]+
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    p.d[n] => _p.d[n]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v<15> & (| : n : N : c_[n]<15>) -> _pp-
                ~g._pReset<9> | (| : n : N : ~_ce[n]<24> & ~c_[n]<24>) -> _pp+

                (: n : N :
                    c_[n]<18> & pe<18> & _v<18> -> _u[n]-
                    ~g._pReset<9> | ~_v<16> -> _u[n]+
                )

                ~pe<20> & (| : n : N : ~_u[n]<20>) -> v+
                _pp<18> & (& : n : N : _ce[n]<18>) -> v-

                ~v<15> -> _v+
                v<9> -> _v-

                (& : n : 1..N-1 : _ce[n]<18>) &
                    v<18> & c_[0]<18> & pe<18> -> _ce[0]-
                (: n : 1..N-2:
                    (& : nn : 0..n-1 : _ce[nn]<18>) & 
                        (& : nn : n+1..N-1 : _ce[nn]<18>) &
                        v<18> & c_[n]<18> & pe<18> -> _ce[n]-
                )
                (& : n : 0..N-2 : _ce[n]<18>) &
                    v<18> & c_[N-1]<18> & pe<18> -> _ce[N-1]-
                (: n : N :
                    ~pe<18> -> _ce[n]+

                    ~_ce[n]<24> -> ce[n]+
                    _ce[n]<18> -> ce[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]<12>) | ~_u[n]<12> -> p.d[n]+
                    (& : nc : N : _c[nc].d[n]<18>) & _u[n]<18> -> p.d[n]-
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: n : N :
                    ~p.d[n]<12> -> _p.d[n]+
                    p.d[n]<9> -> _p.d[n]-
                )
            }
        ]
    }

    export
    template <pint N>
    defproc LEAF (globals g; bool _cp[N], ca[N], pe, _pp; c1of<N> _p) {
        // AEXT tree LEAF
        bool c[N], _c[N], __c[N], _u[N], v, _v, __v, pp;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c);
        c1of<N> p;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                v => _v-
                _v => __v-

                (: n : N :
                    c[n] => _c[n]-
                )

                (| : n : N : ~_c[n]) & ~__v -> pp+
                g.pReset | pe & __v -> pp-

                (: n : N :
                    _c[n] => __c[n]-
                )

                (: n : N :
                    __c[n] & pe & _v -> _u[n]-
                    ~__c[n] & ~pp & ~pe -> _u[n]+
                )

                (| : n : N : ~_u[n]) & ~pe -> v+
                (& : n : N : _u[n]) -> v-

                (: n : N :
                    ~_u[n] & ~_c[n] => p.d[n]+
                )

                (: n : N :
                    ~_u[n] & ~_v => ca[n]+
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                // switch to active low
                (: n : N :
                    p.d[n] => _p.d[n]-
                )
                pp => _pp-
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~v<14> -> _v+
                v<9> -> _v-

                ~_v<9> -> __v+
                _v<6> -> __v-

                (: n : N :
                    ~c[n]<10> -> _c[n]+
                    c[n]<6> -> _c[n]-
                )

                (| : n : N : ~_c[n]<27>) & ~__v<27> -> pp+
                g.pReset<6> | pe<12> & __v<12> -> pp-

                (: n: N :
                    ~_c[n]<9> -> __c[n]+
                    _c[n]<6> -> __c[n]-
                )

                (: n : N :
                    pe<18> & __c[n]<18> & _v<18> -> _u[n]-
                    ~pe<27> & ~__c[n]<27> & ~pp<27> -> _u[n]+
                )

                ~pe<18> & (| : n : N : ~_u[n]<18>) -> v+
                (& : n : N : _u[n]<18>) -> v-

                (: n : N :
                    ~_u[n]<15> & ~_c[n]<15> -> p.d[n]+
                    _u[n]<6> | _c[n]<6> -> p.d[n]-
                )

                (: n : N :
                    ~_u[n]<16> & ~_v<16> -> ca[n]+
                    _u[n]<6> | _v<6> -> ca[n]-
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                // switch to active low
                (: n : N :
                    ~p.d[n]<9> -> _p.d[n]+
                    p.d[n]<6> -> _p.d[n]-
                )
                ~pp<9> -> _pp+
                pp<6> -> _pp-
            }
        ]
    }

    export
    template <pint NN>
    defproc NRN_BUF (globals g; bool xp[NN], xa[NN], ya[NN], _yp[NN]) {
        // buffer the neuron spikes so that the refractory period does not
        // hold up the transmitter
        // NN neurons
        bool _xa[NN];
        bool __xa[NN];
        __xa = xa;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: nn : NN :
                    xp[nn] & _xa[nn] => _yp[nn]-

                    ya[nn] -> _xa[nn]-
                    ~ya[nn] & ~xp[nn] -> _xa[nn]+

                    _xa[nn] => __xa[nn]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: nn : NN :
                    xp[nn]<12> & _xa[nn]<12> -> _yp[nn]-
                    ~xp[nn]<9> | ~_xa[nn]<9> -> _yp[nn]+

                    ya[nn]<6> -> _xa[nn]-
                    ~ya[nn]<18> & ~xp[nn]<18> -> _xa[nn]+

                    ~_xa[nn]<9> -> __xa[nn]+
                    _xa[nn]<6> -> __xa[nn]-
                )
            }
        ]
    }

    namespace repeaters {
        export
        template <pint M_idx, N>
        defproc REPEATERS_P(globals g;
                            bool p__cp, phi_pm; 
                            bool p_ce, enable_pm; 
                            c1of<N> p__c, data_pm) {
            // Repeaters grouped in the parent node cutout
            pint Mmax = 5; // max AEXT NODE tree level
            [M_idx >= Mmax -> 0=1;] // assert false
            pint S_e[2], C_e[Mmax][2];
            pint S_p_d[Mmax][1], C_p_d[Mmax][1];
            // sizing per repeater per stage (bottom to top in tree)
            S_p_d = {{1}, {1}, {0}, {0}, {0}};
            S_e = {3, 10};
            // cap per repeater per stage (bottom to top in tree)
            C_p_d = {{4}, {4}, {0}, {0}, {0}};
            C_e = {{4, 32},
                   {4, 64},
                   {4, 64},
                   {4, 64},
                   {4, 64}};

            [ M_idx > 1 ->
                phi_pm = p__cp;
                data_pm = p__c;
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {} // HACK so netgen -B doesn't complain
            [] M_idx <= 1 ->
                REPEATER_BOOL<1, {S_p_d[M_idx][0]}, {C_p_d[M_idx][0]}>
                    repeaters_phi(g, phi_pm, p__cp);
                REPEATER_c1of<N, 1, {S_p_d[M_idx][0]}, {C_p_d[M_idx][0]}>
                    repeater_data(g, data_pm, p__c);
            ]
            REPEATER_BOOL<2, S_e, C_e[M_idx][0..1]>
                repeaters_enable(g, p_ce, enable_pm);
        }

        namespace mid {
            export
            template <pint M_idx, N>
            defproc REPEATERS_M_PHI_DATA(globals g;
                                         bool phi_pm, phi_mc; 
                                         c1of<N> data_pm, data_mc) {
                // Repeaters grouped in the dedicated repeaters cutout
                pint Mmax = 5; // max AEXT NODE tree level
                [M_idx >= Mmax -> 0=1;] // assert false
                pint S[Mmax][3], C[Mmax][3];
                // sizing per repeater per stage (bottom to top in tree)
                S = {{0, 0, 0 },
                     {0, 0, 0 },
                     {1, 5, 25},
                     {1, 5, 25},
                     {1, 5, 25}};
                // cap per repeater per stage (bottom to top in tree)
                C = {{0, 0, 0  },
                     {0, 0, 0  },
                     {4, 4, 64 },
                     {4, 4, 192},
                     {4, 4, 192}};

                [ M_idx < 2 ->
                    phi_pm = phi_mc; 
                    data_pm = data_mc;
                    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {} // HACK so netgen -B doesn't complain
                [] M_idx >= 2 ->
                    REPEATER_BOOL<3, S[M_idx][0..2], C[M_idx][0..2]>
                      repeaters_phi(g, phi_mc, phi_pm);
                    REPEATER_c1of<N, 3, S[M_idx][0..2], C[M_idx][0..2]>
                        repeater_data(g, data_mc, data_pm);
                ]
            }

            export
            template <pint M_idx, N>
            defproc REPEATERS_M_ENABLE(globals g; bool enable_pm, enable_mc) {
                // Repeaters grouped in the dedicated repeaters cutout
                pint Mmax = 5; // max AEXT NODE tree level
                [M_idx >= Mmax -> 0=1;] // assert false
                pint S[Mmax][2], C[Mmax][2];
                // sizing per repeater per stage (bottom to top in tree)
                S = {{0, 0 },
                     {0, 0 },
                     {6, 36},
                     {6, 36},
                     {6, 36}};
                // cap per repeater per stage (bottom to top in tree)
                C = {{0, 0  },
                     {0, 0  },
                     {4, 64 },
                     {4, 192},
                     {4, 192}};
    
                [ M_idx < 2 ->
                    enable_pm = enable_mc; 
                    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {} // HACK so netgen -B doesn't complain
                [] M_idx >= 2 ->
                    REPEATER_BOOL<2, S[M_idx][0..1], C[M_idx][0..1]>
                        repeaters_en(g, enable_pm, enable_mc);
                ]
            }
        } // namespace mid

        export
        template <pint M_idx, N>
        defproc REPEATERS_M(globals g;
                            bool phi_pm, phi_mc; 
                            bool enable_pm, enable_mc; 
                            c1of<N> data_pm, data_mc) {
            mid::REPEATERS_M_PHI_DATA<M_idx, N>
                repeaters_m_phi_data(g, phi_pm, phi_mc, data_pm, data_mc);
            mid::REPEATERS_M_ENABLE<M_idx, N>
                repeaters_m_enable(g, enable_pm, enable_mc);
        }

        export
        template <pint M_idx, N>
        defproc REPEATERS_C(globals g;
                            bool phi_mc, c__pp; 
                            bool enable_mc, c_pe; 
                            c1of<N> data_mc, c__p) {
            // Repeaters grouped in the child node cutout
            pint Mmax = 5; // max AEXT NODE tree level
            [M_idx >= Mmax -> 0=1;] // assert false
            pint S_p_d[1], C_p_d[Mmax][1];
            // sizing per repeater per stage (bottom to top in tree)
            S_p_d = {5};
            // cap per repeater per stage (bottom to top in tree)
            C_p_d = {{32}, {64}, {64}, {64}, {64}};

            REPEATER_BOOL<1, S_p_d, {C_p_d[M_idx][0]}>
                repeaters_phi(g, c__pp, phi_mc);
            enable_mc = c_pe;
            REPEATER_c1of<N, 1, S_p_d, {C_p_d[M_idx][0]}>
                repeater_data(g, c__p, data_mc);
        }

        export
        template <pint M_idx, N>
        defproc REPEATERS(globals g;
                          bool p__cp, c__pp; 
                          bool p_ce, c_pe; 
                          c1of<N> p__c, c__p) {

            // pm parent-mid
            // mc mid-child
            bool phi_pm, phi_mc;
            bool enable_pm, enable_mc;
            c1of<N> data_pm, data_mc;

            REPEATERS_P<M_idx, N> parent_repeaters(g,
                p__cp, phi_pm, p_ce, enable_pm, p__c, data_pm);
            REPEATERS_M<M_idx, N> mid_repeaters(g,
                phi_pm, phi_mc, enable_pm, enable_mc, data_pm, data_mc);
            REPEATERS_C<M_idx, N> child_repeaters(g,
                phi_mc, c__pp, enable_mc, c_pe, data_mc, c__p);
        }
    } // namespace repeaters
    export

    template <pint M_idx, N, L, BASE_IDX, IDXs>
    defproc REPEATER_TREE_ (globals g; 
                            bool p__cp[L], c__pp[L];
                            bool p_ce[L], c_pe[L];
                            c1of<N> p__c[L], c__p[L]) {
        // Utility for REPEATER_TREE
        // M_idx AEXT tree level (max 4)
        // N radix of AEXT tree (N=4 in production)
        // L links in AEXT tree = (N^M_idx-1) / (N-1) = number of LEAFs and NODEs
        // BASE_IDX index into port heap data structures
        // IDXs number of ports to connect at this level of tree
        repeaters::REPEATERS<M_idx, N> repeaters[IDXs];
        (; i : IDXs :
            repeaters[i].g = g;
            repeaters[i].p__cp = p__cp[BASE_IDX+i];
            repeaters[i].c__pp = c__pp[BASE_IDX+i];
            repeaters[i].p_ce  = p_ce[BASE_IDX+i];
            repeaters[i].c_pe  = c_pe[BASE_IDX+i];
            repeaters[i].p__c  = p__c[BASE_IDX+i];
            repeaters[i].c__p  = c__p[BASE_IDX+i];
        )

        [ M_idx > 0 ->
            REPEATER_TREE_<M_idx-1, N, L, BASE_IDX+IDXs, IDXs*N> 
                _(g, p__cp, c__pp, p_ce, c_pe, p__c, c__p);
        ]
    }

    export
    template <pint M, N, L>
    defproc REPEATER_TREE (globals g; 
                           bool p__cp[L], c__pp[L];
                           bool p_ce[L], c_pe[L];
                           c1of<N> c__p[L], p__c[L]) {
        // Repeaters and wire capacitances internal to the aext tree
        // Can be understood as a tree overlaid with the aext tree
        // M depth of AEXT repeater tree (max 5)
        // N radix of AEXT tree (N=4 in production)
        // L links in AEXT tree = (N^M-1) / (N-1) = number of LEAFs and NODEs
        // .----------------------------------------------------------.
        // |                 link  | S_enable       | C_enable        |
        // |-----------------------|----------------|-----------------|
        // | root    -- array edge | {3, 10, 6, 36} | {4, 64, 4, 192} |
        // | node[0] -- root       | {3, 10, 6, 36} | {4, 64, 4, 192} |
        // | node[1] -- node[0]    | {3, 10, 6, 36} | {4, 64, 4, 64}  |
        // | node[2] -- node[1]    | {3, 10}        | {4, 64}         |
        // | node[3] -- node[2]    | {3, 10}        | {4, 32}         |
        // |----------------------------------------------------------|
        // |                 link  | S_phi/data     | C_phi/data      |
        // |-----------------------|----------------|-----------------|
        // | root    -- array edge | {5, 1, 5, 25}  | {64, 4, 4, 192} |
        // | node[0] -- root       | {5, 1, 5, 25}  | {64, 4, 4, 192} |
        // | node[1] -- node[0]    | {5, 1, 5, 25}  | {64, 4, 4, 64}  |
        // | node[2] -- node[1]    | {5, 1}         | {64, 4}         |
        // | node[3] -- node[2]    | {5, 1}         | {32, 4}         |
        // *----------------------------------------------------------*
        pint Mmax = 4; // max AEXT repeater tree depth
        [M > Mmax -> 0=1;] // assert false
        pint M_idx = M-1;

        REPEATER_TREE_<M_idx, N, L, 0, 1> 
            _(g, p__cp, c__pp, p_ce, c_pe, p__c, c__p);
    }

    export
    template <pint N>
    defproc TOP_INT (globals g;
                     bool _x_phi, y_phi;
                     bool x_enable, y_enable;
                     c1of<N> _x_data, y_data) {
        // interface at the top of the AEXT tree (including repeater tree)
        // converts between active low and high senses

        prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
            ~_x_phi<9> -> y_phi+
            _x_phi<6> -> y_phi-

            (: n : N :
                ~_x_data.d[n]<9> -> y_data.d[n]+
                _x_data.d[n]<6> -> y_data.d[n]-
            )
        }
        x_enable = y_enable;
    }
} // namespace transmitter

export
template <pint M, N, NN>
defproc AEXT (globals g; bool xp[NN], xa[NN], pe, _pp; c1of<N> _p) {
    // Transmitter transmits spikes from neurons to datapath
    // M depth of AEXT tree (max 6)
    // N radix of AEXT tree
    // NN neurons = N^M

    pint N_LEAF = NN/N; // = N^(M-1)
    pint N_NODE = (NN-N) / (N*(N-1)); // = (N^(M-1)-1) / (N-1)

    transmitter::NRN_BUF<NN> buf(g, xp, xa,,);

    transmitter::LEAF<N> leaf[N_LEAF];
    (; n : N_LEAF :
        leaf[n].g = g;
        leaf[n]._cp = buf._yp[n*N..(n+1)*N-1];
        leaf[n].ca = buf.ya[n*N..(n+1)*N-1];
    )

    [ M = 1 ->
        NN = N; // assert
        leaf[0]._pp = _pp;
        leaf[0].pe  = pe;
        leaf[0]._p  = _p;
    [] M > 1 ->

        [ M = 2 ->
            pint N_LINK = 1;
            pint M_REP = M-1;
        [] M > 2 ->
            pint N_LINK = N_NODE/N;
            pint M_REP = M-2;
        ]

        transmitter::REPEATER_TREE<M_REP, N, N_LINK> repeaters(
            g,,,,,,);

        repeaters.p__cp[0] = _pp;
        repeaters.p_ce[0]  = pe;
        repeaters.p__c[0]  = _p;

        transmitter::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        node[0]._pp = repeaters.c__pp[0];
        node[0].pe = repeaters.c_pe[0];
        node[0]._p = repeaters.c__p[0];

        // connect level 0 NODEs to LEAFs
        pint N_L0_NODE = N_LEAF/N; // lvl 0 NODEs
        pint NODE_L0_BASE_IDX = N_NODE-N_L0_NODE;
        (; node_idx : NODE_L0_BASE_IDX..N_NODE-1 :
            (; n : N :
                node[node_idx]._cp[n] = leaf[(node_idx-NODE_L0_BASE_IDX)*N+n]._pp;
                node[node_idx].ce[n] = leaf[(node_idx-NODE_L0_BASE_IDX)*N+n].pe;
                node[node_idx]._c[n] = leaf[(node_idx-NODE_L0_BASE_IDX)*N+n]._p;
            )
        )

        // connect level 1 NODEs to level 0 NODEs
        [ M > 2 ->
            pint N_L1_NODE = N_L0_NODE/N; // lvl 1 NODEs
            pint NODE_L1_BASE_IDX = N_NODE-N_L1_NODE -N_L0_NODE;
            (; node_idx : NODE_L1_BASE_IDX..NODE_L0_BASE_IDX-1 :
                (; n : N :
                    node[node_idx]._cp[n] = node[node_idx*N+n+1]._pp;
                    node[node_idx].ce[n] = node[node_idx*N+n+1].pe;
                    node[node_idx]._c[n] = node[node_idx*N+n+1]._p;
                )
            )
        ]

        // connect NODEs to NODEs
        [ M > 2 ->
            (; np : NODE_L1_BASE_IDX :
                (; nc : N :
                    node[np]._cp[nc] = repeaters.p__cp[np*N+nc+1];
                    node[np].ce[nc] = repeaters.p_ce[np*N+nc+1];
                    node[np]._c[nc] = repeaters.p__c[np*N+nc+1];

                    repeaters.c__pp[np*N+nc+1] = node[np*N+nc+1]._pp;
                    repeaters.c_pe[np*N+nc+1] = node[np*N+nc+1].pe;
                    repeaters.c__p[np*N+nc+1] =  node[np*N+nc+1]._p;
                )
            )
        ]
    ]
}

export
template <pint M, p4M>
defproc AEXT_TO_TILE (globals g;
                      bool _cp[p4M/16], ce[p4M/16]; c1of<4> _c[p4M/16];
                      bool pe, _pp; c1of<4> _p) {
    // AEXT tree above the TILE (in logic space)
    // contains all but the lowest level intermediate NODEs
    // M tree levels (require M>=2)
    // p4M = 4^M neurons
    [ M < 2 ->
        0=1; // assert false
    ]
    pint N = 4; // required for TILE
    // TILE contains the AEXT LEAFs and the lowest level AEXT NODEs

    // These are the number of nodes logically above the TILE
    pint N_NODE_INT = (p4M/N/N/N-1) / (N-1);
    pint N_NODE_LEAF = p4M/N/N/N;
    pint N_NODE = N_NODE_INT + N_NODE_LEAF;

    [ M = 2 ->
        pint N_LINK = 1;
        pint M_REP = M-1;
    [] M > 2 ->
        pint N_LINK = N_NODE;
        pint M_REP = M-2;
    ]

    transmitter::REPEATER_TREE<M_REP, N, N_LINK> repeaters(g,,,,,,);

    repeaters.p__cp[0] = _pp;
    repeaters.p_ce[0] = pe;
    repeaters.p__c[0] = _p;

    [ M = 2 ->
        p4M = 4*N; // assert
        _cp[0] = repeaters.c__pp[0];
        ce[0] = repeaters.c_pe[0];
        _c[0] = repeaters.c__p[0];
    [] M > 2 ->
        transmitter::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        node[0].pe = repeaters.c_pe[0];
        node[0]._pp = repeaters.c__pp[0];
        node[0]._p = repeaters.c__p[0];

        // connect NODEs to child ports
        pint N_LOW_NODE = p4M/N/N/N; // NODEs connecting to LEAFs
        pint NODE_BASE_IDX = N_NODE-N_LOW_NODE;
        (; node_idx : NODE_BASE_IDX..N_NODE-1 :
            (; n : N :
                node[node_idx].ce[n] = ce[(node_idx-NODE_BASE_IDX)*N+n];
                node[node_idx]._cp[n] = _cp[(node_idx-NODE_BASE_IDX)*N+n];
                node[node_idx]._c[n] = _c[(node_idx-NODE_BASE_IDX)*N+n];
            )
        )

        // connect NODEs to NODEs
        [ M > 2 ->
            (; np : NODE_BASE_IDX :
                (; nc : N :
                    node[np].ce[nc] = repeaters.p_ce[np*N+nc+1];
                    node[np]._cp[nc] = repeaters.p__cp[np*N+nc+1];
                    node[np]._c[nc] = repeaters.p__c[np*N+nc+1];

                    repeaters.c_pe[np*N+nc+1] = node[np*N+nc+1].pe;
                    repeaters.c__pp[np*N+nc+1] = node[np*N+nc+1]._pp;
                    repeaters.c__p[np*N+nc+1] =  node[np*N+nc+1]._p;
                )
            )
        ]
    ]
}

namespace brain_transmitter {
    export
    template <pint M, N>
    defproc AEXT_INT (globals g;
                      bool aext__pp, aext_pe; c1of<N> aext__p;
                      eMx1ofN<M, N> y_spk) {
        // interface between transmitter and the datapath
        // M tree levels 
        // N radix of tree (N^M neurons)
        ::aer::transmitter::TOP_INT<N>
            top_int(g, aext__pp,, aext_pe,, aext__p,);
        ::aer::interface::OUT_a1ofN<N>
            out(g, top_int.y_phi, top_int.y_enable, top_int.y_data,);
        ::aer::interface::DESERIAL_RING<M, N, false, true>
            deserial(g, out.y, y_spk,);
    }
} // namespace brain_transmitter

} // namespace aer
