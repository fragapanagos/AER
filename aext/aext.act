// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/lib/arbiter.act";

namespace aer {

namespace transmitter {
    export
    template <pint N; pbool root>
    defproc NODE (globals g; bool _cp[N], co[N], pi, _pp; c1of<N> _c[N], _p) {
        // AEXT tree NODE
        bool c_[N], _co[N], v, _v, _u[N];
        c1of<N> p;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c_);

        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v & (| : n : N : c_[n]) -> _pp-
                ~g._pReset | (| : n : N : ~_co[n] & ~c_[n]) -> _pp+

                (: n : N :
                    c_[n] & pi & _v -> _u[n]-
                    ~g._pReset | ~_v -> _u[n]+
                )

                ~pi & (| : n : N : ~_u[n]) -> v+
                _pp & (& : n : N : _co[n]) -> v-

                v => _v-

                c_[0] & v & pi & (& : n : 1..N-1 : _co[n]) -> _co[0]-
                (: n : 1..N-2:
                    c_[n] & v & pi & 
                        (& : nn : 0..n-1 : _co[nn]) & 
                        (& : nn : n+1..N-1 : _co[nn]) -> _co[n]-
                )
                c_[N-1] & v & pi & (& : n : 0..N-2 : _co[n]) -> _co[N-1]-
                (: n : N :
                    ~pi -> _co[n]+

                    _co[n] => co[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]) | ~_u[n] => p.d[n]+
                )
            }

            [ ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        p.d[n] => _p.d[n]-
                    )
                }
            [] root ->
                p = _p;
            ]
        [] LAYOUT ->
            bool __pp, _pp_;
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                _v<15> & (| : n : N : c_[n]<15>) -> _pp_-
                ~g._pReset<9> | (| : n : N : ~_co[n]<24> & ~c_[n]<24>) -> _pp_+

                ~_pp_<12> -> __pp+
                _pp_<9> -> __pp-

                ~__pp<12> -> _pp+
                __pp<9> -> _pp-

                (: n : N :
                    c_[n]<18> & pi<18> & _v<18> -> _u[n]-
                    ~g._pReset<9> | ~_v<16> -> _u[n]+
                )

                ~pi<20> & (| : n : N : ~_u[n]<20>) -> v+
                _pp_<18> & (& : n : N : _co[n]<18>) -> v-

                ~v<15> -> _v+
                v<9> -> _v-

                (& : n : 1..N-1 : _co[n]<18>) &
                    v<18> & c_[0]<18> & pi<18> -> _co[0]-
                (: n : 1..N-2:
                    (& : nn : 0..n-1 : _co[nn]<18>) & 
                        (& : nn : n+1..N-1 : _co[nn]<18>) &
                        v<18> & c_[n]<18> & pi<18> -> _co[n]-
                )
                (& : n : 0..N-2 : _co[n]<18>) &
                    v<18> & c_[N-1]<18> & pi<18> -> _co[N-1]-
                (: n : N :
                    ~pi<18> -> _co[n]+

                    ~_co[n]<24> -> co[n]+
                    _co[n]<18> -> co[n]-
                )

                (: n : N :
                    (| : nc : N : ~_c[nc].d[n]<12>) | ~_u[n]<12> -> p.d[n]+
                    (& : nc : N : _c[nc].d[n]<18>) & _u[n]<18> -> p.d[n]-
                )
            }

            [ ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        ~p.d[n]<12> -> _p.d[n]+
                        p.d[n]<9> -> _p.d[n]-
                    )
                }
            [] root ->
                p = _p;
            ]
        ]
    }

    export
    template <pint N; pbool root>
    defproc LEAF (globals g; bool _cp[N], co[N], pi, _pp; c1of<N> p) {
        // AEXT tree LEAF
        bool c[N], _c[N], __c[N], _u[N], v, _v, __v, pp;
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c);
        c1of<N> p_;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                v => _v-
                _v => __v-

                (: n : N :
                    c[n] => _c[n]-
                )

                (| : n : N : ~_c[n]) & ~__v -> pp+
                g.pReset | pi & __v -> pp-

                (: n : N :
                    _c[n] => __c[n]-
                )

                (: n : N :
                    __c[n] & pi & _v -> _u[n]-
                    ~__c[n] & ~pp & ~pi -> _u[n]+
                )

                (| : n : N : ~_u[n]) & ~pi -> v+
                (& : n : N : _u[n]) -> v-

                (: n : N :
                    ~_u[n] & ~_c[n] => p_.d[n]+
                )

                (: n : N :
                    ~_u[n] & ~_v => co[n]+
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                pp => _pp-
            }
            [ root ->
                p_ = p; // preserve sense
            [] ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        p_.d[n] => p.d[n]- // switch to active low
                    )
                }
            ]
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~v<14> -> _v+
                v<9> -> _v-

                ~_v<9> -> __v+
                _v<6> -> __v-

                (: n : N :
                    ~c[n]<10> -> _c[n]+
                    c[n]<6> -> _c[n]-
                )

                (| : n : N : ~_c[n]<27>) & ~__v<27> -> pp+
                g.pReset<6> | pi<12> & __v<12> -> pp-

                (: n: N :
                    ~_c[n]<9> -> __c[n]+
                    _c[n]<6> -> __c[n]-
                )

                (: n : N :
                    pi<18> & __c[n]<18> & _v<18> -> _u[n]-
                    ~pi<27> & ~__c[n]<27> & ~pp<27> -> _u[n]+
                )

                ~pi<18> & (| : n : N : ~_u[n]<18>) -> v+
                (& : n : N : _u[n]<18>) -> v-

                (: n : N :
                    ~_u[n]<15> & ~_c[n]<15> -> p_.d[n]+
                    _u[n]<6> | _c[n]<6> -> p_.d[n]-
                )

                (: n : N :
                    ~_u[n]<16> & ~_v<16> -> co[n]+
                    _u[n]<6> | _v<6> -> co[n]-
                )
            }
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                ~pp<9> -> _pp+
                pp<6> -> _pp-
            }
            [ root ->
                p_ = p; // preserve sense
            [] ~root ->
                prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                    (: n : N :
                        // switch to active low
                        ~p_.d[n]<9> -> p.d[n]+
                        p_.d[n]<6> -> p.d[n]-
                    )
                }
            ]
        ]
    }

    export
    template <pint D, R; pint Se[R], CAPe[R], Spd[R], CAPpd[R]>
    defproc AMP_WIRES (globals g; bool _cpp, cpi, _pcp, pco; c1of<D> cp, pc) {
        // model the amplifier and wire capacitances internal to the aext tree
        // D 1-of-D data
        // R repeater inverters
        // Se[R] scales size of repeater inverters (for enable pco->cpi)
        // CAPe[R] capacitive load along repeaters (units of min size inverter cap) (for enable pco->cpi)
        // Spd[R] scales size of repeater inverters (for phi _cpp->_pcp and data cp->pc)
        // CAPpd[R] capacitive load along repeaters (units of min size inverter cap) (for phi _cpp->_pcp and data cp->pc)
        // in production: D=4
        // .-------------------------------------------------------------------------------------------------.
        // |                 link  | R | Se             | CAPe            | Spd            | CAPpd           |
        // |-----------------------|---|----------------|-----------------|----------------|-----------------|
        // | root    -> array edge | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} | {5, 1, 5, 25}  | {64, 4, 4, 192} |
        // | node[0] -> root       | 4 | {3, 10, 6, 36} | {4, 64, 4, 192} | {5, 1, 5, 25}  | {64, 4, 4, 192} |
        // | node[1] -> node[0]    | 4 | {3, 10, 6, 36} | {4, 64, 4, 64}  | {5, 1, 5, 25}  | {64, 4, 4, 64}  |
        // | node[2] -> node[1]    | 2 | {3, 10}        | {4, 64}         | {5, 1}         | {64, 4}         |
        // | node[3] -> node[2]    | 2 | {3, 10}        | {4, 32}         | {5, 1}         | {32, 4}         |
        // | leaf    -> node[3]    | 2 | {3, 10}        | {4, 16}         | {5, 1}         | {16, 4}         |
        // ---------------------------------------------------------------------------------------------------
        // assume min_inv_cap=0.25
        preal min_inv_cap = 0.25;
        
        preal Ce[R];
        preal Cpd[R];
        (; r : R :
            Ce[r] = min_inv_cap * CAPe[r];
            Cpd[r] = min_inv_cap * CAPpd[r];
        )
        REPEATER_BOOL<R, Spd, Cpd> _pcp_cpp(g, _cpp, _pcp);
        REPEATER_BOOL<R, Se, Ce> _cpo_pci(g, pco, cpi);
        REPEATER_c1of<D, R, Spd, Cpd> pc_cp(g, cp, pc);
    }

    export
    template <pint M, N, NN; pbool root; pint M0, Rmax, m0;
              pint R[M0], Se[M0][Rmax], CAPe[M0][Rmax], Spd[M0][Rmax], CAPpd[M0][Rmax]>
    defproc AEXT_ (globals g; bool _xp[NN], xo[NN], pi, _pp; c1of<N> p) {
        // utility for AEXT
        bool w__cpp, w_cpi;
        bool w__pcp = _pp;
        bool w_pco = pi;
        c1of<N> w_pc = p; 
        c1of<N> w_cp;
        AMP_WIRES<N, R[m0], Se[m0][0..R[m0]-1], CAPe[m0][0..R[m0]-1], Spd[m0][0..R[m0]-1], CAPpd[m0][0..R[m0]-1]>
            w(g, w__cpp, w_cpi, w__pcp, w_pco, w_cp, w_pc);
        [ M = 1 ->
            NN = N;
            LEAF<N, root> leaf(g, _xp, xo, w_cpi, w__cpp, w_cp);
        [] M > 1 ->
            NODE<N, root> node(g,,, w_cpi, w__cpp,, w_cp);
            pint k = NN/N;
            AEXT_<M-1, N, k, false, M0, Rmax, m0+1, R, Se, CAPe, Spd, CAPpd> _[N];
            (; n : N :
                _[n].g = g;
                _[n]._xp = _xp[n*k..(n+1)*k-1];
                _[n].xo = xo[n*k..(n+1)*k-1];
                _[n].pi = node.co[n];
                _[n]._pp = node._cp[n];
                _[n].p = node._c[n];
            )
        ]
    }
} // namespace transmitter

export
template <pint M, N, NN>
defproc AEXT (globals g; bool _xp[NN], xo[NN], pi, pp; c1of<N> p) {
    // Transmitter transmits spikes from neurons to datapath
    // M tree levels (max 6)
    // N children per node
    // NN total neurons
    pint Mmax = 6; // max AEXT tree depth
    pint Rmax = 4; // max repeaters between AEXT nodes
    pint R[Mmax];
    pint Se[Mmax][Rmax], Spd[Mmax][Rmax];
    pint CAPe[Mmax][Rmax], CAPpd[Mmax][Rmax];
    // repeaters per stage
    R = {4, 4, 4, 2, 2, 2};
    // sizing per repeater per stage
    Se = {{3, 10, 6, 36},
          {3, 10, 6, 36},
          {3, 10, 6, 36},
          {3, 10, 0, 0 },
          {3, 10, 0, 0 },
          {3, 10, 0, 0 }};
    Spd = {{5, 1, 5, 25},
           {5, 1, 5, 25},
           {5, 1, 5, 25},
           {5, 1, 0, 0 },
           {5, 1, 0, 0 },
           {5, 1, 0, 0 }};
    // cap per repeater per stage
    CAPe = {{4, 64, 4, 192},
            {4, 64, 4, 192},
            {4, 64, 4, 64 },
            {4, 64, 0, 0  },
            {4, 32, 0, 0  },
            {4, 16, 0, 0  }};
    CAPpd = {{64, 4, 4, 192},
             {64, 4, 4, 192},
             {64, 4, 4, 64 },
             {64, 4, 0, 0  },
             {32, 4, 0, 0  },
             {16, 4, 0, 0  }};

    [M > Mmax -> 0=1;] // assert false
    pint ms = Mmax-M; // start idx

    transmitter::AEXT_<M, N, NN, true, M, Rmax, 0, R[ms..Mmax-1],
                       Se[ms..Mmax-1], CAPe[ms..Mmax-1],
                       Spd[ms..Mmax-1], CAPpd[ms..Mmax-1]>
        _(g, _xp, xo, pi,, p);
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        ~_._pp<9> -> pp+
        _._pp<6> -> pp-
    }
}

namespace brain_transmitter {
    export
    template <pint NN>
    defproc NRN_BUF (globals g; bool xp[NN], xo[NN], yi[NN], _yp[NN]) {
        // buffer the neuron spikes so that the refractory period does not
        // hold up the transmitter
        // NN neurons
        bool _xo[NN];
        bool __xo[NN];
        __xo = xo;
        [ ~LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: nn : NN :
                    xp[nn] & _xo[nn] => _yp[nn]-

                    yi[nn] -> _xo[nn]-
                    ~yi[nn] & ~xp[nn] -> _xo[nn]+

                    _xo[nn] => __xo[nn]-
                )
            }
        [] LAYOUT ->
            prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
                (: nn : NN :
                    xp[nn]<12> & _xo[nn]<12> -> _yp[nn]-
                    ~xp[nn]<9> | ~_xo[nn]<9> -> _yp[nn]+

                    yi[nn]<6> -> _xo[nn]-
                    ~yi[nn]<18> & ~xp[nn]<18> -> _xo[nn]+

                    ~_xo[nn]<9> -> __xo[nn]+
                    _xo[nn]<6> -> __xo[nn]-
                )
            }
        ]
    }
} // namespace brain_transmitter

export
template <pint M, N, NN>
defproc BRAIN_AEXT (globals g; bool xp[NN], xo[NN], pi, pp; c1of<N> p) {
    // braindrop / brainstorm transmitter system
    // M tree depth
    //     M = 6 in production
    // N node fanout
    //     N = 4 in production
    // NN neurons
    //     NN = 4^M
    //     NN = 4096 in production
    AEXT<M, N, NN> _(g,,, pi, pp, p);
    brain_transmitter::NRN_BUF<NN> buf(g, xp, xo, _.xo, _._xp);
}

} // namespace aer
