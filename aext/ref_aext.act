// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/lib/arbiter.act";

namespace aer {

namespace transmitter {
    export
    template <pint N>
    defproc NODE (globals g; bool cp[N], co[N], pi, pp; c1of<N> c[N], p) {
        // AEXT tree NODE
        bool _cp[N], c_[N], u[N], v;
        prs<g.Vdd, g.GND> {
            (: n : N :
                cp[n] => _cp[n]-
            )
        }
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c_);

        prs<g.Vdd, g.GND> {
            ~v & (| : n : N : c_[n]) -> pp+
            g.pReset | (| : n : N : co[n] & ~c_[n]) -> pp-
        
            (: n : N :
                c_[n] & pi & ~v -> u[n]+
                g.pReset | v -> u[n]-
            )

            (| : n : N : u[n]) & ~pi -> v+
            (& : n : N : ~co[n]) & ~pp -> v-
            
            c_[0] & v & pi & (& : n : 1..N-1 : ~co[n]) -> co[0]+
            (: n : 1..N-2:
                c_[n] & v & pi & 
                (& : nn : 0..n-1 : ~co[nn]) & 
                (& : nn : n+1..N-1 : ~co[nn]) -> co[n]+
            )
            c_[N-1] & v & pi & (& : n : 0..N-2 : ~co[n]) -> co[N-1]+
            (: n : N :
                ~pi -> co[n]-
            )

            (: n : N :
                (| : nc : N : c[nc].d[n]) | u[n] => p.d[n]+
            )
        }
    }

    export
    template <pint N>
    defproc LEAF (globals g; bool cp[N], co[N], pi, pp; c1of<N> p) {
        // AEXT tree LEAF
        bool _cp[N], c[N], u[N], v;
        prs<g.Vdd, g.GND> {
            (: n : N :
                cp[n] => _cp[n]-
            )
        }
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c);

        prs<g.Vdd, g.GND> {
            (| : n : N : c[n]) & ~v -> pp+
            g.pReset | pi & v -> pp-

            (: n : N :
                c[n] & pi & ~v -> u[n]+
                ~c[n] & ~pp & ~pi -> u[n]-
            )

            (| : n : N : u[n]) & ~pi -> v+
            (& : n : N : ~u[n]) -> v-
        
            (: n : N :
                u[n] & c[n] => p.d[n]+
            )
            
            (: n : N :
                u[n] & v => co[n]+
            )
        }
    }
} // namespace transmitter

export
template <pint M, N, NN>
defproc AEXT (globals g; bool xp[NN], xo[NN], pi, pp; c1of<N> p) {
    // M depth of AEXT tree
    // N radix of AEXT tree
    // NN neurons = N^M
    pint N_LEAF = NN/N; // = N^(M-1)
    pint N_NODE = (NN-N) / (N*(N-1)); // = (N^(M-1)-1) / (N-1)
    // N_LEAF + N_NODE = (N^M-1) / (N-1)
    transmitter::LEAF<N> leaf[N_LEAF];

    (; n : N_LEAF :
        leaf[n].g = g;
        leaf[n].cp = xp[n*N..(n+1)*N-1];
        leaf[n].co = xo[n*N..(n+1)*N-1];
    )

    [ M = 1 ->
        NN = N; // assert
        leaf[0].pi = pi;
        leaf[0].pp = pp;
        leaf[0].p = p;
    [] M > 1 ->
        transmitter::NODE<N> node[N_NODE];
        (; n : N_NODE :
            node[n].g = g;
        )
        node[0].pi = pi;
        node[0].pp = pp;
        node[0].p = p;

        // connect NODEs to LEAFs
        pint N_LOW_NODE = N_LEAF/N; // NODEs connecting to LEAFs
        pint NODE_BASE_IDX = N_NODE-N_LOW_NODE;
        (; node_idx : NODE_BASE_IDX..N_NODE-1 :
            (; n : N :
                node[node_idx].co[n] = leaf[(node_idx-NODE_BASE_IDX)*N+n].pi;
                node[node_idx].cp[n] = leaf[(node_idx-NODE_BASE_IDX)*N+n].pp;
                node[node_idx].c[n] = leaf[(node_idx-NODE_BASE_IDX)*N+n].p;
            )
        )

        [ M > 2 ->
            (; np : NODE_BASE_IDX :
                (; nc : N :
                    node[np].cp[nc] = node[np*N+nc+1].pp;
                    node[np].co[nc] = node[np*N+nc+1].pi;
                    node[np].c[nc] =  node[np*N+nc+1].p;
                )
            )
        ]
    ]
}

namespace brain_transmitter {
    export
    template <pint NN>
    defproc NRN_BUF (globals g; bool xp[NN], xo[NN], yi[NN], yp[NN]) {
        // buffer the neuron spikes so that the refractory period does not
        // hold up the transmitter
        // NN neurons
        prs<g.Vdd, g.GND> {
            (: nn : NN :
                xp[nn] & ~xo[nn] => yp[nn]+

                yi[nn] -> xo[nn]+
                ~yi[nn] & ~xp[nn] -> xo[nn]-
            )
        }
    }
} // namespace brain_transmitter

export
template <pint M, N, NN>
defproc BRAIN_AEXT (globals g; bool xp[NN], xo[NN], pi, pp; c1of<N> p) {
    // braindrop / brainstorm transmitter system
    // M tree depth
    //     M = 6 in production
    // N node fanout
    //     N = 4 in production
    // NN neurons
    //     NN = 4^M
    //     NN = 4096 in production
    AEXT<M, N, NN> _(g,,, pi, pp, p);
    brain_transmitter::NRN_BUF<NN> buf(g, xp, xo, _.xo, _.xp);
}

} // namespace aer
