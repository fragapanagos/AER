// This file defines a tree transmitter and receiver.
// The data traverses the tree with a serialized packet format.
import "aer/lib/arbiter.act";

namespace aer {

namespace transmitter {
    export
    template <pint N>
    defproc NODE (globals g; bool cp[N], co[N], pi, pp; c1of<N> c[N], p) {
        // AEXT tree NODE
        bool _cp[N], c_[N], u[N], v;
        prs<g.Vdd, g.GND> {
            (: n : N :
                cp[n] => _cp[n]-
            )
        }
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c_);

        prs<g.Vdd, g.GND> {
            ~v & (| : n : N : c_[n]) -> pp+
            g.pReset | (| : n : N : co[n] & ~c_[n]) -> pp-
        
            (: n : N :
                c_[n] & pi & ~v -> u[n]+
                g.pReset | v -> u[n]-
            )

            (| : n : N : u[n]) & ~pi -> v+
            (& : n : N : ~co[n]) & ~pp -> v-
            
            c_[0] & v & pi & (& : n : 1..N-1 : ~co[n]) -> co[0]+
            (: n : 1..N-2:
                c_[n] & v & pi & 
                (& : nn : 0..n-1 : ~co[nn]) & 
                (& : nn : n+1..N-1 : ~co[nn]) -> co[n]+
            )
            c_[N-1] & v & pi & (& : n : 0..N-2 : ~co[n]) -> co[N-1]+
            (: n : N :
                ~pi -> co[n]-
            )

            (: n : N :
                (| : nc : N : c[nc].d[n]) | u[n] => p.d[n]+
            )
        }
    }

    export
    template <pint N>
    defproc LEAF (globals g; bool cp[N], co[N], pi, pp; c1of<N> p) {
        // AEXT tree LEAF
        bool _cp[N], c[N], u[N], v;
        prs<g.Vdd, g.GND> {
            (: n : N :
                cp[n] => _cp[n]-
            )
        }
        ::aer::arbiter::N_ARB_S<N> arb(g, _cp, c);

        prs<g.Vdd, g.GND> {
            (| : n : N : c[n]) & ~v -> pp+
            g.pReset | pi & v -> pp-

            (: n : N :
                c[n] & pi & ~v -> u[n]+
                ~c[n] & ~pp & ~pi -> u[n]-
            )

            (| : n : N : u[n]) & ~pi -> v+
            (& : n : N : ~u[n]) -> v-
        
            (: n : N :
                u[n] & c[n] => p.d[n]+
            )
            
            (: n : N :
                u[n] & v => co[n]+
            )
        }
    }
} // namespace transmitter

export
template <pint M, N, NN>
defproc AEXT (globals g; bool xp[NN], xo[NN], pi, pp; c1of<N> p) {
    // utility for AEXT
    [ M = 1 ->
        NN = N;
        transmitter::LEAF<N> leaf(g, xp, xo, pi, pp, p);
    [] M > 1 ->
        pint k = NN/N;
        AEXT<M-1, N, k> _[N];
        (; n : N :
            _[n].g = g;
            _[n].xp = xp[n*k..(n+1)*k-1];
            _[n].xo = xo[n*k..(n+1)*k-1];
        )

        transmitter::NODE<N> node(g,,, pi, pp,, p);
        (; n : N :
            node.cp[n] = _[n].pp;
            node.co[n] = _[n].pi;
            node.c[n] = _[n].p;
        )
    ]
}

namespace brain_transmitter {
    export
    template <pint NN>
    defproc NRN_BUF (globals g; bool xp[NN], xo[NN], yi[NN], yp[NN]) {
        // buffer the neuron spikes so that the refractory period does not
        // hold up the transmitter
        // NN neurons
        prs<g.Vdd, g.GND> {
            (: nn : NN :
                xp[nn] & ~xo[nn] => yp[nn]+

                yi[nn] -> xo[nn]+
                ~yi[nn] & ~xp[nn] -> xo[nn]-
            )
        }
    }
} // namespace brain_transmitter

export
template <pint M, N, NN>
defproc BRAIN_AEXT (globals g; bool xp[NN], xo[NN], pi, pp; c1of<N> p) {
    // braindrop / brainstorm transmitter system
    // M tree depth
    //     M = 6 in production
    // N node fanout
    //     N = 4 in production
    // NN neurons
    //     NN = 4^M
    //     NN = 4096 in production
    AEXT<M, N, NN> _(g,,, pi, pp, p);
    brain_transmitter::NRN_BUF<NN> buf(g, xp, xo, _.xo, _.xp);
}

} // namespace aer
