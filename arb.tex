\documentclass[aer.tex]{subfiles}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$n$-way Arbiter ($N\!\_ARB$)}

The $n$-way arbiter $N\_ARB$ arbitrates between $n$ children (see Figure~\ref{fig:n_arb}) and is specified by

\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{img/transmitter/n_arb.pdf}
  \caption{$N\!\_ARB$ arbitrates between $n$ children.}
  \label{fig:n_arb}
\end{figure}

\begin{csp}
N_ARB(n)\equiv
  *[[\langle\|i:0..n\-1:#{C`i}->C`i;C`i\rangle]]
\end{csp}

\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{img/transmitter/n_arb_h_arb.pdf}
  \caption{$N\!\_ARB$ decomposed as a binary tree of $H\!\_ARB$ cells. Here is an $N\!\_ARB$ instance servicing 4 children. The $P$ port of the top $H\!\_ARB$ cell is connected back to itself.}
  \label{fig:n_arb_h_arb}
\end{figure}

In words, the children send requests at any time. When requests arrive, $N\!\_ARB$ selects one requesting child to proceed. The first $C_i$ communication indicates that the child should proceed, and the second $C_i$ communication confirms that the child has finished.

We decompose $N\!\_ARB$ into a binary tree of heirarchical arbiter cells, $H\!\_ARB$ (see Figure~\ref{fig:n_arb_h_arb}). 

\begin{csp}
N_ARB(n)\equiv*[\langle\pll\,i:0..n\-1:H_ARB\rangle]
\end{csp}

\noindent For an $N\!\_ARB$ instance $n\_arb$ and $n-1$ $H\_ARB$ instances $h\_arb[0]..h\_arb[n-1]$, we connect the $n\_arb$ ports to the $h\_arb$ ports as follows.

\begin{csp}
\langle\,i:0..n\-1:
  [i\%2=0 -> 
    n_arb.C`i\Leftrightarrow\!h_arb[i/2].C`0
  []i\%2=1 ->
    n_arb.C`i\Leftrightarrow\!h_arb[i/2].C`1
  ]\rangle
\end{csp}

\noindent We arrange the $h\_arb$ instances as a binary tree.

\begin{csp}
\langle\,i:0..n\-2:
  [i\%2=0 -> 
    h_arb[i].P\Leftrightarrow\!h_arb[(n\+i)/2].C`0
  []i\%2=1 ->
    h_arb[i].P\Leftrightarrow\!h_arb[(n\+i)/2].C`1
  ]\rangle

h_arb[n\-1].P \Leftrightarrow\! h_arb[n\-1].P
\end{csp}

\noindent The top $h\_arb$'s $P$ port is connected back to itself.

\subsection{Heirarchical arbiter $H\_ARB$}

$H\!\_ARB$ coordinates with its parent (another $H\!\_ARB$ instance) and arbitrates between two children. 
With ports

\begin{tabular}[]{rl}
$C1$ & child 1 port \\
$C2$ & child 2 port \\
$P$ & parent port \\
\end{tabular} \\

\noindent $H\!\_ARB$ is specified by

\begin{csp}
H_ARB\equiv
  *[[#{C`1}|#{C`2}->P;
    [#{C`1}->C`1;C`1\|~#{C`1}->skip];
    [#{C`2}->C`2;C`2\|~#{C`2}->skip];P]]
\end{csp}

When a child request arrives, $H\!\_ARB$ sends a request to its parent. When the parent gives permission to go ahead, $H\!\_ARB$ checks the first child and then the second child. During each check, $H\!\_ARB$ services the child if its request is present. Otherwise, $H\!\_ARB$ skips and moves on. After checking the children, $H\!\_ARB$ releases its parent.

$H\!\_ARB$ implements a greedy yet fair arbitration algorithm. $H\!\_ARB$ is greedy because it can service both children for a single request to the parent. $H\!\_ARB$ is fair because it will service each child at most once for each request to the parent. 

\begin{figure}
  \centering
  \includegraphics[width=.5\textwidth]{img/transmitter/arb_h_detail.pdf}
  \caption{$H\_ARB$ decomposition. Dotted line indicates wire used for probing only.}
  \label{fig:h_arb_detail}
\end{figure}

We decompose $H\!\_ARB$ into a control cell $CTRL$ and two child arbitration cells $C\_ARB$ as in Figure~\ref{fig:h_arb_detail}.

\begin{csp}
H\_ARB\equiv*[CTRL\pll\!C_ARB\pll\!C_ARB]
\end{csp}

\begin{figure}
  \centering
  \includegraphics[width=.7\textwidth]{img/transmitter/H_ARB_bubble_reshuffled.pdf}
  \caption{$H\!\_ARB$ after bubble reshuffling. Ports are expanded and inverters introduced by bubble reshuffling are shown.}
  \label{fig:h_arb_bubbled}
\end{figure}

\noindent Bubble reshuffling $CTRL$ and $C\_ARB$ yields the $H\!\_ARB$ shown in Figure~\ref{fig:h_arb_bubbled}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Control cell $CTRL$}
$CTRL$ sequences communications with the parent of $H\!\_ARB$ and the child arbiters.
$CTRL$ has ports

\begin{tabular}[]{rl}
$P$ & parent port \\
$S_1$ & child arbiter 1 port \\
$S_2$ & child arbiter 2 port \\
\end{tabular} \\

\paragraph{CHP} 

\begin{csp}
CTRL\equiv
  *[[#{C`1}|#{C`2}->P;S`1;S`1;S`2;S`2;P]
\end{csp}

\noindent where 

\begin{tabular}[]{rl}
  $C_1$ & probes child 1 \\
  $C_2$ & probes child 2 \\
  $P$ & communicates with the parent \\
  $S_1$ & communicates with the child 1 arbiter \\
  $S_2$ & communicates with the child 2 arbiter \\
\end{tabular} \\ \\

\paragraph{HSE} 

Directly translating the CHP,

\begin{hse}
CTRL\equiv
  *[[c1i|c2i];po+;[pi];
    s1o+;[s1i];[~s1i];s1o-;
    s2o+;[s2i];[~s2i];s2o-;
    po-;[~pi]]
\end{hse}

\noindent There are 3 indistinguishable states--after $[p_i]$, after $s1_o\!\downarrow$, and after $s2_o\!\downarrow$. The correct operation of $CTRL$ precludes reshuffling to break symmetry, so we use 2 state variables to distinguish betwen the 3 states.

\begin{hse}
CTRL\equiv
  *[[c1i|c2i];po+;[pi];x-;
    s1o+;[s1i];y-;s1o-;[~s1i];
    s2o+;[s2i];x+;s2o-;[~s2i];
    po-;[~pi];y+]
\end{hse}

\paragraph{PRS}

\begin{prs2}
(c1i | c2i) & y -> po+
~s2i & x & ~y -> po-

~x & y -> s1o+
x | ~y -> s1o-

~s1i & ~x & ~y -> s2o+
x -> s2o-

s2i & ~y -> x+
pi & y -> x-

~pi -> y+
s1i -> y-
\end{prs2}

\noindent after bubble reshuffling

\begin{prs2}
(~_c1i | ~_c2i) & ~_y -> po+
_s2i & x & _y -> po-

~x & ~_y -> s1o+
x | _y -> s1o-

~s1i & ~x & ~y -> s2o+
x -> s2o-

~_s2i & ~y -> x+
pi & y -> x-

~pi -> y+
s1i -> y-
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Child Arbiter ($C\!\_ARB$)}
$C\!\_ARB$ determines whether or not a child's request is present when called upon by $CTRL$.

\paragraph{CHP}

\begin{csp}
C_ARB\equiv
  *[[#C->S;C;C;S
    \|#S->S;S]]
\end{csp}

\noindent where 

\begin{tabular}[]{rl}
  $C$ & communicates with the child \\ 
  $S$ & communicates with $CTRL$ \\
\end{tabular} \\ \\

We arbitrate between requests from the child, $\overline{C}$, and 
requests from $CTRL$, $\overline{S}$. If there a child request is present, the arbiter is biased towards selecting the child because $S$ requests will not arrive until $CTRL$ has obtained permission from the parent. Although small, there is a chance that a child's request will be skipped on a given iteration of $CTRL$, but the weakly fair assumption ensures that the child will be serviced eventually.

\noindent If the arbitration selects the child request $\overline{C}$, 

\begin{tabular}[]{rl}
  $S$ & wait for and acknowledge $CTRL$'s request \\
  $C$ & signal the child to proceed \\
  $C$ & wait for the child to complete \\
  $S$ & release $CTRL$ so it can move on \\
\end{tabular} \\ \\

\noindent If the arbitration selects $CTRL$'s request $\overline{S}$,

\begin{tabular}[]{rl}
  $S$ & wait for and acknowledge $CTRL$'s request \\
  $S$ & release $CTRL$ so it can move on \\
\end{tabular} \\ \\

\noindent which is a simple 4-phase handshake. Note that $S$ is shared between the two branches.

\paragraph{HSE}

Directly translating the CHP,

\begin{hse}
*[[ci->[si];so+;co+;[~ci];co-;[~si];so-
  \|si->so+;[~si];so-]]
\end{hse}

The states before the $[\neg\,s_i]$ waits in the $\overline{C}$ and $\overline{S}$ branches are indistinguishable. Instead of using a state variable to store which branch we're traversing, we move $[\neg\,s_i]$ forward in the $\overline{C}$ branch. 

\begin{hse}
*[[ci->[si];so+;[~si];co+;[~ci];co-;so-
  \|si->so+;[~si];so-]]
\end{hse}

\noindent or in CHP,

\begin{csp}
ARB_C\equiv
*[[#C->S;S\star(C;C)
  \|#S->S;S]]
\end{csp}

\noindent After $co\!\downarrow$, the child could raise its request again ($c_i$) and greedily hold the circuit in a loop servicing the child. 
We break this loop by releasing $CTRL$ ($s_o\!\downarrow$) before releasing the child. This yields

\begin{hse}
*[[ci->[si];so+;[~si];co+;[~ci];so-;co-
  \|si->so+;[~si];so-]]
\end{hse}

\noindent It's not possible to express this in CHP exactly, but an approximation would be

\begin{csp}
ARB_C\equiv
*[[#C->S;S\star\!C\star\!C
  \|#S->S;S]]
\end{csp}

\noindent Next, we use intermediate variables $\hat{c_i}$ and $\hat{s_i}$ to represent the arbitration.

\begin{hse}
*[[ci->\hat{ci}+;[\hat{ci}];[si];so+;[~si];co+;[~ci];\hat{ci}-;[~\hat{ci}];so-;co-
  \|si->\hat{si}+;[\hat{si}];so+;[~si];\hat{si}-;[~\hat{si}];so-]]
\end{hse}

\noindent and break the arbitration out into a separate process,

\begin{hse}
*[[ci->\hat{ci}+;[~ci];\hat{ci}-
  \|si->\hat{si}+;[~si];\hat{si}-]]\pll
*[[\hat{ci}->[si];so+;[~si];co+;[~\hat{ci}];so-;co-
  []\hat{si}->so+;[~\hat{si}];so-]]
\end{hse}

\noindent Note that the $\hat{c_i}$ branch of the select statement uses $s_i$ and not $\hat{s_i}$. Putting $[\neg\!s_i]$ before $c_o\!\uparrow$ ensures that the arbitration will not traverse the $s_i$ before the child has completed as indicated by $[\neg\,\hat{c_i}]$. 
Note also that $s_o$ is shared between both branches of selection statement and 
that there are again indistinguishable states between the branches---before $[s_i]$ in the $\overline{C}$ branch and after $[\neg\,\hat{s_i}]$ in the $\overline{S}$ branch.
To distinguish the branches, we introduce intermediate values $cs_o$ and $ss_o$ and merge them in a third concurrent process.

\begin{hse}
*[[ci->\hat{ci}+;[~ci];\hat{ci}-
  \|si->\hat{si}+;[~si];\hat{si}-]]\pll
*[[\hat{ci}->[si];cso+;[~si];co+;[~\hat{ci}];cso-;co-
  []\hat{si}->sso+;[~\hat{si}];sso-]]\pll
*[[cso->so+;[~cso];so-]
  []sso->so+;[~sso];so-]
\end{hse}

\paragraph{PRS}

$s_i$ and $c_i$ are inputs to a standard 2-input arbiter, which outputs $\hat{s_i}$ and $\hat{c_i}$.

\begin{prs2}
\hat{ci} & si & ~sso -> cso+
~\hat{ci} -> cso-

~si & cso -> co+
si | ~cso -> co-

\hat{si} & ~co -> sso+
~\hat{si} | co -> sso-

cso | sso -> so+
~cso & ~sso -> so-
\end{prs2}

\noindent after bubble reshuffling

\begin{prs2}
~_\hat{ci} & ~_si & ~sso -> cso+
_\hat{ci} -> cso-

_si & cso -> _co-
~_si | ~cso -> _co+

~_\hat{si} & ~co -> sso+
_\hat{si} | co -> sso-

cso | sso -> _so-
~cso & ~sso -> _so+
\end{prs2}

\noindent where $\_\hat{s_i}$ and $\_\hat{c_i}$ come from an active-low 2-input arbiter with inputs $\_s_i$ and $\_c_i$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
