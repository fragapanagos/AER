// contains a modified version of the brainstorm config memory definition
// assumes aer repository positioned as submodule within brainstorm repository
// i.e. as brainstorm/act/aer
import "aer/lib/channel.act";
import "aer/lib/comm.act";
import "lib/channel.act";
import "mem/interface.act";
import "mem/decoder.act";
import "mem/bank.act";
import "mem/config_bank.act";

namespace aer {

template <pint M>
defproc flip_word_order (globals g; eMx1of4<M> x, y) {
    //flips the word order from x to y
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {} // HACK to appease netgen -b
    x.e = y.e;
    (; m : M :
        x.m[m] = y.m[M-1-m];
    )
}

template <pint M_1of4, M_1of2>
defproc word_1of4_to_1of2 (globals g; c1of4 _x[M_1of4]; c1of2 y[M_1of2]) {
    // converts word from Mx1of4 to Mx1of2
    M_1of2 = (M_1of4*2); // assert
    prs<g.Vdd, g.GND> {
        (: m4 : M_1of4 :
            ~_x[m4].d[0]<9> | ~_x[m4].d[2]<9> -> y[m4*2].d[0]+
            _x[m4].d[0]<12> & _x[m4].d[2]<12> -> y[m4*2].d[0]-

            ~_x[m4].d[1]<9> | ~_x[m4].d[3]<9> -> y[m4*2].d[1]+
            _x[m4].d[1]<12> & _x[m4].d[3]<12> -> y[m4*2].d[1]-

            ~_x[m4].d[0]<9> | ~_x[m4].d[1]<9> -> y[m4*2+1].d[0]+
            _x[m4].d[0]<12> & _x[m4].d[1]<12> -> y[m4*2+1].d[0]-

            ~_x[m4].d[2]<9> | ~_x[m4].d[3]<9> -> y[m4*2+1].d[1]+
            _x[m4].d[2]<12> & _x[m4].d[3]<12> -> y[m4*2+1].d[1]-
        )
    }
}

defproc addr_vn (globals g; c1of4 _addr; bool vn) {
    // checks validity/neutrality of address data. only checks last word
    pint D = 4;
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        (& : d : D : _addr.d[d]<12>) -> vn-
        (| : d : D : ~_addr.d[d]<9>) -> vn+
    }
}


template <pint in_1of4, rows, cols, word_size>
defproc config_sram_decoder (globals g; c1of4 _input[in_1of4]; dualrail _write[word_size]; bool _col_select[cols], row_select[rows]) {
    // Converts in_1of4 input words into write data, row, column select lines
    // Only supports hardcoded in_1of4, rows, cols, word_size
    in_1of4 = 4; // assert
    rows = 8; // assert
    cols = 16; // assert
    word_size = 1; // assert
    pint D2 = 2;
    pint D4 = 4;

    // convert middle word to 1of2 representation
    c1of2 w3[2];
    c1of2 _w3[2];
    word_1of4_to_1of2<1, 2> decode_wr(g, {_input[3]}, w3);

    _write[0].d = _w3[1].d;
    bool col_select[cols];
 
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        (: m : 2 :
            (: d : 2 :
                ~w3[m].d[d] -> _w3[m].d[d]+
                w3[m].d[d] -> _w3[m].d[d]-
            )
        )

        // we assume sufficient latency in the receiver for the bitcell to be written
        (: d : D4 :
            (: dd : D4 :
                [after=0] ~_input[1].d[dd] & ~_input[2].d[d] -> col_select[4*d+dd]+
                [after=0] _input[1].d[dd] | _input[2].d[d] -> col_select[4*d+dd]-

            )
        )
        (: n : D4*D4 :
            [after=0] ~col_select[n]<9> -> _col_select[n]+
            [after=0] col_select[n]<6> -> _col_select[n]-
        )

        // we assume sufficient latency in the receiver for the bitcell to be written
        (: d : D4 :
            (: dd : D2 :
                [after=0] ~_input[0].d[d] & ~_w3[0].d[dd] -> row_select[4*dd+d]+
                [after=0] _input[0].d[d] | _w3[0].d[dd] -> row_select[4*dd+d]-
            )
        )
    }

}

export
template <pint aerv_words, word_size, cols, rows>
defproc config_sram_interface (globals g; eMx1of4<aerv_words> _aerv_data; dualrail _write[word_size]; bool _col_select[cols], row_select[rows]) {
    // interface between parallel deserial output and sram
    // aerv_data words arrive in order 3,2,1,0
    // ------------------------------
    //           aerv_data
    // write/row   row        col
    // ------------------------------
    //   [3]  |    [0]       [1,2]    
    // ------------------------------ 
    //    |         |          |       
    //    v         v          v      
    // 1in4to2-->rdecode    cdecode
    //    |         |          |     
    //    v         v          v
    // ------------------------------
    // write   row_select  col_select
    //            sram
    // ------------------------------
    aerv_words = 4; // assert
    word_size = 1; // assert
    cols = 16; // assert
    rows = 8; //assert
    config_sram_decoder<aerv_words, rows, cols, word_size> decoder(g, _aerv_data.m, _write, _col_select, row_select);

    addr_vn vn(g, _aerv_data.m[0],); 
    prs<g.Vdd, g.GND | g.vpsub, g.vnsub> {
        ~vn.vn -> _aerv_data.e+
        vn.vn -> _aerv_data.e-
    }
}

} // namespace aer

namespace mem {

/*
                                  col_select
                          C0      C1      C2     C3  
                          |       |       |       |
   write =================&=======&=======&=======& 
                         | |     | |     | |     | |  
                     ____v v_____v_v_____v_v_____v_v__ 
                    | W0[f,t] W1[f,t] W2[t,f] W3[t,f] |
           r R0---->|S0                               |
           o        |                                 |
           w        |                                 |
           | R1---->|S1                               |
           s    .   |                                 |
           e    .   |              bank               |
           l    .   |                                 |
           e R14--->|S14                              |
           c        |                                 |
           t        |                                 |
             R15--->|S15                              |
                    |_________________________________|

Notes:

*/
export template <pint rows, cols, word_size>
defproc config_sramNxM_addr_decoded(globals g; dualrail _write[word_size]; bool _col_select[cols], row_select[rows]; dualrail _q[rows][cols][word_size])
{
    config_arrayNxM<rows, cols, word_size> array(g.Vdd, g.GND, g.sReset, g.pReset, g._sReset, g._pReset,,,);

	/****************** write, col_select => array._bl **********************/
	dualrail __write[cols][word_size];
    // we assume sufficient latency in the receiver for the bitcell to be written
	(;i:cols:
		(;j:word_size:
			prs <g.Vdd, g.GND | g.vpsub, g.vnsub>
			{
				[after=0] ~_write[j].f<12> & ~_col_select[i]<12> -> __write[i][j].f+
				[after=0] _write[j].f<6> | _col_select[i]<6> -> __write[i][j].f-
				[after=0] ~_write[j].t<12> & ~_col_select[i]<12> -> __write[i][j].t+
				[after=0] _write[j].t<6> | _col_select[i]<6> -> __write[i][j].t-

				[after=0] __write[i][j].f<6> -> array._bl[i][j][0]-
				[after=0] ~__write[i][j].f<9> -> array._bl[i][j][0]+
				[after=0] __write[i][j].t<6> -> array._bl[i][j][1]-
				[after=0] ~__write[i][j].t<9> -> array._bl[i][j][1]+
			}
		)
	)

	/************************ row_select => array.wl *************************/
    row_select = array.wl;

	/**************************** _q => array._q *****************************/
	(;i:rows:
		(;j:cols:
			(;k:word_size:
				_q[i][j][k].d = array._q[i][j][k];
			)
		)
	)
}

} // mem
