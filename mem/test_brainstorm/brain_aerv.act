// tests that brain aerv works without deadlock, instability, or interference
// while both spikes and memory packets are being delivered randomly
import "aer/aerv/aerv.act";
import "aer/lib/test.act";
import "aer/lib/compat_bs.act";
import "mem/memory.act";

pint M     = 3;
pint Mp4   = 64; // 4**M
pint M_SPK = M+1;
pint M_MEM = M+4;
pint N_SYN = Mp4;
pint N_MEM = N_SYN/4;
pint D     = 4;

aer::globals g_aer;
aer::globals g = g_aer;
globals g_bs;
compat_bs::globals g_compat(g_aer, g_bs);

aer::SOURCE_BRAIN_AERV<M_SPK, M_SPK-M, 0, 2> spk_src(g,);
aer::SOURCE_BRAIN_AERV<M_MEM, M_MEM-M, 2, 1> mem_src(g,);
aer::SYNAPSE spk_snk[N_SYN];

aer::eMx1of4_to_eMx1of2<4, 8> con_4to2[N_MEM];
pint log2_rows = 4;
pint log2_cols = 2;
pint rows = 16;
pint cols = 4;
pint word_size = 2;
pint write_delay = 0;
pint precharge_delay = 0;
pint pn = 2;
pint width = 10;
mem::config_sramNxM<log2_rows, rows, log2_cols, cols, word_size, write_delay, precharge_delay, pn, width> sram[N_MEM];
bool write_b[N_MEM][4];
bool addr[N_MEM][12];
(; n : N_MEM :
    con_4to2[n].g = g;
    sram[n].g = g_bs;
    con_4to2[n].y.e = sram[n].write.e;
    write_b[n] = con_4to2[n].y.m[0].d # con_4to2[n].y.m[1].d;
    write_b[n] = sram[n].write.b[0].d # sram[n].write.b[1].d;
    addr[n] = con_4to2[n].y.m[2].d # con_4to2[n].y.m[3].d # con_4to2[n].y.m[4].d # con_4to2[n].y.m[5].d # con_4to2[n].y.m[6].d # con_4to2[n].y.m[7].d;
    addr[n] = sram[n].addr[0].d # sram[n].addr[1].d # sram[n].addr[2].d # sram[n].addr[3].d # sram[n].addr[4].d # sram[n].addr[5].d;
)

aer::a1of2 y_syn[N_SYN];
(; n : N_SYN :
    spk_snk[n].g = g;
    spk_snk[n].spk = y_syn[n];
)

aer::eMx1of4<M_MEM-M> y_mem[N_MEM];
(; n : N_MEM :
    y_mem[n] = con_4to2[n].x;
)

aer::BRAIN_AERV<M, Mp4, M_SPK, M_MEM, N_SYN, N_MEM> aerv(
    g, spk_src.d, mem_src.d, y_syn, y_mem);
