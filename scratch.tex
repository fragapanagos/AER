\documentclass{article}
\usepackage{mystyle}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{arbiter $CTRL$ with passive $S$ ports}

\subsection{CHP}

\begin{csp}
CTRL\approx
  *[[#{C1}|#{C2}->P;S1;S1\star(S2;S2\star\!P)]
  
C_S\equiv
  *[S1;S2;S2;S1]
\end{csp}

\subsection{HSE}

\begin{hse}
CTRL\equiv
  *[[c1i|c2i];po+;[pi];
    [s1i];s1o+;[~s1i];
    [s2i];s2o+;[~s2i];
    po-;[~pi];s1o-;s2o-]
\end{hse}

\begin{hse}
C_S\equiv
  *[s1o+;[s1i];s2o+;[s2i];s2i-;[~s2i];s1o-;[~s1i]]
\end{hse}

needs a state variable

\begin{hse}
C_S\equiv
  *[x+;s1o+;[s1i];s2o+;[s2i];x-;s2o-;[~s2i];s1o-;[~s1i]]
\end{hse}

\subsection{PRS}

$CTRL\equiv$
\begin{prs2}
c1i | c2i -> po+
~s2i & s2o -> po-

pi & s1i -> s1o+
~pi -> s1o-

~s1i & s1o & s2i -> s2o+
~pi & ~s1o -> s2o-
\end{prs2}

$C\_S\equiv$
\begin{prs2}
x -> s1o+
~s2i & ~x -> s1o-

s1i & x -> s2o+
~x -> s2o-

~s1i & ~s2i -> x+
s1i & s2i -> x-
\end{prs2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{arbiter $CTRL$ with active $S$ ports}

\subsection{CHP} 

\begin{csp}
CTRL\equiv
  *[[#{C1}|#{C2}->P;S1;S1;S2;S2;P]
\end{csp}

\subsection{HSE}

\begin{hse}
CTRL\equiv
  *[[c1i|c2i];po+;[pi];
    s1o+;[s1i];[~s1i];s1o-;
    s2o+;[s2i];[~s2i];s2o-;
    po-;[~pi]]
\end{hse}

needs 2 state variables:

\begin{hse}
CTRL\equiv
  *[[c1i|c2i];po+;[pi];x+;
    s1o+;[s1i];y+;s1o-;[~s1i];
    s2o+;[s2i];x-;s2o-;[~s2i];
    po-;[~pi];y-]
\end{hse}


\subsection{PRS}

\begin{prs2}
c1i | c2i -> po+
~s2i & ~x & y -> po-

x & ~y -> s1o+
y -> s1o-

~s1i & x & y -> s2o+
s2i & ~x -> s2o-

pi & ~y -> x+
s2i & y -> x-

s1i & x -> y+
~pi & ~x -> y-
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{post arbiter}

\includegraphics[width=\textwidth]{img/transmitter/arb.pdf}

\noindent CHP:

\begin{csp}
CTRL\equiv
  *[[#{C1}|#{C2}->P;S1;S1\star(S2;S2\star\!P)]]
\end{csp}
\begin{csp}
C_S\equiv
  *[(SB,SG)\star\!S;(SB,SG)\star\!S]
\end{csp}
\begin{csp}  
C_GATE\equiv
  *[C\star(A,S);C\star(A,S)]
\end{csp}
\begin{csp}
C_BYPASS\equiv
  *[S;A;S,A]
\end{csp}
\begin{csp}
C_ARB\equiv
  *[[#{A1}->A1;A1\|#{A2}->A2;A2]]
\end{csp}

\noindent HSE:

\begin{hse}
CTRL\equiv
  *[[c1i|c2i];po+;[pi];
    [s1i];s1o+;[~s1i];
    [s2i];s2o+;[~s2i];
    po-;[~pi];s1o-,s2o-]
\end{hse}
\begin{hse}
C_S\equiv
  *[[sgi|sbi];so+;[si];sgo+,sbo+;
    [~sgi&~sbi];so-;[~si];sgo-,sbo-]
\end{hse}
\begin{hse}
C_GATE\equiv    
  *[[ci];ao+,so+;[ai&si];co+;
    [~ci];ao-,so-;[~ai&~si];co-]
\end{hse}
\begin{hse}
C_BYPASS\equiv
  *[so+;[si];ao+;[ai];
    so-,ao-;[~si&~ai]]
\end{hse}
\begin{hse}
C_ARB\equiv
  *[[a1i];a1o+;[~a1i];a1o-
   \|[a2i];a2o+;[~a2i];a2o-]
\end{hse}

\noindent PRS

$CTRL\equiv$
\begin{prs2}
c1i | c2i -> po+
~s2i & s2o -> po-

pi & s1i -> s1o+
pi & ~s1i & s1o & s2i -> s2o+
~pi -> s1o-, s2o-
\end{prs2}

$C\_S\equiv$
\begin{prs}
sgi | sbi -> so+
~sgi & ~sbi -> so-

si -> sgo+, sbo+
~si -> sgo-, sbo-
\end{prs}

$C\_GATE\equiv$
\begin{prs2}
c1i -> ao+, so+
~c1i -> ao-, so-

ai & si -> c1o+
~ai & ~si -> c1o-
\end{prs2}

$C\_BY\!P\!ASS\equiv$
\begin{prs2}
~si&~ai -> so+
si -> ao+
ai -> so-, ao-
\end{prs2}

$C\_ARB\equiv$
\begin{prs2}
a1i & _a2o -> _a1o-
~a1i | ~_a2o -> _a1o+

~_a1o & _a2o -> a1o+
_a1o -> a1o-

a2i & _a1o -> _a2o-
~a2i | ~_a1o -> _a2o+

~_a2o & _a1o -> a2o+
_a2o -> a2o-
\end{prs2}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\section{A Better Arbiter (failed. on hold)}

Starting with

\begin{csp}
ARB2\equiv*
  *[[#{L1}->R;L1;L1;R
    \|#{L2}->R;L2;L2;R]]
\end{csp}

we split out the arbitration into a separate process.

\begin{csp}
ARB2\equiv
*[[#{L1}->A1;R;L1;L1;R;A1]] \pll
*[[#{L2}->A2;R;L2;L2;R;A2]] \pll
*[[#{A1}->A1;A1\|#{A2}->A2;A2]]
\end{csp}

This arbiter is not greedy and returns the token to the parent after servicing a child.
To make it greedy yet fair, we split out communication with the parent arbiter cell into a separate process.

\begin{csp}
ARB2\equiv
  *[[#{L1}->A1;R1;L1;L1;A1;R1)]] \pll
  *[[#{L2}->A2;R2;L2;L2;A2;R2)]] \pll
  *[[#{A1}->A1;A1\|#{A2}->A2;A2]]\pll
  *[[#{R1}|#{R2}->R;
    [#{R1}->R1;R1\|~#{R1}->skip],
    [#{R2}->R2;R2\|~#{R2}->skip];
    R]]
\end{csp}

The parent communication process implements a greedy algorithm because once it acquires the token from the parent,
it will not return the token until both children have been serviced (if both have requested). 
The algorithm is fair because each child will only be serviced at most once for posession of the token.
The parent communication process can signal children processes in parallel because aribtration is handled by the arbitration process.
We use synchronizers (see section~\ref{subsec:sync}) enabled by the parent request to ensure that selection guards are mutually exclusive.


\begin{csp}
ARB2\equiv
  *[[#{L1}->A1;R1;L1;L1;A1;R1)]] \pll
  *[[#{L2}->A2;R2;L2;L2;A2;R2)]] \pll
  *[[#{A1}->A1;A1\|#{A2}->A2;A2]]\pll
  *[[#{R1}|#{R2}->R;
    [#{R1'}->R1;R1[]~#{R1'}->skip],
    [#{R2'}->R2;R2[]~#{R2'}->skip];
    R]]
\end{csp}
where probes on $R1$ and $R2$ have been replaced with probes on $R1'$ and $R2'$, respectively. 
These are synchronized versions of their respective signals.

Next, we make the 2-phase portions of each 4-phase communication explicit so we can pipeline them.
Since each communication is paired, it's straightforward to assign the first and second as the first and second
2-phase communications of a 4-phase protocol. 

\begin{csp}
ARB2\equiv
  *[[#{L1}->A1+;R1+;L1+;L1-;A1-;R1-]] \pll
  *[[#{L2}->A2+;R2+;L2+;L2-;A2-;R2-]] \pll
  *[[#{A1}->A1+;A1-\|#{A2}->A2+;A2-]]\pll
  *[[#{R1}|#{R2}->R+;
    [#{R1'}->R1+;R1-[]~#{R1'}->skip],
    [#{R2'}->R2+;R2-[]~#{R2'}->skip];
    R-]]
\end{csp}

We pipeline the arbitration and parent requests for speed.

\begin{csp}
ARB2\equiv
  *[[#{L1}->A1+,R1+;L1+;L1-\star(A1-,R1-)]] \pll
  *[[#{L2}->A2+,R2+;L2+;L2-\star(A2-,R2-)]] \pll
  *[[#{A1}->A1+;A1-\|#{A2}->A2+;A2-]]\pll
  *[[#{R1}|#{R2}->R+;
    [#{R1'}->R1+;R1-[]~#{R1'}->skip],
    [#{R2'}->R2+;R2-[]~#{R2'}->skip];
    R-]]
\end{csp}

or alternatively expressed with fewer guards as

\begin{csp}
ARB2\equiv
  *[L1+\star(A1+,R1+);L1-\star(A1-,R1-)] \pll
  *[L2+\star(A2+,R2+);L2-\star(A2-,R2-)] \pll
  *[[#{A1}->A1+;A1-\|#{A2}->A2+;A2-]]\pll
  *[[#{R1}|#{R2}];R+;
    [#{R1'}->R1+;R1-[]~#{R1'}->skip],
    [#{R2'}->R2+;R2-[]~#{R2'}->skip];
    R-]
\end{csp}

The HSE is given by

\begin{hse}
*[[l1i];a1o+,r1o+;[a1i&r1i];l1o+;
  [~l1i];a1o-,r1o-;[~a1i&~r1i];l1o-]
*[[l2i];a2o+,r2o+;[a2i&r2i];l2o+;
  [~l2i];a2o-,r2o-;[~a2i&~r2i];l2o-]
  
*[[a1o];a1i+;[~a1o];a1i-
 \|[a2o];a2i+;[~a2o];a2i-]
 
*[[r1o|r2o];ro+;[ri];
  [[r1o'];r1i+;[~r1o];r1i-[][_r1o']],
  [[r2o'];r2i+;[~r2o];r2i-[][_r2o']];
  ro-;[~ri]]
\end{hse}

The arbiter and synchronizer processes are standardized (see sections~\ref{subsec:arb} and~\ref{subsec:sync}), 
so we will omit their PRS here. First we develop the PRS for the children communication processes

\begin{prs2}
l1i->a1o+,r1o+
~l1i->a1o-,r1o-

a1i&r1i->l1o+
~a1i&~r1i->l1o-

l2i->a2o+,r2o+
~l2i->a2o-,r2o-

a2i&r2i->l2o+
~a2i&~r2i->l2o-
\end{prs2}

To make these CMOS implementable, we invert the senses of the $L1$ and $L2$ ports.

\begin{prs2}
~_l1i -> a1o+, r1o+
_l1i -> a1o-, r1o-

a1i & r1i -> _l1o-
~a1i & ~r1i -> _l1o+

~_l2i -> a2o+, r2o+
_l2i -> a2o-, r2o-

a2i & r2i -> _l2o-
~a2i & ~r2i -> _l2o+
\end{prs2}

Next we develop the PRS for the parent communication process

\begin{prs2}
~ri & (r1o | r2o) -> ro+
~r1o & ~r2o -> ro-

~ri & r1o' -> r1i+

~ri & r2o' -> r2i+

\end{prs2}

This is where things became really complicated and we abandoned this design.




\end{document}
