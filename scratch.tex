\documentclass[aer.tex]{subfiles}

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Essentially, we are converting from a 1-of-N code to an M-1-of-N code.

\subsection{CHP}
The transmitter is specified by

\begin{csp}
AEXT\equiv
  *[[\langle\|n:0..N\-1:#{C`n}->D!enc(C`n);D;C`n;C`n\rangle]]
\end{csp}

\noindent In words,

\begin{tabular}[]{rl}
  $\overline{C_n}$ & when the $i$th neuron spikes and is selected by the arbiter \\
  $D!enc(C_n)$ & compute and transmit the encoding of the neuron address \\
  $D$ & reset the data transmission lines \\
  $C_n$ & signal the neuron's reset \\
  $C_i$ & lower the neuron's reset \\
\end{tabular} \\

We split the transmitter into control and data (encoding) processes. 

\begin{csp}
CTRL\equiv*[[\langle\|n:0..N\-1:#{C`n}->S`n;S`n;C`n;C`n\rangle]]
\end{csp}

\begin{csp}
ENC\equiv*[S\star\!D!enc(S);S\star\!D]
\end{csp}

\noindent Control arbitrates between incoming neuron requests. The encoder computes and transmits the endoded neuron address. $S$ in $ENC$ is composed of all the $S_n$ in $CTRL$.

We further split the encoder into transmission and function blocks.

\begin{csp}
ENC_XMIT\equiv\langle\pll\,n:0..N\-1:*[S`n\star\!X`n;S`n\star\!X`n]\rangle
ENC_FBLK\equiv*[[valid(X)];D!enc(X);[neutral(X)];D]
\end{csp}

\noindent $X$ in $ENC\_FBLK$ is composed of all the $X_n$ in $ENC\_XMIT$, $valid(\cdot)$ computes validity, and $neutral(\cdot)$ computes neutrality.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{HSE}

First, $CTRL$,

\begin{hse}
CTRL\equiv
*[[\langle\|n:0..N\-1:cni->sno+;[sni];sno-;[~sni];cno+;[cni];cno-\rangle]]
\end{hse}

We introduce intermediate variables $cn$ to represent the arbitration.

\begin{hse}
CTRL\equiv
*[[\langle\|n:0..N\-1:cni->cn+;sno+;[sni];sno-;[~sni];cno+;[cni];cn-;cno-\rangle]]
\end{hse}

We break out the arbitration process.

\begin{hse}
CTRL\equiv
*[[\langle\|n:0..N\-1:cni->cn+;[~cni];cn-;\rangle]] \pll
\langle\pll\!n:0..N\-1:*[[cn];sno+;[sni];sno-;[~sni];cno+;[~cn];cno-]\rangle
\end{hse}

We introduce state variables $xn$ to eliminate indistinguishable states,

\begin{hse}
CTRL\equiv
*[[\langle\|n:0..N\-1:cni->cn+;[~cni];cn-;\rangle]] \pll
\langle\pll\!n:0..N\-1:*[[cn];sno+;[sni];xn+;sno-;[~sni];cno+;[~cn];xn-;cno-]\rangle
\end{hse}

Next, $ENC\_XMIT$,

\begin{hse}
ENC_XMIT\equiv
\langle\pll\!n:0..N\-1:*[[sni];xno+;[di];sno+;[~sni];xno-;[~di];sno-]\rangle
\end{hse}

Next, $ENC\_FBLK$,

\begin{hse}
ENC_FBLK\equiv
*[[\langle|n:0..N\-1:xni\rangle];
  [\langle[]n:0..N\-1:xni->D(enc(xni))\Uparrow\rangle];
  [\langle&n:0..N\-1:~xni\rangle];D\Downarrow]
\end{hse}

We split out the valid/neutral checks into a separate process to avoid long series chain of transistors.

\begin{hse}
ENC_FBLK\equiv
*[[\langle[]n:0..N\-1:vi&xni->D(enc(xni))\Uparrow\rangle];[~vi];D\Downarrow]

VN\equiv
*[[\langle|n:0..N\-1:xni\rangle];vo+;[\langle&n:0..N\-1:~xni\rangle];vo-]]
\end{hse}

\noindent Note that we still need the $v_i$ guard in the transmission. Otherwise, the up transition of the valid/neutral output would not be acknowledged.

In summary,

\begin{hse}
CTRL\equiv
*[[\langle\|n:0..N\-1:cni->cn+;[~cni];cn-;\rangle]] \pll
\langle\pll\!n:0..N\-1:*[[cn];sno+;[sni];xn+;sno-;[~sni];cno+;[~cn];xn-;cno-]\rangle
\end{hse}

\begin{hse}
ENC_XMIT\equiv
\langle\pll\!n:0..N\-1:*[[sni];xno+;[di];sno+;[~sni];xno-;[~di];sno-]\rangle
\end{hse}

\begin{hse}
ENC_FBLK\equiv
*[[\langle[]n:0..N\-1:vi&xni->D(enc(xn))\Uparrow\rangle];[~vi];D\Downarrow]

VN\equiv
*[[\langle|n:0..N\-1:sni\rangle];vo+;[\langle&n:0..N\-1:~sni\rangle];vo-]]
\end{hse}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PRS}

First, $CTRL$,

$cn_i$ is input to an arbiter and $cn$ is its output,

$CTRL\equiv$
\begin{prs2}
cn & ~xn -> sno+
~cn | xn -> sno-

sni -> xn+
~cn -> xn-

~sni & xn -> cno+
sni | ~xn -> cno-
\end{prs2}

Next, $ENC\_XMIT$,

$ENC\_XMIT_n\equiv$
\begin{prs2}
sni -> xno+
~sni -> xno-

xno & di -> sno+
~xno & ~di -> sno-
\end{prs2}

Next, $ENC\_FBLK$,

$ENC\_FBLK_{jk}\equiv$
\begin{prs2}
vi & enc^{\-1}(j,k) -> djk+

~vi -> djk-
\end{prs2}

$VN$ is a standard $OR$ tree since this is a 1-of-N code.

\pagebreak

\begin{csp}
STATE\equiv*[[\langle\|n:0..N\-1:#{C`n}->S`n;S`n;C`n;C`n\rangle]]
\end{csp}

\begin{csp}
ENC\equiv*[[S`n;D!enc(n);D;S`n]]
\end{csp}
Need blocks for arbitration, state, encoding and transmission.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{HSE}

\begin{hse}
ENC_XMIT\equiv
*[[c0i->c0+;[~c0i];c0-
  \|c1i->c1+;[~c1i];c1-
  \|c2i->c2+;[~c2i];c2-
  \|c3i->c3+;[~c3i];c3-
 ]]
 
*[[c0];s0o+;[di];x0+;s0o-;[~di];c0o+;[~c0];x0-;c0o-]
*[[c1];s1o+;[di];x1+;s1o-;[~di];c1o+;[~c1];x1-;c1o-]
*[[c2];s2o+;[di];x2+;s2o-;[~di];c2o+;[~c2];x2-;c2o-]
*[[c3];s3o+;[di];x3+;s3o-;[~di];c3o+;[~c3];x3-;c3o-]

ENC_FBLK\equiv
*[[vi&s0i->d00+,d10+[]vi&s1i->d01+,d10+[]vi&s2i->d00+,d11+[]vi&s3i->d01+,d11+];
  [~vi];d00-,d01-,d10-,d11-]

VN\equiv
*[[s0i|s1i|s2i|s3i];vo+;[~s0i&~s1i&~s2i&~s3i];vo-]]
\end{hse}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{PRS}

$ENC\_XMIT_n\equiv$
\begin{prs2}
cn&~xn->sno+
~cn|xn->sno-

cn&di->xn+
~cn->xn-

~di&xn->cno+
~xn->cno-
\end{prs2}

$ENC\_FBLK\equiv$
\begin{prs2}
vi & (s0i|s2i) -> d00+
vi & (s1i|s3i) -> d01+
vi & (s0i|s1i) -> d10+
vi & (s2i|s3i) -> d11+

~vi -> d00-
~vi -> d01-
~vi -> d10-
~vi -> d11-
\end{prs2}

$VN$ is a standard $OR$ tree.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{HSE}

\begin{hse}
STATE\equiv
*[[c0i->c0+;[~c0i];c0-
  \|c1i->c1+;[~c1i];c1-
  \|c2i->c2+;[~c2i];c2-
  \|c3i->c3+;[~c3i];c3-
 ]]

*[[c0->s0o+;[s0i];s0o-;[~s0i];c0o+;[~c0];c0o-
  []c1->s1o+;[s1i];s1o-;[~s1i];c1o+;[~c1];c1o-
  []c2->s2o+;[s2i];s2o-;[~s2i];c2o+;[~c2];c2o-
  []c3->s3o+;[s3i];s3o-;[~s3i];c3o+;[~c3];c3o-
 ]]
\end{hse}

\begin{hse}
ENC\equiv
*[[s0i|s1i|s2i|s3i];
  [s0i->d00+,d10+[]s1i->d01+,d10+[]s2i->d00+,d11+[]s3i->d01+,d11+];
  [~s0i&~s1i&~s2i&~s3i];d00-,d01-,d10-,d11-]
\end{hse}

\begin{hse}
RESET\equiv
*[[s0i&di->s0o+;[~s0i&~di];s0o-
  []s1i&di->s1o+;[~s1i&~di];s1o-
  []s2i&di->s2o+;[~s2i&~di];s2o-
  []s3i&di->s3o+;[~s3i&~di];s3o-
 ]]
\end{hse}

In $STATE$, we replace selection with concurrent execution. 

\begin{hse}
STATE\equiv
*[[c0];s0o+;[s0i];s0o-;[~s0i];c0o+;[~c0];c0o-]
*[[c1];s1o+;[s1i];s1o-;[~s1i];c1o+;[~c1];c1o-]
*[[c2];s2o+;[s2i];s2o-;[~s2i];c2o+;[~c2];c2o-]
*[[c3];s3o+;[s3i];s3o-;[~s3i];c3o+;[~c3];c3o-]
\end{hse}

\noindent The $S$ communication requires exclusion because it is used to raise and lower the data wires. Concurrent execution is valid because mutually exclusive access to the data wires is ensured by waiting for the data wires to clear as implied by $\neg sj_i$ before raising the the neuron reset signal, which then leads to the arbiter selecting another branch of $STATE$.

Next, we simplify $ENC$. The $sj_i$ validity check is superflous, and the neutrality check requires a transistor chain that grows linearly with the number of neurons. The validity check is unecessary because the $sj_i$ effectively implement a 1-of-N code, so the selection branch guards alone implement the validity check. To implement a scalable neutrality check, we add a valid/neutral detection circuit for the $sj_i$'s. Since $sj_i$ effectively implement a giant 1-of-N code, this turns out to be simply an OR gate, which can be distributed across a tree of OR gates.

\begin{hse}
ENC\equiv
*[[vi&s0i->d00+,d10+[]vi&s1i->d01+,d10+[]vi&s2i->d00+,d11+[]vi&s3i->d01+,d11+];
  [~vi];d00-,d01-,d10-,d11-]
\end{hse}

\begin{hse}
VN\equiv
*[[s0i|s1i|s2i|s3i];vo+;[~s0i&~s1i&~s2i&~s3i];vo-]]
\end{hse}

Note that even though the initial validity check worked, we needed to add $v_i$ to the transmission guards otherwise $VN$'s $v_o$'s upward transition would not be acknowledged.

Next, we simplify $RESET$. $STATE$ ensures the mutual exclusion of the reset branches, so we don't need to use selection.

\begin{hse}
RESET\equiv
*[[s0i&di];s0o+;[~s0i&~di];s0o-]
*[[s1i&di];s1o+;[~s1i&~di];s1o-]
*[[s2i&di];s2o+;[~s2i&~di];s2o-]
*[[s3i&di];s3o+;[~s3i&~di];s3o-]
\end{hse}

We should reall lump the encoding and reset circuits together

\begin{hse}
ENC\equiv
*[[vi&s0i->d00+,d10+[]vi&s1i->d01+,d10+[]vi&s2i->d00+,d11+[]vi&s3i->d01+,d11+];
  [~vi];d00-,d01-,d10-,d11-]

*[[s0i&di];s0o+;[~s0i&~di];s0o-]
*[[s1i&di];s1o+;[~s1i&~di];s1o-]
*[[s2i&di];s2o+;[~s2i&~di];s2o-]
*[[s3i&di];s3o+;[~s3i&~di];s3o-]
\end{hse}


To summarize,

\begin{hse}
ENC_XMIT\equiv
*[[c0i->c0+;[~c0i];c0-
  \|c1i->c1+;[~c1i];c1-
  \|c2i->c2+;[~c2i];c2-
  \|c3i->c3+;[~c3i];c3-
 ]]
 
*[[c0];s0o+;[di];x0+;s0o-;[~di];c0o+;[~c0];x0-;c0o-]
*[[c1];s1o+;[di];x1+;s1o-;[~di];c1o+;[~c1];x1-;c1o-]
*[[c2];s2o+;[di];x2+;s2o-;[~di];c2o+;[~c2];x2-;c2o-]
*[[c3];s3o+;[di];x3+;s3o-;[~di];c3o+;[~c3];x3-;c3o-]

ENC_FBLK\equiv
*[[vi&s0i->d00+,d10+[]vi&s1i->d01+,d10+[]vi&s2i->d00+,d11+[]vi&s3i->d01+,d11+];
  [~vi];d00-,d01-,d10-,d11-]

VN\equiv
*[[s0i|s1i|s2i|s3i];vo+;[~s0i&~s1i&~s2i&~s3i];vo-]]
\end{hse}


\end{document}
