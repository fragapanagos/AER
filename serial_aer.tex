\documentclass{article}
\usepackage{mystyle}

\begin{document}
\title{Serialized Tree AER}
\author{Sam Fok}
\maketitle

The neuron address packet is serialized as a series of 1-of-N words. 
We use an additional line (making the total data lines 1-of-(N+1)) to indicate the completion of a packet.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transmitter ($AEXT$)}

The transmitter is organized as a tree. Packets travel from the leaves of the tree to the root. At each node, incoming packet streams are merged into a single output stream. Each packet is prepended with a word indicating which branch it came from. To merge the streams, incoming packets from different branches are output one after the other. 

\begin{csp}
NODE\equiv
*[[h->
    [#{C0}->s:=0,P!(0);
    \|#{C1}->s:=1,P!(1)];
    h:=false
  []~h->
    [s=0->C0?x;P!x
    []s=1->C1?x;P!x
    ];h:=x.tail
 ]]
\end{csp}

We divide NODE into FWD and MERGE processes. 
FWD prepends a word to the packet indicating which branch the packet is coming from.
MERGE arbitrates between incoming packet streams and outputs them one at a time.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FWD version 1}

This version has fewer state variables than version 2, but the pull-up and pull-down chains are too long.

%%%%%%%%%%%%%%%
\subsubsection*{CHP}

\begin{csp}
FWD\equiv
  h:=true;
  *[[h&#{X}->Y!(\textrm{header});h-
    []~h&#{X}->Y!(X?)\*[X=t->h+];
    ]
   ]
\end{csp}

%%%%%%%%%%%%%%%
\subsubsection*{HSE}

\begin{hse}
h:=true;
*[h&(x0|x1|xt)->yn+;[yi];q+;yn-;[~yi];h-;q-
  []~h&x0->y0+;xo+;[yi];y0-;[~x0];xo-;[~yi]
  []~h&x1->y1+;xo+;[yi];y1-;[~x1];xo-;[~yi]
  []~h&xt->yt+;xo+;[yi];h+;yt-;[~xt];xo-;[~yi]
\end{hse}

%%%%%%%%%%%%%%%
\subsubsection*{PRS}

\begin{prs2}
h & yi & yn -> q+
~h -> q-

yt & xo & yi -> h+
q & ~yi -> h-
\end{prs2}

\begin{prs2}
~h & (y0 | y1 | yt) -> xo+
~x0 & ~x1 & ~xt & ~y0 & ~y1 & ~yt -> xo-
\end{prs2}

\begin{prs2}
h & ~q & ~yi & ~xo & (x0 | xi | xt) -> yn+
q -> yn-
\end{prs2}

\begin{prs2}
~h & ~q & ~yi & x0 & ~xo -> y0+
yi & xo -> y0-

~h & ~q & ~yi & x1 & ~xo -> y1+
yi & xo -> y1-
\end{prs2}

\begin{prs2}
~h & ~q & ~yi & xt & ~xo -> yt+
h & xo -> yt-
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{FWD version 2}

This version has more state variables than version 1, but has reasonable pull-up and pull-down chains.

%%%%%%%%%%%%%%%
\subsubsection*{CHP}

\begin{csp}
FWD\equiv
  *[[h&#{X}->Y!(\textrm{header});h-
    []~h&#{X}->X?u\*Y!u,[u=t->h+]
    ]
   ]
\end{csp}

%%%%%%%%%%%%%%%
\subsubsection*{HSE}

\begin{hse}
*[[h&(x0|x1|xt)->yn+;[yi];h-;yn-;[~yi]
  []~h&x0->u0+;(xo+;[~x0]),(y0+;[yi]);u0-;(y0-;[~yi]),xo-
  []~h&x1->u1+;(xo+;[~x1]),(y1+;[yi]);u1-;(y1-;[~yi]),xo-
  []~h&xt->ut+;(xo+;[~xt]),(yt+;h+;[yi]);ut-;(yt-;[~yi]),xo-
\end{hse}

\begin{hse}
*[[h&(x0|x1|xt)->yn+;[yi];h-;yn-;[~yi]
  []~h&x0->u0+;[~x0&yi];u0-;[~yi]
  []~h&x1->u1+;[~x1&yi];u1-;[~yi]
  []~h&xt->ut+;[~xt&h&yi];ut-;[~yi]

*[u0->xo+,y0+;[~u0];y0-,xo-
  []u1->xo+,y1+;[~u1];y1-,xo-
  []ut->xo+,(yt+;h+);[ut-];yt-,xo-
\end{hse}

%%%%%%%%%%%%%%%
\subsubsection*{PRS}

\begin{prs2}
yt -> h+
yn & yi -> h-
\end{prs2}

\begin{prs2}
h & (x0 | x1 | xt) & ~yi & ~yt -> yn+
~h & yi & ~un -> yn-
\end{prs2}

\begin{prs2}
u0 | u1 | ut -> xo+
~u0 & ~u1 & ~ut -> xo-
\end{prs2}

\begin{prs2}
~h & x0 & ~yi -> u0+
~x0 & yi -> u0-

~h & x1 & ~yi -> u1+
~x1 & yi -> u1-
\end{prs2}

\begin{prs2}
~h & xt & ~yi -> ut+
h & ~xt & yi -> ut-
\end{prs2}

\begin{prs2}
u0 -> y0+
~h & ~u0 -> y0-

u1 -> y1+
~h & ~u1 -> y1-
\end{prs2}

\begin{prs2}
ut -> yt+
~ut -> yt-
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Leaf interface LEAF\_INT}

LEAF\_INT interfaces with the neuron and outputs a tail word to get the party started.

%%%%%%%%%%%%%%%
\subsubsection*{CHP}
\begin{csp}
LEAF_INT\equiv
  *[C\star\!P!\textrm{tail};C\star\!P!\textrm{tail}]
\end{csp}

%%%%%%%%%%%%%%%
\subsubsection*{HSE}
\begin{hse}
*[[ci];{po}`t+;[pi]co+;
  [~ci];{po}`t-;[~pi];co-]
\end{hse}

%%%%%%%%%%%%%%%
\subsubsection*{PRS}
\begin{prs2}
ci -> {po}`t+
~ci -> {po}`t-

pi -> co+
~pi -> co-
\end{prs2}

\noindent These are just wires...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MERGE}

MERGE sequences between outputting two serialized packet streams.

\begin{csp}
MERGE\equiv
  *[[~l&~r->
      [#{L}->l:=true
      \|#{R}->r:=true
      ]
    []l|r->
      [l->O!(L?)
      []r->O!(R?)
    ]
  ]
\end{csp}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MERGE version 0}

I don't like this version because the pullup chains for the state variables
are too long and won't scale to higher radix encoding.

%%%%%%%%%%%%%%%
\subsubsection*{CHP}

\begin{csp}
MERGE\equiv
  *[[h->[#{C0}->a:=0\|#{C1}->a:=1];h-
    []~h&a=0->P!(C0?)
    []~h&a=0->P!(C1?)
    ]]
\end{csp}

%%%%%%%%%%%%%%%
\subsubsection*{HSE}

\begin{hse}
*[[~ao&~a1&(c00|c01|c0t)->a0+
  \|~a0&~a1&(c10|c11|c1t)->a1+]]

*[[ a0&c00->p0+;c0o+;[pi&~c00];p0-;c0o-;[~pi]
  []a0&c01->p1+;c0o+;[pi&~c01];p1-;c0o-;[~pi]
  []a0&c0t->pt+;c0o+;[pi&~c0t];a0-;pt-;c0o-;[~pi]
  []a1&c10->p0+;c1o+;[pi&~c10];p0-;c1o-;[~pi]
  []a1&c11->p1+;c1o+;[pi&~c11];p1-;c1o-;[~pi]
  []a1&c1t->pt+;c1o+;[pi&~c1t];a1-;pt-;c1o-;[~pi]
  ]]
\end{hse}
%%%%%%%%%%%%%%%
\subsubsection*{PRS}

\begin{prs2}
~a0 & (c00 | c01| c0t) & ~c0o -> a0i+
a0 -> a0i-

~a1 & (c10 | c11| c1t) & ~c1o -> a1i+
a1 -> a1i-

a0o & ~a1 & ~c1o & ~pi -> a0+ % uhoh will depend on other a's
~a0o & pi & pt & ~c0t -> a0-

a1o & ~a0 & ~c0o & ~pi -> a1+
~a1o & pi & pt & ~c1t -> a1-
\end{prs2}

\begin{prs2}
~pi & (a0 & c00 | a1 & c10) -> p0+
pi & (~_a0 & ~c00 | ~_a1 & ~c10) -> p0-

~pi & (a0 & c01 | a1 & c11) -> p1+
pi & (~_a0 & ~c01 | ~_a1 & ~c11) -> p1-

~pi & (a0 & c0t | a1 & c1t) -> pt+
_a0 & _a1 -> pt-
\end{prs2}

\begin{prs2}
a0 & (p0 | p1 | pt) -> c0o+
~p0 & ~p1 & ~pt -> c0o-

a1 & (p0 | p1 | pt) -> c1o+
~p0 & ~p1 & ~pt -> c1o-
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{MERGE version 1}

This one has acceptable pullup/pulldown chains, but I'm worried about making it CMOS implementable

%%%%%%%%%%%%%%%
\subsubsection*{HSE}

\begin{hse}
*[[~a0&(c00|c01|c0t)->a0+;h-;[~a0];h+
  \|~a1&(c10|c11|c1t)->a1+;h-;[~a1];h+]]

*[[ a0&c00->p0+;c0o+;[pi&~c00];p0-;c0o-;[~pi]
  []a0&c01->p1+;c0o+;[pi&~c01];p1-;c0o-;[~pi]
  []a0&c0t->pt+;c0o+;[pi&~c0t];a0-;pt-;c0o-;[~pi]
  []a1&c10->p0+;c1o+;[pi&~c10];p0-;c1o-;[~pi]
  []a1&c11->p1+;c1o+;[pi&~c11];p1-;c1o-;[~pi]
  []a1&c1t->pt+;c1o+;[pi&~c1t];a1-;pt-;c1o-;[~pi]
  ]]
\end{hse}

%%%%%%%%%%%%%%%
\subsubsection*{PRS}

\begin{prs2}
(c00 | c01| c0t) & ~a0 -> a0i+
~h & a0 -> a0i-

(c10 | c11| c1t) & ~a1-> a1i+
~h & a1 -> a1i-

h & a0o & ~pi -> a0+
pt & pi & c0o & ~c0t & ~a0o -> a0-

h & a1o & ~pi -> a1+
pt & pi & c1o & ~c1t & ~a1o -> a1-
\end{prs2}

\begin{prs2}
~a0 & ~a1 -> h+
a0 | a1 & ~c0o & ~c1o-> h-
\end{prs2}

\begin{prs2}
~pi & (a0 & c00 | a1 & c10) & ~h -> p0+
pi & (a0 & ~c00 | a1 & ~c10) -> p0-

~pi & (a0 & c01 | a1 & c11) & ~h -> p1+
pi & (a0 & ~c01 | a1 & ~c11) -> p1-

~pi & (a0 & c0t | a1 & c1t) & ~h -> pt+
~a0 & ~a1 -> pt-
\end{prs2}

\begin{prs2}
a0 & (p0 | p1 | pt) -> c0o+
~p0 & ~p1 & ~pt -> c0o-

a1 & (p0 | p1 | pt) -> c1o+
~p0 & ~p1 & ~pt -> c1o-
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Receiver ($AERV$)}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{version 0}

%%%%%%%%%%%%%%%
\subsubsection*{CHP}

\begin{csp}
AERV\equiv
  h:=true, s0=0, s1=0;
  *[
      [h->P?s;h-
      []~h&s=0->C0!(P?)\*[P=t->h+]
      []~h&s=1->C1!(P?)\*[P=t->h+]
      ] 
   ]
\end{csp}

%%%%%%%%%%%%%%%
\subsubsection*{CHP}

\begin{hse}
AERV\equiv
  h:=true;
  *[
      [h&pi0->s0+[]h&pi1->s1+];po+;[~pi0&~pi1];h-;po-
      []~h&s0&pit->c0ot+;po+;s0-;h+;[c0i];c0ot-;[~pit];po-;[~c0i]
      []~h&s1&pit->c1ot+;po+;s1-;h+;[c1i];c1ot-;[~pit];po-;[~c1i]
      ]
   ]
\end{hse}

%%%%%%%%%%%%%%%
\subsubsection*{PRS}

\begin{prs2}
h & pi0 -> s0+
c0ot & po -> s0-

h & pi1 -> s1+
c1ot & po -> s1-
\end{prs2}

\begin{prs2}
~so & c0ot | ~s1 & c1ot -> h+
(s0 | s1) & ~pi0 & ~pi1 -> h-
\end{prs2}

\begin{prs2}
(s0 | s1) & h | c0ot | c1ot -> po+
~h & ~pi0 & ~pi1 | ~c0ot & ~c1ot & ~pit -> po-
\end{prs2}

\begin{prs2}
~c0i & ~c1i & s0 & pit -> co0t+
c0i & h -> co0t-

~c0i & ~c1i & s1 & pit -> co1t+
c1i & h -> co1t-
\end{prs2}

% \begin{hse}
% AERV\equiv
%   h:=true;
%   *[
%       [h&pi0->s0+[]h&pi1->s1+];po+;[~pi0&~pi1];h-;po-
%       []~h&s0&pi0->c0o0+;po+;[~pi0];po-;[c0i];c0o0-;[~c0i]
%       []~h&s0&pi1->c0o1+;po+;[~pi1];po-;[c0i];c0o1-;[~c0i]
%       []~h&s0&pit->c0ot+;po+,s0-;h+;[~pit];po-;[c0i];c0ot-;[~c0i]
%       []~h&s1&pi0->c1o0+;po+;[~pi0];po-;[c1i];c1o0-;[~c1i]
%       []~h&s1&pi1->c1o1+;po+;[~pi1];po-;[c1i];c1o1-;[~c1i]
%       []~h&s1&pit->c1ot+;po+,s1-;h+;[~pit];po-;[c1i];c1ot-;[~c1i]
%       ]
%    ]
% \end{hse}

% \begin{hse}
% AERV\equiv
%   h:=true;
%   *[
%       [h&p0i->s0+,s1-[]h&p1i->s0-,s1+];h-
%       []~h->[s=0->C0!(P?)
%             []s=1->C1!(P?)]; 
%             [P=t->h+]
%       ]
%    ]
% \end{hse}

\begin{csp}
AERV\equiv
  h:=true;
  *[P?x;
    [h->
      s:=x;
    []~h->
      [s=0->C0!x
      []s=1->C1!x
      ]
    ];h:=x.tail
   ]
\end{csp}

We decompose $AERV$ into control and data processes.
Control
\begin{csp}
CTRL\equiv
  h:=true;
  *[R';
    [h->S'
    []~h->C'
    ]; h=x.tail
   ]
\end{csp}

\begin{hse}
CTRL\equiv
  *[[cri];cro+;[~cri];cro-;
      [h->cxo+;[cxi];cxo-;[~cxi]
      []~h->cco+;[cci];cco-;[~cci]];
    [xt->h+[]~xt->h-]
   ]
\end{hse}

Reading in
\begin{hse}
READ\equiv
  *[[{pi}`0|{pi}`1|{pi}`t];cro+;
      [cri&{pi}`0->x0+
      []cri&{pi}`1->x1+
      []cri&{pi}`t->xt+];
    po+;[~p0&~pi&~pt];cro-;[~cri];po-]
\end{hse}

Assigning X to S
\begin{hse}
AXS\equiv
  *[[csi];[x0->s0+[]x1->s1+];cso+;[~csi];cso-]
\end{hse}

Forwarding words to children
\begin{hse}
COUT\equiv
  *[[cci];
      [s0&x0->{c0o}`0+
      []s0&x1->{c0o}`1+
      []s0&xt->{c0o}`t+
      []s1&x0->{c1o}`0+
      []s1&x1->{c1o}`1+
      []s1&xt->{c1o}`t+
      ];
    [c0i|c1i];cco+;
    [~cci];c0o\!\Downarrow,c1o\!\Downarrow;
    [~c0i&~c1i];cco-]
    ]
\end{hse}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
