// tests the serial aer transmitter

/*CMOS implementable version-------------------------------------------------*/
import "serial_aer.act";
pint M=6;
pint N=4;
pint NN=4096; // NN=N^M

globals g;
bool Reset = g.sReset;

e1of<NN> src;
eMx1of4<M> snk;

aer::AEXT<M, N, NN> aext(g,,,,,);
aer::interface::OUT_a1ofN<N> out(g, aext.pp, aext.pi, aext.p,);
aer::interface::DESERIAL_RING<M, N> deserial(g, out.y,);
SINK_eMx1ofN<M, N> snk_(g, deserial.y);

prs<g.Vdd, g.GND> {
    (: nn : NN :
        src.d[nn] => aext._xp[nn]-
    )
    (| : nn : NN : aext.xo[nn]) => src.e-
}

deserial.y.e = snk.e;
(; m : M :
    deserial.y.m[m].d = snk.m[m].d;
)

/*reference version----------------------------------------------------------*/
// import "ref_serial_aer.act";
// pint M=6;
// pint N=4;
// pint NN=4096; // NN=N^M
// 
// globals g;
// bool Reset = g.sReset;
// 
// e1of<NN> src;
// eMx1of4<M> snk;
// 
// aer::AEXT<M, N, NN> aext(g, src.d,,,,);
// aer::interface::OUT_a1ofN<N> out(g, aext.pp, aext.pi, aext.p,);
// aer::interface::DESERIAL_RING<M, N> deserial(g, out.y,);
// SINK_eMx1ofN<M, N> snk_(g, deserial.y);
// 
// prs<g.Vdd, g.GND> {
//     (| : nn : NN : aext.xo[nn]) => src.e-
// }
// 
// deserial.y.e = snk.e;
// (; m : M :
//     deserial.y.m[m].d = snk.m[m].d;
// )
