\documentclass[aer.tex]{subfiles}
\begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\part{Building blocks}
Here we describe some of the basic building blocks.

\section{Arbiter ($ARB$)}
\label{subsec:arb}

The basic arbiter sequences between the possibly simultaneous requests of two clients.

\paragraph{CHP}

\begin{csp}
ARB\equiv*[[#{A`1}->A1;A1\|#{A`2}->A2;A2]]
\end{csp}

\noindent where

\begin{tabular}[]{rll}
  \code{A1} & (passive) & communicates with client 1 \\
  \code{A2} & (passive) & communicates with client 2 \\
\end{tabular} \\

\paragraph{HSE}

Directly translating the CHP,

\begin{hse}
  *[[a1i->a1o+;[~a1i];a1o-
    \|a2i->a2o+;[~a2i];a2o-]
\end{hse}

\noindent Introducing intermediate variables $a_1$ and $a_2$,

\begin{hse}
  *[[a1i->a1+;[a1];a1o+;[~a1i];a1-;[~a1];a1o-
    \|a2i->a2+;[a2];a2o+;[~a2i];a2-;[~a2];a2o-]
\end{hse}

\noindent Breaking out the arbitration from communication with the child,

\begin{hse}
  *[[a1i->a1+;[~a1i];a1-
    \|a2i->a2+;[~a2i];a2-]
  *[[a1->a1o+;[~a1];a1o-
    []a2->a2o+[~a2];a2o-]]
\end{hse}

\paragraph{PRS}

The arbitration process is implemented by 

\begin{prs2}
a1i&~a2->a1+
~a1i|a2->a1-

a2i&~a1->a2+
~a2i|a1->a2-
\end{prs2}

When $a1_i\land\neg\,a2_i$, the cell is stable at $a1\land\neg\,a2$.
When $\neg\,a1_i\land\,a2_i$, the cell is stable at $\neg\,a1\land\,a2$.
To see the arbitration mechanism, consider the case when $a1_i\land\,a2_i$ is true:

\begin{prs2}
~a2->a1+
a2->a1-

~a1->a2+
a1->a2-
\end{prs2}

\noindent which describes two cross-coupled inverters. 
When $a1_i\land\,a2_i$, circuit is bistable at either $a1\land\neg\,a2$ or $\neg\,a1\land\,a2$. 
Intermediate states are unstable. The time it takes to resolve the metastability follows an exponential distribution, so it's technically unbounded.

To be CMOS-implementable, we invert the senses of $a1$ and $a2$ to produce

\begin{prs2}
a1i&_a2->_a1-
~a1i|~_a2->_a1+

a2i&_a1->_a2-
~a2i|~_a1->_a2+
\end{prs2}

\noindent which describes two cross-coupled NAND gates.

We don't want output the cross-coupled NAND gates' outputs while they're in a metastable state,
so we use a filter circuit that passes on the outputs only when they've separated by at least 
the threshold voltage of a PMOS transistor. The client communication process is implemented by

\begin{prs2}
~_a1 & _a2 -> a1o+
_a1 -> a1o-

~_a2 & _a1 -> a2o+
_a2 -> a2o-
\end{prs2}

\subsubsection{Active Low Arbiter}

We can also arbitrate between active low signals. 
With inputs $\_a1_i$ and $\_a2_i$, intermediate variables $a1$ and $a2$, and outputs $\_a1_o$ and $\_a2_o$,
we now use cross-coupled NOR gates to arbitrate,

\begin{prs2}
_a1i|a2->a1-
~_a1i&~a2->a1+

_a2i|a1->a2-
~_a2i&~a1->a2+
\end{prs2}

\noindent and filter the outputs with

\begin{prs2}
a1 & ~a2 -> _a1o-
~a1 -> _a1o+

a2 & ~a1 -> _a2o-
~a2 -> _a2o+
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Synchronizer ($SYNC$)}
\label{subsec:sync}
When we cannot assume the stability of a signal $x$, we use the synchronizer to generate
a stable representation of $x$.

\begin{csp}
SYNC\equiv*[[#{Re}&#X->R;Re;R
          \|#{Re}&~#X->R;Re;R]]
\end{csp}

where

\begin{tabular}[c]{rl}
$Re$ & is the read-enable signal \\
$X$ & is the input signal \\
$R$ & is a stabilized representation of $X$ \\
\end{tabular}

In words, when $Re$ is activated, the synchronizer samples $X$ and outputs a stable representation of $X$.
However, as we'll see, this is not implementable because of the negated probe on $X$. 
An HSE of $SYNC$ is

\begin{hse}
sync\equiv*[[re&x->r.0+;[~re];r.0-
        \|re&~x->r.1+;[~re];r.1-]]
\end{hse}

$sync$ is not implementable because $x$ may change at any time.
each branch of the arbitration statement must do two things:
prevent the other branch from proceeding and raise the output. In the case that a branch
has blocked the other but before it has raised its output, the circuit could deadlock if $x$ changes value.
To fix this situation, we introduce stabilized intermediate variables $a.0$ and $a.1$ to
stabilize the selection of one of the two gaurds.

\begin{hse}
sync\equiv*[[re&x->a.0+;[a.0];r.0+;[~re];a.0-;[~a.0];r.0-
        \|re&~x->a.1+;[a.1];r.1+;[~re];a.1-;[~a.1];r.1-]]
\end{hse}

Next, we further decompose $sync$ into concurrent stabilization (aka integration) and arbitration processes.

\begin{hse}
sync\equiv*[[re&~x];a.0+;[~re];a.0-]]
     \pll*[[re&x];a.1+;[~re];a.1-]]
     \pll*[[a.0->r.0+;[~a.0&~a.1];r.0-
        \|a.1->r.1+;[~a.0&a.1];r.1-]]
\end{hse}

Arbitration now occurs between $a.0$ and $a.1$, which are stable signals as opposed to unstable $x$.
Unlike typical arbiter circuits, $sync$ will not execute both branches of its arbitration statement
if both $a.0$ and $a.1$ are true. Rather, $sync$ will only execute one of the branches before 
$a.0$ and $a.1$ are reset. The three processes are implemented by the PRS

\begin{prs2}
x->_x-
~x->_x+

~_re&~x->a.0+
_re->a.0-

~_re&~_x->a.1+
_re->a.1-

_r.1&a.0->_r.0-
~_r.1|(~a.0&~a.1)->_r.0+
_r.0&a.1->_r.1-
~r.0|(~a.0&~a.1)->_r.1+
\end{prs2}

A standard filter circuit composed of inverters with cross-coupled pMOS gates 
then filters the output signals to resolve metastability and output $r.0$ and $r.1$.

\end{document}
