\documentclass[aer.tex]{subfiles}
\begin{document}

\part{Transmitter}
The transmitter detects spike events and transmits
them out of the core (e.g. to a router or a receiver) in serialized AER
packets. Neurons are arranged in a 2D grid of rows (y address) and columns 
(x address). 
When a neuron spikes, it (and any other neuron in the same row) raises a 
request to the arbiter at the end of the rows. 
The row arbiter selects a row of neurons to transmit. The 
y address is then transmitted. Any neuron that spiked in the 
selected row then send their column addresses to the column latch and arbiter.
Their column addresses are latched to allow the neurons to reset while the 
column arbiter sequences the transmission of their x addresses. Once all of the
x addresses have been transmitted, the tail bit is transmitted to signal the 
end of the packet.

\section{Transmitter Decomposition}
Here we will start from a high level description of the transmitter and then decompose
the description into a set of concurrent, parallel processes. 
The highest level description of the address-event transmitter $AEXT$ is

\begin{csp}
AEXT(n)\equiv*[[\langle\|\,j:1..n:#{P`j}->A!enc(j)\pll\,P`j\rangle]]
\end{csp}
where 

\begin{tabular}[]{rl}
$n$ & is the number of neurons \\
$P_j$ & is the port communicating with the $j$th neuron \\
$A$ & is the output port \\
$enc(\cdot)$ & is a function returning the address of a neuron \\
\end{tabular} \\

In words, when the $j$th neuron spikes, output its address and reset the neuron. 
We rely on the "$\vert$" arbitration operator to handle multiple neurons spiking simultaneously.
We first expand $AEXT$ into rows and columns.

\begin{csp}
AEXT(x,y)\equiv*[[\langle\|\,l:1..y:\langle|k:1..x:#{P`{l\cdot\,k}}\rangle->A`1!enc(l)
               ,[\langle\|\,k:1..x:#{P`{l\cdot\,k}}->A`2!enc(k),P`{l\cdot\,k}\rangle]\rangle]]
\end{csp}
where 

\begin{tabular}[]{rl}
$x$ & is the number of columns \\
$y$ & is the number of rows \\
$P_{l\cdot k}$ & is the port communicating with the $l\cdot\,k$ neuron, and $l\cdot k=xl+k$  \\
$A_1$ & is the row address output port \\
$A_2$ & is the column address output port \\
\end{tabular} \\

In words, for every row, wait for any neuron in that row to spike.
When a neuron spikes within a row, transmit the row address. In parallel,
arbitrate between the spiked neurons in the row 
and transmit one neuron's column addresses while resetting it.

We still rely on the arbitration operator, 
so our next step is to decompose $AEXT$ into separate processes for 
arbitration ($ARB$) and concurrent transmition ($ARY$). The arbitration process is given by

\begin{csp}
ARB(m)\equiv*[[\langle\|j:1..m:#{L`j}->L`j;L`j\rangle]]
\end{csp}
where $m$ is the number of processes to arbitrate and $L_j$ is port communicating with the $j$th process.
The first $L_j$ communication informs the $j$th process it may proceed, 
and the second $L_j$ communication confirms when the $j$th process has finished 
before the arbiter moves on to the next process. 
With the arbiter defined, we define the concurrent transmition process

\begin{csp}
ARY(y,x)\equiv*[[\langle,l:1..y:\langle|k:1..x:#{P`{l\cdot\,k}}\rangle->R`l;A`1!enc(l)
             ,[\langle,k:1..x:#{P`{l\cdot\,k}}->C`k;A`2!enc(k),P`{l\cdot\,k};C`k\rangle];R`l\rangle]]
\end{csp}
where

\begin{tabular}[]{rl}
$R_l$ & is the port communicating with the row arbiter \\
$C_k$ & is the port communicating with the column arbiter \\
\end{tabular} \\

From $AEXT$ to $ARY$, we replace arbitration "$\vert$" with concurrancy "$,$" and
introduce communications with the row and column arbiters.
As $ARB$ has two communications with each client: one to grant permission and one to check for 
completion, $ARY$ has two communications with the each arbiter: one to request permission and
one to indicate completion.

Next, we split out the address encoding function of $ARY$ into its own process.

\begin{csp}
ENC(m)\equiv*[[\langle[]j:1..m:#{L`j}->A!enc(j),L`j\rangle]]
\end{csp}

where $L$ communicates with $ARY$. We can use selection, which assumes mutual exclusion, 
in the encoding process because the arbiters ensure that we only attempt to encode one address at time.
Introducing a row and column address encoder, we rewrite $ARY$ as

\begin{csp}
ARY(y,x)\equiv*[[\langle,l:1..y:\langle|k:1..x:#{P`{l\cdot\,k}}\rangle->R`l;A`l
             ,[\langle,k:1..x:#{P`{l\cdot\,k}}->C`k;D`k,P`{l\cdot\,k};C`k\rangle];R`l\rangle]]
\end{csp}

where the $A_l$ port communicates with the row address encoder
and the $D_k$ port communicates with the column address encoder.

Next, we decompose $ARY$ into concurrent row and column processes.

\begin{csp}
ROW(x)\equiv*[[\langle|k:1..x:#{P`k}\rangle->R;
            A,[\langle,k:1..x:#{P`k}->C`k,P`k\rangle];R]]
COL(y)\equiv*[[\langle[]l:1..y:#{R`l}->C;D,R`l;C\rangle]]
\end{csp}

where

\begin{tabular}[c]{rl}
$P_k$ & communicates with the $k$th neuron in a row \\
$R$ & communicates the the row arbiter \\
$A$ & communicates with the row address encoder \\
$C_k$ & communicates with the $k$th column process \\
$R_l$ & communicates with the $l$th row process \\
$C$ & communicates with the column arbiter \\
$D$ & communicates with the column address encoder \\
\end{tabular}

In words, we have decomposed $ARY$ into $y$ $ROW$ processes and $x$ $COL$ processes. 
When a neuron spikes, its $ROW$ process makes a request to the row arbiter.
Once granted permission, $ROW$, in parallel, communicates with the row address encoder, 
signals the $COL$ processes corresponding to spiked neurons in the row to proceed, 
and sends reset signals to the spiked neurons.
When the row addess encoder, $COL$ processes, and neuron resets have completed, 
$ROW$ signals the row arbiter that it has finished.
The $COL$ processes use selection between the $R_l$ ports in the column because the 
row arbiter has ensured that only one $ROW$ process will signal the $COL$ process
at a time. 

Once signaled by a $ROW$ process, $COL$ makes a request to the column arbiter.
After gaining permission, $COL$ communicates with the column address encoder while
acknowledging the $ROW$ process. Finally, $COL$ signals the column arbiter that 
it has finished.

Our final step is to read out the activated columns in a row in parallel
and transmit the row and column addresses sequentially.
To read out columns in parallel, we modify $ROW$ and convert $COL$ into $LTH$ and $BUS$.
To sequence the address transmitions, we create $SEQ$.

$ROW$ is modified as

\begin{csp}
ROW(x)\equiv*[[\langle,k:1..x:#{P`k}->w.k+\rangle];R;
           A,C!w,[\langle,k:1..x:w.k->P`k\rangle];R,w:=0]
\end{csp}

where

\begin{tabular}[c]{rl}
$w$ & is an $x$-bit integer indicating which neurons spiked \\
$C$ & interfaces with $BUS$ (see below) \\
\end{tabular}

Note how $w$ is cleared at the end of the process as well. 
$BUS$ and $LTH$ are defined as

\begin{csp}
BUS(y,x)\equiv*[[\langle[]l:1..y:#{R`l}->C!(R`l?)\rangle]]
LTH(x)\equiv*[R?w;[\langle,k:1..x:w.k->C`k;D`k,w.k-;C`k\rangle];R]
\end{csp}

where for $BUS$,

\begin{tabular}[c]{rl}
$R_l$ & interfaces with an instance of $ROW$ \\
$C$ & interfaces with $SEQ$ (see below) \\
\end{tabular}

and for $LTH$

\begin{tabular}[c]{rl}
$R$ & interfaces with $SEQ$ \\
$C_k$ & interfaces with an the column $ARB$ \\
$D_k$ & interfaces with an instance of $ENC$ \\
\end{tabular}

$BUS$ simply communicates data between $ROW$ and $SEQ$. 
$LTH$ reads in data from $SEQ$ and sends the column addresses to be encoded.
The second $R$ communication indicates that all column addresses have been encoded.

$SEQ$ sequences the events

\begin{csp}
SEQ(b,x)\equiv*[S!(D?),T!(R?);S;T!\phi\]\pll*[T!(C?)]
\end{csp}

where 

\begin{tabular}[c]{rl}
$D$ & reads in data from $BUS$ \\
$S$ & communicates with $LTH$ \\
$R$ & interfaces with the row $ENC$ \\
$C$ & interfaces with the column $ENC$ \\
$T$ & is the transmitter output port \\
$\phi$ & is a reserved keyword for a tailword \\
\end{tabular}

The second $S$ communication corresponds to $LTH$'s second $R$ communication and
indiciates that the latch is empty and that the transmitter may move on to the next row.
There is a timing assumption that row data arrives at $T$ before column data.
This assumption is valid because the row data has fewer processes to traverse
than column data before reaching $T$.

Now that we have decomposed the transmitter, we will proceed to HSE and PRS
for the decomposed components.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Event Generator ($EVT$)}
EVT interfaces the neuron with the rest of the transmitter. 
There is one EVT per neuron.

\paragraph{CHP}

Safe version:

\begin{csp}
EVT\equiv
  *[P;R;C;P;R;C]
\end{csp}

\noindent Closest to implementation:

\begin{csp}
EVT\equiv
  *[P\star\!R;C;P\star\!R;C]
\end{csp}

where

\begin{tabular}[]{rll}
  $P$ & (passive) & communicates with the neuron \\
  $R$ & (active) & communicates with row interface $INT$ \\
  $C$ & (active) & signals the column latch $LTH$ \\
\end{tabular} \\ \\

\paragraph{HSE}

\begin{hse}
*[[pi];ro+;[ri];co+,po+;
 [~pi];ro-;[~ri];co-,po-]
\end{hse}  

In words,

\begin{tabular}[]{rl}
  \code{[pi]} & wait for the neuron to spike \\
  \code{ro$\uparrow$;[ri]} & get permission from the arbiter interface / row arbiter to go ahead \\
  \code{co$\uparrow$,po$\uparrow$} & send the column signal and the neuron reset signal \\
  \code{[$\neg$pi]} & wait for the neuron to reset \\
  \code{ro$\downarrow$;[$\neg$ri]} & indicate that the row arbiter can select the next row. \\
  \code{co$\downarrow$, po$\downarrow$} & reset the column request and neuron reset signals \\
\end{tabular} \\ \\

Note that the \code{[$\neg$ri]} wait also indicates that the sequencer is done with this row 
(and acknowledges \code{co$\uparrow$}).

\paragraph{PRS}

\begin{prs2}
 pi&~ri->ro+
~pi->ro-

 ri&ro->co+,po+
~ri->co-,po-
\end{prs2}
The \code{ro$\uparrow$} guard is strengthened with 
\code{$\neg$ri} so that if the neuron spikes immediately after it has
reset, \code{[$\neg$pi]}, 
we do not try to raise \code{ro} while executing \code{ro$\downarrow$}. 
The \code{co$\uparrow$,po$\uparrow$} guard is strengthened with \code{ro} because \code{ri} is a wire connecting all EVT instances in a row. We only want the neurons that have actually spiked
to proceed with raising their column and neuron reset lines.

Next, we explicitly represent the isochronic fork between
\code{co} and \code{ro} using a local variable \code{u}.
To make the PRS CMOS-implementable, we invert the sense of \code{pi}, \code{co}, and \code{po}.

\begin{prs2}
 ~_pi & ~ri -> ro+
_pi         -> ro-

u  -> _co-
~u -> _co+

 ri & ro -> u-
~ri      -> u+

u  -> _po-
~u -> _po+
\end{prs2}

Initially, \code{$\neg$po$\land\neg$ro$\land\neg$co} is true. With reset circuitry,

\begin{prs2}
~sReset & ~_pi & ~ri -> ro+
pReset | _pi -> ro-

u  -> _co-
~u -> _co+

_sReset & ri & ro -> u-
~_pReset | ~ri -> u+

u  -> _po-
~u -> _po+
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interface ($INT$)}

There are two sets of INTs in the transmitter:
one for the rows and another for the columns.
The row INTs communicate with 
EVT, the row arbiter, and the y-address controller (ADY).
The column INTs communicate with 
the column address latch (LTH), the column arbiter, and the x-address controller (ADX).

\paragraph{CHP}

Safest:

\begin{csp}
INT\equiv
  *[V;C;E;V;C;E]
\end{csp}

Closest to implementation:

\begin{csp}
INT\equiv
  *[V\star\!(C,E);V\star\!(C,E)]
\end{csp}

Each row (column) $INT$ has the following ports:

\begin{tabular}[]{rll}
  $V$ & (passive) & receives requests from $EVT$ ($LTH$) \\
  $C$ & (active) & transmits request to the row (column) arbiter \\
  $E$ & (active) & communicates with the row (column) address controller \\
\end{tabular} \\ \\

For row INTs, \code{vi} is the wired-or output of all EVT \code{ro} ports in the row. Likewise,
\code{vo} is connected to all of the EVT \code{ri} ports in the row.

INT's HSE is given by

\begin{hse}
*[[vi];co+;[ci&~ei];eo+,vo+;
 [~vi&ei];co-;[~ci];eo-,vo-]
\end{hse}

In words,

\begin{tabular}[]{rl}
  \code{[vi]} & wait for a request from EVT (LTH) for the arbiter \\
  \code{co$\uparrow$} & send request to arbiter \\
  \code{[ci$\land\neg$ei]} & wait for arbiter to grant permission and address controller to finish previous transmission \\
  \code{eo$\uparrow$, vo$\uparrow$} & \specialcell[t]{l}{
  signal EVT to transmit column information (LTH to transmit column addresses) \\
  signal address latch to store address } \\
  \code{[$\neg$vi$\land$ei]} & \specialcell[t]{l}{
    wait for EVT to reset neuron (LTH to send column address) \\
    and ADY (ADX) to have latched the address} \\
  \code{co$\downarrow$;[$\neg$ci]} & release arbiter \\
  \code{eo$\downarrow$, vo$\downarrow$} & return EVT and ADY (LTH and ADX) signals to initial value \\
\end{tabular} \\ \\

Note how INT signals the address encoder first after gaining permission from the arbiter
and second after the arbiter has been released instead of before the arbiter has been released.
This is safe because INT waits until \code{ei} clears before the first \code{E} communication. 
That is, \code{E} follows a lazy-active protocol.
INT's PRS is given by

\begin{prs2}
 vi      -> co+
~vi & ei -> co-

 ci & ~ei -> eo+, vo+
~ci       -> eo-, vo-
\end{prs2}

Next, we represent the isochronic fork between \code{eo} and \code{vo}
using local variable \code{y}. 
To make the PRS CMOS-implementable, we introduce local variable \code{x} and
invert the sense of \code{vi} and \code{ei}.

\begin{prs2}
vi         -> x-
~vi & ~_ei -> x+

ci & _ei -> y-
~ci      -> y+

y  -> eo-
~y -> eo+

~x -> co+
x  -> co-

y  -> vo-
~y -> vo+
\end{prs2}

Initially, \code{$\neg$co$\land\neg$vo$\land\neg$eo} is true. With reset circuitry,

\begin{prs2}
_sReset & vi          -> x-
~_pReset | ~vi & ~_ei -> x+

_sReset & ci & _ei -> y-
~_pReset | ~ci     -> y+

y -> eo-
~y -> eo+

~x -> co+
x -> co-

y -> vo-
~y -> vo+
\end{prs2}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subfile{arb} % arbiter decomposition

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Latch ($LTH$)}

LTH is responsible for storing the column address of a neuron. 
LTH has the following ports:

\begin{tabular}[]{rll}
  \code{R} & (passive) & communication line with sequencer \\
  \code{Rk} & (passive) & column request from EVT \\
  \code{G} & (active) & request line to column interface (to the column arbiter) \\
\end{tabular} \\ \\

\code{Rk} is fed by the wired-or of all requests from EVTs in a column.
The HSE for LTH is given by:

\begin{hse}
*[[ri&rk];go+;ro+;[~ri&gi];go-;[~gi];ro-]
\end{hse}

In words,

\begin{tabular}[]{rl}
  \code{[ri$\land$rk]} & wait for column data and the go-ahead from the SEQ \\
  \code{go$\uparrow$} & raise request to column INT \\
  \code{ro$\uparrow$} & signal SEQ that the latch has data \\
  \code{[$\neg$ri$\land$gi]} & wait for SEQ and INT to indicate that address has transmitted \\
  \code{go$\downarrow$} & release INT request \\
  \code{[$\neg$gi]} & wait for INT to release ARB \\
  \code{ro$\downarrow$} & indicate to SEQ that LTH is empty? \\
\end{tabular} \\ \\

\begin{prs2}
 ri&rk->go+
~ri&gi->go-

 gi|go->ro+
~gi&~go->ro-
\end{prs2}

Note how we made the guard for \code{ro} combinational by using \code{gi} in
the pullup.

Questions:
\begin{itemize}
\item What is the open dot feeding into \code{rk}?
\item What prevents \code{rk} go low before \code{go} completes? 
How does sequencer enforce this?
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Y Address Controller ($ADY$)}

ADY captures the row address and has the following ports:

\begin{tabular}[]{rll}
  \code{di} & (input) & indicates that column data present \\
  \code{do} & (output) & indicates that row address latched \\
  \code{Y} & (passive) & SEQ's control signal \\
  \code{vy} & (input) & indicates validity of row address latch \\
\end{tabular} \\ \\

ADY's HSE is given by

\begin{hse}
*[[yi];yo+;[vy];do+;[~yi];yo-;[~vy&~di];do-]
\end{hse}

In words,

\begin{tabular}[]{rl}
  \code{[yi]} & wait for the go-ahead from the SEQ \\
  \code{yo$\uparrow$} & open row address latch to save and output row address \\
  \code{[vy]} & wait for row address latch data to become valid \\
  \code{do$\uparrow$} & signal INT and SEQ that row address has been latched \\
  \code{[$\neg$yi]} & wait for SEQ to complete row address transmission \\
  \code{yo$\downarrow$} & clear row address latch \\
  \code{[$\neg$vy$\land\neg$di]} & wait for row address latch to become neutral and column data to clear \\
  \code{do$\downarrow$} & signal INT and SEQ that row data has cleared \\
\end{tabular} \\ \\

PRS is given by

\begin{prs}
\end{prs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{X Address Controller ($ADX$)}

ADX captures the column address and has the following ports:

\begin{tabular}[]{rll}
  \code{X} & (passive) & SEQ control signal \\
  \code{C} & (output) & communicate data validity to INT \\
  \code{V} & (internal) & indicates that data is valid \\
\end{tabular} \\ \\

ADX's HSE is given by

\begin{hse}
*[[xi];xo+;[vx];co+;[~xi];xo-;[~vx];co-]
\end{hse}

In words,

\begin{tabular}[]{rl}
  \code{[xi]} & wait for the go-ahead from the SEQ \\
  \code{xo$\uparrow$} & open column address latch to save and output column address \\
  \code{[vx]} & wait for column address latch data to become valid \\
  \code{co$\uparrow$} & signal INT that column address has been latched \\
  \code{[$\neg$xi]} & wait for SEQ to complete column address transmission \\
  \code{xo$\downarrow$} & clear column address latch \\
  \code{[$\neg$vx]} & wait for column address latch to become neutral \\
  \code{co$\downarrow$} & signal INT that column data has cleared \\
\end{tabular} \\ \\

PRS is given by

\begin{prs}
\end{prs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sequencer ($SEQ$)}

\begin{tabular}[]{rll}
  \code{S} & (active) & (\code{si} and \code{sod}) communicates with LTH \\
  \code{so} & (internal) & state variable. High (low) means transmitting row (column or tail bit). \\
  \code{Y} & (output) & controls ADY \\
  \code{X} & (output) & controls ADX \\
  \code{T} & (active) & \code{to} signals the tailbit generator. \code{ti} is the ack from the attached receiver (or router) \\
\end{tabular} \\ \\

SEQ's HSE is given by

\begin{hse}
*[[~ti&si&so];yo+;[ti];so-;yo-;
  [~ti&~si&~so];to+;so+;[ti];to-]
\pll
*[[~ti&si&~so];xo+;[ti];xo-]
\end{hse}

SEQ contains two processes running in parallel. 
The top process is responsible for transmitting the row address and tail bit.
The bottom process is responsible for transmitting the column addresses.

In words, the top process works as follows

\begin{tabular}[]{rl}
  \code{[$\neg$ti$\land$si$\land$so]} & wait for the receiver to be ready, LTH to have data, and \code{so} to be high \\
  \code{yo$\uparrow$} & signal ADY to transmit the row address \\
  \code{[ti]} & wait for the receiver to acknowledge receipt of the row address \\
  \code{so$\downarrow$} & switch \code{so} to low state \\
  \code{yo$\downarrow$} & release ADY \\
  \code{[$\neg$ti$\land\neg$si$\land\neg$so]} & wait for the receiver to be ready, LTH to be clear, and \code{so} to be low \\
  \code{to$\uparrow$} & signal tail bit generator to transmit the tail bit \\
  \code{so$\uparrow$} & return \code{so} to high state \\
  \code{[ti]} & wait for the receiver to acknowledge receipt of the tail bit \\
  \code{to$\downarrow$} & release tail bit generator \\
\end{tabular} \\ \\

In words, the bottom process works as follows

\begin{tabular}[]{rl}
  \code{[$\neg$ti$\land$si$\land\neg$so]} & wait for the receiver to be ready, LTH to have data, and \code{so} to be low \\
  \code{xo$\uparrow$} & signal ADX to transmit the column address \\
  \code{[ti]} & wait for the receiver to acknowledge receipt of the column address \\
  \code{xo$\downarrow$} & release ADX \\
\end{tabular} \\ \\

Putting the top and bottom processes together, first, the top process has transmits the row address.
SEQ then switches to the bottom process, which transmits column addresses until LTH is empty. SEQ
then switches back to the top process which transmits the tail bit and returns SEQ to its initial state. 

PRS is given by

\begin{prs}
\end{prs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Test structures}
Here we describe some processes used to test the transmitter processes

\subsection{EVT}
For testing evt, I used a dummy LTH\_INT process that takes the place of the LTH and INT blocks.
LTH\_INT's HSE is given by

\begin{hse}
*[[vi&~rk];vo+;[~vi&rk];vo-]
\end{hse}

The LTH\_INT's PRS is given by 

\begin{prs}
vi&~rk -> vo+
~vi&rk -> vo-
\end{prs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
