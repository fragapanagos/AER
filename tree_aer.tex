\documentclass{article}
\usepackage{mystyle}

\begin{document}
\title{Tree AER}
\author{Sam Fok}
\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Transmitter ($AEXT$)}

Each node of the tree has two passive input ports, $D0$ and $D1$, and one active output port, $X$.

$D0$ and $D1$ are merged into $X$. Arbitration occurs between the $D0$ and $D1$ requests. 

\begin{csp}
*[[#{D0}->D0\*X!(0,D0?)
  \|#{D1}->D1\*X!(1,D1?)]]
\end{csp}

Where the bullet operator indicates the there will be some interleaving between the two communications. Which communication ordering hasn't been settled at this moment. All versions use the standard arbiter given by

\begin{hse}
*[[a0i->a0+;[~a0i];a0-
  \|a1i->a1+;[~a1i];a1-]]
\end{hse}

The intermediate nodes generate their arbiter requests using completion circuits:

\begin{hse}
*[[V(D0)];a0i+;[N(D0)];a0i-]
*[[V(D1)];a1i+;[N(D1)];a1i-]
\end{hse}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transmitter ordering $D\!\star\!X;D\!\star\!X$}

%%%%%%%%%%%%%%%%
\subsubsection{Leaf node}

\begin{csp}
*[[D0\star\!X!0;D0\star\!X
  \|D1\star\!X!1;D1\star\!X]]
\end{csp}

\begin{hse}
*[[a0->x`{00}+;[xi];d0o+;[~a0];x`{00}-;[~xi];d0o-
  []a1->x`{01}+;[xi];d1o+;[~a1];x`{01}-;[~xi];d1o-]]
\end{hse}

%%%%%%%%%%%%%%%%
\subsubsection{Intermediate nodes}

\begin{csp}
*[[D0\star\!X!(0,D0?);D0\star\!X
  \|D1\star\!X!(1,D1?);D1\star\!X]]
\end{csp}

\begin{hse}
*[[a0->x`{00}+,\langle,m:M:[d0`{m0}->x`{(m\+1)0}+[]d0`{m1}->x`{(m\+1)1}+]\rangle;[xi];d0o+;
  [~a0];x\!\Downarrow;[~xi];d0o-
  []a1->x`{01}+,\langle,m:M:[d1`{m0}->x`{(m\+1)0}+[]d1`{m1}->x`{(m\+1)1}+]\rangle;[xi];d1o+;
  [~a1];x\!\Downarrow;[~xi];d1o-
 ]]
\end{hse}

%%%%%%%%%%%%%%%%
\subsubsection{PRS}

\noindent \textbf{Leaf and intermediate nodes...creating the highest order bit}

\begin{prs2}
a0 & ~d1o -> x`{00}+
~a0 | d1o -> x`{00}-

a1 & ~d0o -> x`{01}+
~a1 | d0o -> x`{01}-
\end{prs2}

\noindent \textbf{Intermediate nodes only...transmitting the existing lower order bits}

\begin{prs2}
(a0 & d0`{m0} | a1 & d1`{m0}) & ~d0o & ~d1o -> x`{(m\+1)0}+

~a0 & d0o | ~a1 & d1o -> x`{(m\+1)0}-
\end{prs2}

\begin{prs2}
(a0 & d0`{m1} | a1 & d1`{m1}) & ~d0o & ~d1o -> x`{(m\+1)1}+

~a0 & d0o | ~a1 & d1o -> x`{(m\+1)1}-
\end{prs2}

\noindent \textbf{Common to all nodes...}

\begin{prs2}
xi & a0 & ~d1o -> d0o+
~xi -> d0o-

xi & a1 & ~d0o -> d1o+
~xi -> d1o-
\end{prs2}

%%%%%%%%%%%%%%%%
\subsubsection{CMOS-implementable PRS}
We alternate between version 1 and 2 described below at each layer. Using only one of the versions would require more inverters. The leaves will use version 1, though this is arbitrary.

\noindent \\ \textbf{Version 0}

\noindent \textbf{Leaf and intermediate nodes...creating the highest order bit}

\begin{prs2}
~_a0 & ~d1o -> x`{00}+
_a0 | d1o -> x`{00}-

~_a1 & ~d0o -> x`{01}+
_a1 | d0o -> x`{01}-
\end{prs2}

\noindent \textbf{Intermediate nodes only...transmitting the existing lower order bits}

\begin{prs2}
(~_a0 & ~_d0`{m0} | ~_a1 & ~_d1`{m0}) & ~d0o & ~d1o -> x`{(m\+1)0}+

_a0 & d0o | _a1 & d1o -> x`{(m\+1)0}-
\end{prs2}

\begin{prs2}
(~_a0 & ~_d0`{m1} | ~_a1 & ~_d1`{m1}) & ~d0o & ~d1o -> x`{(m\+1)1}+

_a0 & d0o | _a1 & d1o -> x`{(m\+1)1}-
\end{prs2}

\noindent \textbf{Common to all nodes...}

\begin{prs2}
~_xi & ~_a0 & ~d1o -> d0o+
_xi -> d0o-

~_xi & ~_a1 & ~d0o -> d1o+
_xi -> d1o-
\end{prs2}

\noindent \\ \textbf{Version 1}

\noindent \textbf{Leaf and intermediate nodes...creating the highest order bit}

\begin{prs2}
a0 & _d1o -> _x`{00}-
~a0 | ~_d1o -> _x`{00}+

a1 & _d0o -> _x`{01}-
~a1 | ~_d0o -> _x`{01}+
\end{prs2}

\noindent \textbf{Intermediate nodes only...transmitting the existing lower order bits}

\begin{prs2}
(a0 & d0`{m0} | a1 & d1`{m0}) & _d0o & _d1o -> _x`{(m\+1)0}-

~a0 & ~_d0o | ~a1 & ~_d1o -> _x`{(m\+1)0}+
\end{prs2}

\begin{prs2}
(a0 & d0`{m1} | a1 & d1`{m1}) & _d0o & _d1o -> _x`{(m\+1)1}-

~a0 & ~_d0o | ~a1 & ~_d1o -> _x`{(m\+1)1}+
\end{prs2}

\noindent \textbf{Common to all nodes...}

\begin{prs2}
xi & a0 & _d1o -> _d0o-
~xi -> _d0o+

xi & a1 & _d0o -> _d1o-
~xi -> _d1o+
\end{prs2}

%%%%%%%%%%%%%%%%
\subsubsection{Accounting}

For $4096$ neurons ($12$ bits)...

\noindent The valid/neutral detectors used as input to the arbiters at each level would require $81,572$ transistors. Each node has 2 v/n detectors. The bitwidth of the nodes decrease as we go down the tree, but the number of nodes grows exponentially.
$$2(146)+4(132)+8(118)+16(104)+32(90)+64(76)+128(62)+256(48)+512(34)+1024(20)+2048(6)=81572$$

\noindent An arbiter requires $12$ transistors. $4095$ nodes worth of arbiters requires $49,140$ transistors.

\noindent The merging circuitry will require $105,662$ transistors. We'll need an additional $8192$ transistors to interface with all the neurons because of inverters on the neuron acknowledge signals.

\noindent This brings our total to $244,566$ transistors for the transmitter.

\noindent At $2\mu\textrm{m}^2$ per $10$ transistors in $28\mathrm{nm}$, this requires $48,913\mu\textrm{m}^2$ total, or approximately $11.95\mu\textrm{m}^2$ per neuron.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Receiver ($AERV$)}

The receiver simply looks at the highest order bit and directs the traffic accordingly.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Receiver ordering: $D\!\star\!X;D\!\star\!X$}

%%%%%%%%%%%%%%%%
\subsubsection{Leaf level}

\begin{csp}
*[[D=0->D\star\!X0[]D=1->D\star\!X1];D\star\!(X0,X1)]
\end{csp}

\begin{hse}
*[[d`{00}];x0o+;[x0i];do+;[~d`{00}];x0o-,x1o-;[~x0i&~x1i];do-]
*[[d`{01}];x1o+;[x1i];do+;[~d`{01}];x0o-,x1o-;[~x0i&~x1i];do-]
\end{hse}

%%%%%%%%%%%%%%%%
\subsubsection{Higher levels}

\begin{csp}
*[D?y\star\![y=0->X0!y[]y=1->X1!y];D\star\!(X0,X1)]
\end{csp}

\begin{hse}
*[[d`{00}];\langle,m:1..M\-1:[d`{m0}->x0`{(m\-1)0}+[]d`{m1}->x0`{(m\-1)1}+]\rangle;[x0i];do+;
  [~d`{00}];x0\!\Downarrow;[~x0i&~x1i];do-]
*[[d`{01}];\langle,m:1..M\-1:[d`{m0}->x1`{(m\-1)0}+[]d`{m1}->x1`{(m\-1)1}+]\rangle;[x1i];do+;
  [~d`{01}];x1\!\Downarrow;[~x0i&~x1i];do-]
\end{hse}

%%%%%%%%%%%%%%%%
\subsubsection{PRS}

\textbf{Leaf node...}

\begin{prs2}
d`{00} -> x0o+
~d`{00} -> x0o-

d`{01} -> x1o+
~d`{01} -> x1o-
\end{prs2}

\noindent \textbf{Intermediate nodes...}

\begin{prs2}
d`{00} & d`{m0} -> x0`{(m\-1)0}+
~d`{00} & ~d`{m0} -> x0`{(m\-1)0}-

d`{01} & d`{m0} -> x1`{(m\-1)0}+
~d`{01} & ~d`{m0} -> x1`{(m\-1)0}-
\end{prs2}

\begin{prs2}
d`{00} & d`{m1} -> x0`{(m\-1)1}+
~d`{00} & ~d`{m1} -> x0`{(m\-1)1}-

d`{01} & d`{m0} -> x1`{(m\-1)1}+
~d`{01} & ~d`{m0} -> x1`{(m\-1)1}-
\end{prs2}

\noindent \textbf{Common to all nodes...}

\begin{prs2}
x0i | x1i -> do+
~x0i & ~x1i -> do-
\end{prs2}

%%%%%%%%%%%%%%%%
\subsubsection{CMOS-implementable PRS}

\textbf{Leaf node...}

\noindent Wires. No transistors required.

\begin{prs2}
d`{00} -> x0o+
~d`{00} -> x0o-

d`{01} -> x1o+
~d`{01} -> x1o-
\end{prs2}

\noindent \textbf{Intermediate nodes...}

\begin{prs2}
d`{00} & d`{m0} -> _x0`{(m\-1)0}+
~d`{00} & ~d`{m0} -> _x0`{(m\-1)0}-

d`{01} & d`{m0} -> _x1`{(m\-1)0}+
~d`{01} & ~d`{m0} -> _x1`{(m\-1)0}-
\end{prs2}

\begin{prs2}
d`{00} & d`{m1} -> _x0`{(m\-1)1}+
~d`{00} & ~d`{m1} -> _x0`{(m\-1)1}-

d`{01} & d`{m0} -> _x1`{(m\-1)1}+
~d`{01} & ~d`{m0} -> _x1`{(m\-1)1}-
\end{prs2}


\begin{prs2}
_x0`{(m\-1)0} -> x0`{(m\-1)0}-
~_x0`{(m\-1)0} -> x0`{(m\-1)0}+

_x1`{(m\-1)0} -> x1`{(m\-1)0}-
~_x1`{(m\-1)0} -> x1`{(m\-1)0}+
\end{prs2}

\begin{prs2}
_x0`{(m\-1)1} -> x0`{(m\-1)1}-
~_x0`{(m\-1)1} -> x0`{(m\-1)1}+

_x1`{(m\-1)1} -> x1`{(m\-1)1}-
~_x1`{(m\-1)1} -> x1`{(m\-1)1}+
\end{prs2}

\noindent 4 C-elements per output bit = 32 transistors per output bit.

\noindent \\ \textbf{Common to all nodes ($N-1$ nodes)...}

\noindent We implement the OR gate by alternanting NAND and NOR gates at each level of the tree.

\noindent Starting at the bottom of the tree and at every other level:
\begin{prs2}
x0i | x1i -> _do+
~x0i & ~x1i -> _do-
\end{prs2}

\noindent Starting at one up from the bottom of the tree and at every other level:
\begin{prs2}
_x0i & _x1i -> do-
~_x0i | ~_x1i -> do+
\end{prs2}

\noindent This requires $4$ transistors per node. If there are an odd number of levels, we add an inverter to the top of the tree.

%%%%%%%%%%%%%%%%
\subsubsection{Accounting}

With 1-of-2 encoding (dual-rail encoding) and 4096 neurons, the receiver requires 147,036 transistors across 20,427 gates. To arrive at this number, we note that the receiver is organized as a tree with 4095 nodes. Each node of the tree can be divided into circuitry assocaited with communicating on $X$, which outputs data to the lower layers and circuitry associated with communicating on $D$, which acknowledges data from higher layers. The output circuitry accounting is in Table~\ref{tab:recv}. The receiver output circuitry requires 130,656 transistors across 16,332 gates. The receiver acknowledge circuitry requires 16,380 transistors across 4095 gates.

\noindent At 2$\mu\textrm{m}^2$ per 10 transistors, the receiver requires 29,407$\mu\textrm{m}^2$ total or approximately 7.2$\mu\textrm{m}^2$ per neuron. 

\noindent At 2$\mu\textrm{m}^2$ per gate, the receiver requires 40,854$\mu\textrm{m}^2$ total or approximately 10$\mu\textrm{m}^2$ per neuron.

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|l|l|l|l|}
  \hline
  Level & Nodes & Bits & Gates/Node & Transistors/Node & Gates & Transistors \\
  \hline
  (root) 0 & 1 & 11 & 44 & 352 & 44 & 352 \\
  \hline
  1 & 2 & 10 & 40 & 320 & 80 & 640 \\
  \hline
  2 & 4 & 9 & 36 & 288 & 144 & 1152 \\
  \hline
  3 & 8 & 8 & 32 & 246 & 256 & 2048 \\
  \hline
  4 & 16 & 7 & 28 & 224 & 448 & 3584 \\
  \hline
  5 & 32 & 6 & 24 & 192 & 768 & 6144 \\
  \hline
  6 & 64 & 5 & 20 & 160 & 1280 & 10240 \\
  \hline
  7 & 128 & 4 & 16 & 128 & 2048 & 16384 \\
  \hline
  8 & 256 & 3 & 12 & 96 & 3072 & 24576 \\
  \hline
  9 & 512 & 2 & 8 & 64 & 4096 & 32768 \\
  \hline
  10 & 1024 & 1 & 4 & 32 & 4096 & 32768 \\
  \hline
  11 & 2048 & 0 & 0 & 0 & 0 & 0 \\
  \hline
  \end{tabular}
  \caption{\label{tab:recv} Receiver output circuitry requirements for 4096 neurons.}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transmitter ordering: $D;X;X;D$}

I would prefer this ordering because it would allow the data to be pipelined, but the PRS may not be so simple...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Transmitter ordering: $D\!\star\!X;X;D$}

%%%%%%%%%%%%%%%%
\subsubsection{First level}

\begin{csp}
*[[D0\star\!X!0;X;D0
  \|D1\star\!X!1;X;D1]]
\end{csp}

\begin{hse}
*[[a0->x`{00}+;[xi];d0o+;x`{00}-;[~xi&~a0];d0o-
  []a1->x`{01}+;[xi];d1o+;x`{01}-;[~xi&~a1];d1o-]]
\end{hse}

%%%%%%%%%%%%%%%%
\subsubsection{Subsequent levels}

\begin{csp}
*[[D0\star\!X!(0,D0?);X;D0
  \|D1\star\!X!(1,D1?);X;D1]]
\end{csp}

\begin{hse}
*[[a0->x`{00}+,\langle,m:M:[d0`{m0}->x`{(m\+1)0}+[]d0`{m1}->x`{(m\+1)1}+]\rangle;[xi];d0o+;
   x\!\Downarrow;[~xi&~a0];d0o-
  []a1->x`{01}+,\langle,m:M:[d1`{m0}->x`{(m\+1)0}+[]d1`{m1}->x`{(m\+1)1}+]\rangle;[xi];d1o+;
   x\!\Downarrow;[~xi&~a1];d1o-
 ]]
\end{hse}

%%%%%%%%%%%%%%%%
\subsubsection{PRS}

First and subsequent level...

\begin{prs2}
a0 & ~d1o & ~d0o-> x`{00}+
d0o -> x`{00}-

a1 & ~d0o & ~d1o -> x`{01}+
d1o -> x`{01}-
\end{prs2}

\noindent Subsequent levels only...

\begin{prs2}
((a0 & d0`{m0}) | (a1 & d1`{m0})) & ~d0o & ~d1o -> x`{(m\+1)0}+

d0o | d1o -> x`{(m\+1)0}-
\end{prs2}

\begin{prs2}
((a0 & d0`{m1}) | (a1 & d1`{m1})) & ~d0o & ~d1o -> x`{(m\+1)1}+

d0o | d1o -> x`{(m\+1)1}-
\end{prs2}

\noindent Common to all levels...

\begin{prs2}
xi & a0 & ~d1o -> d0o+
~xi & ~a0 -> d0o-

xi & a1 & ~d0o-> d1o+
~xi & ~a1 -> d1o-
\end{prs2}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document}
